(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["steelseries"] = factory();
	else
		root["steelseries"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/steelseries.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Altimeter.js":
/*!**************************!*\
  !*** ./src/Altimeter.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony import */ var _drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawRadialCustomImage */ \"./src/drawRadialCustomImage.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createLcdBackgroundImage */ \"./src/createLcdBackgroundImage.js\");\n/* harmony import */ var _drawTitleImage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./drawTitleImage */ \"./src/drawTitleImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst Altimeter = function (canvas, parameters) {\n  parameters = parameters || {}\n  // parameters\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_8__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_8__[\"BackgroundColor\"].DARK_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let titleString =\n    undefined === parameters.titleString ? '' : parameters.titleString\n  let unitString =\n    undefined === parameters.unitString ? '' : parameters.unitString\n  const unitAltPos = undefined !== parameters.unitAltPos\n  const knobType =\n    undefined === parameters.knobType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_8__[\"KnobType\"].METAL_KNOB\n      : parameters.knobType\n  const knobStyle =\n    undefined === parameters.knobStyle ? _definitions__WEBPACK_IMPORTED_MODULE_8__[\"KnobStyle\"].BLACK : parameters.knobStyle\n  let lcdColor =\n    undefined === parameters.lcdColor ? _definitions__WEBPACK_IMPORTED_MODULE_8__[\"LcdColor\"].BLACK : parameters.lcdColor\n  const lcdVisible =\n    undefined === parameters.lcdVisible ? true : parameters.lcdVisible\n  const digitalFont =\n    undefined === parameters.digitalFont ? false : parameters.digitalFont\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_8__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  const customLayer =\n    undefined === parameters.customLayer ? null : parameters.customLayer\n  //\n  const minValue = 0\n  const maxValue = 10\n  let value = minValue\n  let value100 = 0\n  let value1000 = 0\n  let value10000 = 0\n  let angleStep100ft\n  let angleStep1000ft\n  let angleStep10000ft\n  const tickLabelPeriod = 1 // Draw value at every 10th tickmark\n  let tween\n  let repainting = false\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_7__[\"getCanvasContext\"])(canvas) // Get the canvas context\n  // Constants\n  const TICKMARK_OFFSET = _tools__WEBPACK_IMPORTED_MODULE_7__[\"PI\"]\n  //\n  let initialized = false\n  // **************   Buffer creation  ********************\n  // Buffer for the frame\n  const frameBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_7__[\"createBuffer\"])(size, size)\n  let frameContext = frameBuffer.getContext('2d')\n  // Buffer for the background\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_7__[\"createBuffer\"])(size, size)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  let lcdBuffer\n\n  // Buffer for 10000ft pointer image painting code\n  const pointer10000Buffer = Object(_tools__WEBPACK_IMPORTED_MODULE_7__[\"createBuffer\"])(size, size)\n  let pointer10000Context = pointer10000Buffer.getContext('2d')\n\n  // Buffer for 1000ft pointer image painting code\n  const pointer1000Buffer = Object(_tools__WEBPACK_IMPORTED_MODULE_7__[\"createBuffer\"])(size, size)\n  let pointer1000Context = pointer1000Buffer.getContext('2d')\n\n  // Buffer for 100ft pointer image painting code\n  const pointer100Buffer = Object(_tools__WEBPACK_IMPORTED_MODULE_7__[\"createBuffer\"])(size, size)\n  let pointer100Context = pointer100Buffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_7__[\"createBuffer\"])(size, size)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n  // End of variables\n\n  // Get the canvas context and clear it\n  mainCtx.save()\n  // Has a size been specified?\n  size =\n    size === 0 ? Math.min(mainCtx.canvas.width, mainCtx.canvas.height) : size\n\n  // Set the size\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  const imageWidth = size\n  const imageHeight = size\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight / 2\n\n  const unitStringPosY = unitAltPos ? imageHeight * 0.68 : false\n\n  const stdFont = Math.floor(imageWidth * 0.09) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_7__[\"stdFontName\"]\n\n  // **************   Image creation  ********************\n  const drawLcdText = function (value) {\n    mainCtx.save()\n    mainCtx.textAlign = 'right'\n    mainCtx.textBaseline = 'middle'\n    mainCtx.strokeStyle = lcdColor.textColor\n    mainCtx.fillStyle = lcdColor.textColor\n\n    if (\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_8__[\"LcdColor\"].STANDARD ||\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_8__[\"LcdColor\"].STANDARD_GREEN\n    ) {\n      mainCtx.shadowColor = 'gray'\n      mainCtx.shadowOffsetX = imageWidth * 0.007\n      mainCtx.shadowOffsetY = imageWidth * 0.007\n      mainCtx.shadowBlur = imageWidth * 0.009\n    }\n    if (digitalFont) {\n      mainCtx.font = Math.floor(imageWidth * 0.075) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_7__[\"lcdFontName\"]\n    } else {\n      mainCtx.font = Math.floor(imageWidth * 0.075) + 'px bold ' + _tools__WEBPACK_IMPORTED_MODULE_7__[\"stdFontName\"]\n    }\n    mainCtx.fillText(\n      Math.round(value),\n      (imageWidth + imageWidth * 0.4) / 2 - 4,\n      imageWidth * 0.607,\n      imageWidth * 0.4\n    )\n    mainCtx.restore()\n  }\n\n  const drawTickmarksImage = function (\n    ctx,\n    freeAreaAngle,\n    offset,\n    minVal,\n    maxVal,\n    angleStep\n  ) {\n    const MEDIUM_STROKE = Math.max(imageWidth * 0.012, 2)\n    const THIN_STROKE = Math.max(imageWidth * 0.007, 1.5)\n    const TEXT_DISTANCE = imageWidth * 0.13\n    const MED_LENGTH = imageWidth * 0.05\n    const MAX_LENGTH = imageWidth * 0.07\n    const RADIUS = imageWidth * 0.4\n    let counter = 0\n    let sinValue = 0\n    let cosValue = 0\n    let alpha // angle for tickmarks\n    let valueCounter // value for tickmarks\n    const ALPHA_START = -offset - freeAreaAngle / 2\n\n    ctx.save()\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.font = stdFont\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n\n    for (\n      alpha = ALPHA_START, valueCounter = 0;\n      valueCounter <= 10;\n      alpha -= angleStep * 0.1, valueCounter += 0.1\n    ) {\n      sinValue = Math.sin(alpha)\n      cosValue = Math.cos(alpha)\n\n      // tickmark every 2 units\n      if (counter % 2 === 0) {\n        ctx.lineWidth = THIN_STROKE\n        // Draw ticks\n        ctx.beginPath()\n        ctx.moveTo(\n          centerX + (RADIUS - MED_LENGTH) * sinValue,\n          centerY + (RADIUS - MED_LENGTH) * cosValue\n        )\n        ctx.lineTo(centerX + RADIUS * sinValue, centerY + RADIUS * cosValue)\n        ctx.closePath()\n        ctx.stroke()\n      }\n\n      // Different tickmark every 10 units\n      if (counter === 10 || counter === 0) {\n        ctx.lineWidth = MEDIUM_STROKE\n\n        // if gauge is full circle, avoid painting maxValue over minValue\n        if (freeAreaAngle === 0) {\n          if (Math.round(valueCounter) !== maxValue) {\n            ctx.fillText(\n              Math.round(valueCounter).toString(),\n              centerX + (RADIUS - TEXT_DISTANCE) * sinValue,\n              centerY + (RADIUS - TEXT_DISTANCE) * cosValue\n            )\n          }\n        }\n        counter = 0\n\n        // Draw ticks\n        ctx.beginPath()\n        ctx.moveTo(\n          centerX + (RADIUS - MAX_LENGTH) * sinValue,\n          centerY + (RADIUS - MAX_LENGTH) * cosValue\n        )\n        ctx.lineTo(centerX + RADIUS * sinValue, centerY + RADIUS * cosValue)\n        ctx.closePath()\n        ctx.stroke()\n      }\n      counter++\n    }\n    ctx.restore()\n  }\n\n  const draw100ftPointer = function (ctx, shadow) {\n    let grad\n\n    if (shadow) {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'\n      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'\n    } else {\n      grad = ctx.createLinearGradient(\n        0,\n        imageHeight * 0.168224,\n        0,\n        imageHeight * 0.626168\n      )\n      grad.addColorStop(0, '#ffffff')\n      grad.addColorStop(0.31, '#ffffff')\n      grad.addColorStop(0.3101, '#ffffff')\n      grad.addColorStop(0.32, '#202020')\n      grad.addColorStop(1, '#202020')\n      ctx.fillStyle = grad\n    }\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.518691, imageHeight * 0.471962)\n    ctx.bezierCurveTo(\n      imageWidth * 0.514018,\n      imageHeight * 0.471962,\n      imageWidth * 0.509345,\n      imageHeight * 0.467289,\n      imageWidth * 0.509345,\n      imageHeight * 0.467289\n    )\n    ctx.lineTo(imageWidth * 0.509345, imageHeight * 0.200934)\n    ctx.lineTo(imageWidth * 0.5, imageHeight * 0.168224)\n    ctx.lineTo(imageWidth * 0.490654, imageHeight * 0.200934)\n    ctx.lineTo(imageWidth * 0.490654, imageHeight * 0.467289)\n    ctx.bezierCurveTo(\n      imageWidth * 0.490654,\n      imageHeight * 0.467289,\n      imageWidth * 0.481308,\n      imageHeight * 0.471962,\n      imageWidth * 0.481308,\n      imageHeight * 0.471962\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.471962,\n      imageHeight * 0.481308,\n      imageWidth * 0.467289,\n      imageHeight * 0.490654,\n      imageWidth * 0.467289,\n      imageHeight * 0.5\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.467289,\n      imageHeight * 0.514018,\n      imageWidth * 0.476635,\n      imageHeight * 0.528037,\n      imageWidth * 0.490654,\n      imageHeight * 0.53271\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.490654,\n      imageHeight * 0.53271,\n      imageWidth * 0.490654,\n      imageHeight * 0.579439,\n      imageWidth * 0.490654,\n      imageHeight * 0.588785\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.485981,\n      imageHeight * 0.593457,\n      imageWidth * 0.481308,\n      imageHeight * 0.59813,\n      imageWidth * 0.481308,\n      imageHeight * 0.607476\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.481308,\n      imageHeight * 0.616822,\n      imageWidth * 0.490654,\n      imageHeight * 0.626168,\n      imageWidth * 0.5,\n      imageHeight * 0.626168\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.509345,\n      imageHeight * 0.626168,\n      imageWidth * 0.518691,\n      imageHeight * 0.616822,\n      imageWidth * 0.518691,\n      imageHeight * 0.607476\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.518691,\n      imageHeight * 0.59813,\n      imageWidth * 0.514018,\n      imageHeight * 0.593457,\n      imageWidth * 0.504672,\n      imageHeight * 0.588785\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.504672,\n      imageHeight * 0.579439,\n      imageWidth * 0.504672,\n      imageHeight * 0.53271,\n      imageWidth * 0.509345,\n      imageHeight * 0.53271\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.523364,\n      imageHeight * 0.528037,\n      imageWidth * 0.53271,\n      imageHeight * 0.514018,\n      imageWidth * 0.53271,\n      imageHeight * 0.5\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.53271,\n      imageHeight * 0.490654,\n      imageWidth * 0.528037,\n      imageHeight * 0.481308,\n      imageWidth * 0.518691,\n      imageHeight * 0.471962\n    )\n    ctx.closePath()\n    ctx.fill()\n    ctx.restore()\n  }\n\n  const draw1000ftPointer = function (ctx) {\n    const grad = ctx.createLinearGradient(\n      0,\n      imageHeight * 0.401869,\n      0,\n      imageHeight * 0.616822\n    )\n    grad.addColorStop(0, '#ffffff')\n    grad.addColorStop(0.51, '#ffffff')\n    grad.addColorStop(0.52, '#ffffff')\n    grad.addColorStop(0.5201, '#202020')\n    grad.addColorStop(0.53, '#202020')\n    grad.addColorStop(1, '#202020')\n    ctx.fillStyle = grad\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.518691, imageHeight * 0.471962)\n    ctx.bezierCurveTo(\n      imageWidth * 0.514018,\n      imageHeight * 0.462616,\n      imageWidth * 0.528037,\n      imageHeight * 0.401869,\n      imageWidth * 0.528037,\n      imageHeight * 0.401869\n    )\n    ctx.lineTo(imageWidth * 0.5, imageHeight * 0.331775)\n    ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.401869)\n    ctx.bezierCurveTo(\n      imageWidth * 0.471962,\n      imageHeight * 0.401869,\n      imageWidth * 0.485981,\n      imageHeight * 0.462616,\n      imageWidth * 0.481308,\n      imageHeight * 0.471962\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.471962,\n      imageHeight * 0.481308,\n      imageWidth * 0.467289,\n      imageHeight * 0.490654,\n      imageWidth * 0.467289,\n      imageHeight * 0.5\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.467289,\n      imageHeight * 0.514018,\n      imageWidth * 0.476635,\n      imageHeight * 0.528037,\n      imageWidth * 0.490654,\n      imageHeight * 0.53271\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.490654,\n      imageHeight * 0.53271,\n      imageWidth * 0.462616,\n      imageHeight * 0.574766,\n      imageWidth * 0.462616,\n      imageHeight * 0.593457\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.467289,\n      imageHeight * 0.616822,\n      imageWidth * 0.5,\n      imageHeight * 0.612149,\n      imageWidth * 0.5,\n      imageHeight * 0.612149\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.5,\n      imageHeight * 0.612149,\n      imageWidth * 0.53271,\n      imageHeight * 0.616822,\n      imageWidth * 0.537383,\n      imageHeight * 0.593457\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.537383,\n      imageHeight * 0.574766,\n      imageWidth * 0.509345,\n      imageHeight * 0.53271,\n      imageWidth * 0.509345,\n      imageHeight * 0.53271\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.523364,\n      imageHeight * 0.528037,\n      imageWidth * 0.53271,\n      imageHeight * 0.514018,\n      imageWidth * 0.53271,\n      imageHeight * 0.5\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.53271,\n      imageHeight * 0.490654,\n      imageWidth * 0.528037,\n      imageHeight * 0.481308,\n      imageWidth * 0.518691,\n      imageHeight * 0.471962\n    )\n    ctx.closePath()\n    ctx.fill()\n    ctx.restore()\n  }\n\n  const draw10000ftPointer = function (ctx) {\n    ctx.fillStyle = '#ffffff'\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.518691, imageHeight * 0.471962)\n    ctx.bezierCurveTo(\n      imageWidth * 0.514018,\n      imageHeight * 0.471962,\n      imageWidth * 0.514018,\n      imageHeight * 0.467289,\n      imageWidth * 0.514018,\n      imageHeight * 0.467289\n    )\n    ctx.lineTo(imageWidth * 0.514018, imageHeight * 0.317757)\n    ctx.lineTo(imageWidth * 0.504672, imageHeight * 0.303738)\n    ctx.lineTo(imageWidth * 0.504672, imageHeight * 0.182242)\n    ctx.lineTo(imageWidth * 0.53271, imageHeight * 0.116822)\n    ctx.lineTo(imageWidth * 0.462616, imageHeight * 0.116822)\n    ctx.lineTo(imageWidth * 0.495327, imageHeight * 0.182242)\n    ctx.lineTo(imageWidth * 0.495327, imageHeight * 0.299065)\n    ctx.lineTo(imageWidth * 0.485981, imageHeight * 0.317757)\n    ctx.lineTo(imageWidth * 0.485981, imageHeight * 0.467289)\n    ctx.bezierCurveTo(\n      imageWidth * 0.485981,\n      imageHeight * 0.467289,\n      imageWidth * 0.485981,\n      imageHeight * 0.471962,\n      imageWidth * 0.481308,\n      imageHeight * 0.471962\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.471962,\n      imageHeight * 0.481308,\n      imageWidth * 0.467289,\n      imageHeight * 0.490654,\n      imageWidth * 0.467289,\n      imageHeight * 0.5\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.467289,\n      imageHeight * 0.518691,\n      imageWidth * 0.481308,\n      imageHeight * 0.53271,\n      imageWidth * 0.5,\n      imageHeight * 0.53271\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.518691,\n      imageHeight * 0.53271,\n      imageWidth * 0.53271,\n      imageHeight * 0.518691,\n      imageWidth * 0.53271,\n      imageHeight * 0.5\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.53271,\n      imageHeight * 0.490654,\n      imageWidth * 0.528037,\n      imageHeight * 0.481308,\n      imageWidth * 0.518691,\n      imageHeight * 0.471962\n    )\n    ctx.closePath()\n    ctx.fill()\n  }\n\n  function calcAngleStep () {\n    angleStep100ft = _tools__WEBPACK_IMPORTED_MODULE_7__[\"TWO_PI\"] / (maxValue - minValue)\n    angleStep1000ft = angleStep100ft / 10\n    angleStep10000ft = angleStep1000ft / 10\n  }\n\n  function calcValues () {\n    value100 = (value % 1000) / 100\n    value1000 = (value % 10000) / 100\n    value10000 = (value % 100000) / 100\n  }\n\n  // **************   Initialization  ********************\n  // Draw all static painting code to background\n  const init = function (parameters) {\n    parameters = parameters || {}\n    // Parameters\n    const drawFrame2 =\n      undefined === parameters.frame ? false : parameters.frame\n    const drawBackground2 =\n      undefined === parameters.background ? false : parameters.background\n    const drawPointers =\n      undefined === parameters.pointers ? false : parameters.pointers\n    const drawForeground2 =\n      undefined === parameters.foreground ? false : parameters.foreground\n\n    initialized = true\n\n    calcAngleStep()\n\n    // Create frame in frame buffer (backgroundBuffer)\n    if (drawFrame2 && frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        frameContext,\n        frameDesign,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    if (drawBackground2 && backgroundVisible) {\n      // Create background in background buffer (backgroundBuffer)\n      Object(_drawBackground__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      // Create custom layer in background buffer (backgroundBuffer)\n      Object(_drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        backgroundContext,\n        customLayer,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      // Create tickmarks in background buffer (backgroundBuffer)\n      drawTickmarksImage(\n        backgroundContext,\n        0,\n        TICKMARK_OFFSET,\n        0,\n        10,\n        angleStep100ft,\n        tickLabelPeriod,\n        0,\n        true,\n        true,\n        null\n      )\n\n      // Create title in background buffer (backgroundBuffer)\n      Object(_drawTitleImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n        backgroundContext,\n        imageWidth,\n        imageHeight,\n        titleString,\n        unitString,\n        backgroundColor,\n        true,\n        true,\n        unitStringPosY\n      )\n    }\n\n    // Create lcd background if selected in background buffer (backgroundBuffer)\n    if (drawBackground2 && lcdVisible) {\n      lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n        imageWidth * 0.4,\n        imageHeight * 0.09,\n        lcdColor\n      )\n      backgroundContext.drawImage(\n        lcdBuffer,\n        (imageWidth - imageWidth * 0.4) / 2,\n        imageHeight * 0.56\n      )\n    }\n\n    if (drawPointers) {\n      // Create 100ft pointer in buffer\n      draw100ftPointer(pointer100Context, false)\n      // Create 1000ft pointer in buffer\n      draw1000ftPointer(pointer1000Context, false)\n      // Create 10000ft pointer in buffer\n      draw10000ftPointer(pointer10000Context, false)\n    }\n\n    if (drawForeground2 && foregroundVisible) {\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        true,\n        knobType,\n        knobStyle\n      )\n    }\n  }\n\n  const resetBuffers = function (buffers) {\n    buffers = buffers || {}\n    const resetFrame = undefined === buffers.frame ? false : buffers.frame\n    const resetBackground =\n      undefined === buffers.background ? false : buffers.background\n    const resetPointers =\n      undefined === buffers.pointers ? false : buffers.pointers\n    const resetForeground =\n      undefined === buffers.foreground ? false : buffers.foreground\n\n    if (resetFrame) {\n      frameBuffer.width = size\n      frameBuffer.height = size\n      frameContext = frameBuffer.getContext('2d')\n    }\n\n    if (resetBackground) {\n      backgroundBuffer.width = size\n      backgroundBuffer.height = size\n      backgroundContext = backgroundBuffer.getContext('2d')\n    }\n\n    if (resetPointers) {\n      pointer100Buffer.width = size\n      pointer100Buffer.height = size\n      pointer100Context = pointer100Buffer.getContext('2d')\n\n      pointer1000Buffer.width = size\n      pointer1000Buffer.height = size\n      pointer1000Context = pointer1000Buffer.getContext('2d')\n\n      pointer10000Buffer.width = size\n      pointer10000Buffer.height = size\n      pointer10000Context = pointer10000Buffer.getContext('2d')\n    }\n\n    if (resetForeground) {\n      foregroundBuffer.width = size\n      foregroundBuffer.height = size\n      foregroundContext = foregroundBuffer.getContext('2d')\n    }\n  }\n\n  //* *********************************** Public methods **************************************\n  this.setValue = function (newValue) {\n    value = parseFloat(newValue)\n    this.repaint()\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.setValueAnimated = function (newValue, callback) {\n    newValue = parseFloat(newValue)\n    const targetValue = newValue < minValue ? minValue : newValue\n    const gauge = this\n    let time\n\n    if (value !== targetValue) {\n      if (undefined !== tween && tween.isPlaying) {\n        tween.stop()\n      }\n      // Allow 5 secs per 10,000ft\n      time = Math.max((Math.abs(value - targetValue) / 10000) * 5, 1)\n      tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n        {},\n        '',\n        _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n        value,\n        targetValue,\n        time\n      )\n      // tween = new Tween(new Object(), '', Tween.strongEaseInOut, value, targetValue, 1);\n      tween.onMotionChanged = function (event) {\n        value = event.target._pos\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_7__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tween.onMotionFinished = callback\n      }\n\n      tween.start()\n    }\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers({\n      frame: true\n    })\n    frameDesign = newFrameDesign\n    init({\n      frame: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers({\n      background: true,\n      pointer: true // type2 & 13 depend on background\n    })\n    backgroundColor = newBackgroundColor\n    init({\n      background: true, // type2 & 13 depend on background\n      pointer: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers({\n      foreground: true\n    })\n    foregroundType = newForegroundType\n    init({\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLcdColor = function (newLcdColor) {\n    lcdColor = newLcdColor\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setTitleString = function (title) {\n    titleString = title\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setUnitString = function (unit) {\n    unitString = unit\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init({\n        frame: true,\n        background: true,\n        led: true,\n        pointers: true,\n        foreground: true\n      })\n    }\n\n    // mainCtx.save();\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    // Draw frame\n    if (frameVisible) {\n      mainCtx.drawImage(frameBuffer, 0, 0)\n    }\n\n    // Draw buffered image to visible canvas\n    mainCtx.drawImage(backgroundBuffer, 0, 0)\n\n    // Draw lcd display\n    if (lcdVisible) {\n      drawLcdText(value)\n    }\n\n    // re-calculate the spearate pointer values\n    calcValues()\n\n    let shadowOffset = imageWidth * 0.006 * 0.5\n\n    mainCtx.save()\n    // Draw 10000ft pointer\n    // Define rotation center\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate((value10000 - minValue) * angleStep10000ft)\n    mainCtx.translate(-centerX, -centerY)\n    // Set the pointer shadow params\n    mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset\n    mainCtx.shadowBlur = shadowOffset * 2\n    // Draw the pointer\n    mainCtx.drawImage(pointer10000Buffer, 0, 0)\n\n    shadowOffset = imageWidth * 0.006 * 0.75\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset\n\n    // Draw 1000ft pointer\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(\n      (value1000 - minValue) * angleStep1000ft -\n        (value10000 - minValue) * angleStep10000ft\n    )\n    mainCtx.translate(-centerX, -centerY)\n    mainCtx.drawImage(pointer1000Buffer, 0, 0)\n\n    shadowOffset = imageWidth * 0.006\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset\n\n    // Draw 100ft pointer\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(\n      (value100 - minValue) * angleStep100ft -\n        (value1000 - minValue) * angleStep1000ft\n    )\n    mainCtx.translate(-centerX, -centerY)\n    mainCtx.drawImage(pointer100Buffer, 0, 0)\n    mainCtx.restore()\n\n    // Draw the foregound\n    if (foregroundVisible) {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Altimeter);\n\n\n//# sourceURL=webpack://steelseries/./src/Altimeter.js?");

/***/ }),

/***/ "./src/Battery.js":
/*!************************!*\
  !*** ./src/Battery.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst Battery = function (canvas, parameters) {\n  parameters = parameters || {}\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let value = undefined === parameters.value ? 50 : parameters.value\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"getCanvasContext\"])(canvas)\n\n  // Has a size been specified?\n  if (size === 0) {\n    size = mainCtx.canvas.width\n  }\n\n  const imageWidth = size\n  const imageHeight = Math.ceil(size * 0.45)\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = imageWidth\n  mainCtx.canvas.height = imageHeight\n\n  const createBatteryImage = function (ctx, imageWidth, imageHeight, value) {\n    let grad\n\n    // Background\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.025, imageHeight * 0.055555)\n    ctx.lineTo(imageWidth * 0.9, imageHeight * 0.055555)\n    ctx.lineTo(imageWidth * 0.9, imageHeight * 0.944444)\n    ctx.lineTo(imageWidth * 0.025, imageHeight * 0.944444)\n    ctx.lineTo(imageWidth * 0.025, imageHeight * 0.055555)\n    ctx.closePath()\n    //\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.925, 0)\n    ctx.lineTo(0, 0)\n    ctx.lineTo(0, imageHeight)\n    ctx.lineTo(imageWidth * 0.925, imageHeight)\n    ctx.lineTo(imageWidth * 0.925, imageHeight * 0.722222)\n    ctx.bezierCurveTo(\n      imageWidth * 0.925,\n      imageHeight * 0.722222,\n      imageWidth * 0.975,\n      imageHeight * 0.722222,\n      imageWidth * 0.975,\n      imageHeight * 0.722222\n    )\n    ctx.bezierCurveTo(\n      imageWidth,\n      imageHeight * 0.722222,\n      imageWidth,\n      imageHeight * 0.666666,\n      imageWidth,\n      imageHeight * 0.666666\n    )\n    ctx.bezierCurveTo(\n      imageWidth,\n      imageHeight * 0.666666,\n      imageWidth,\n      imageHeight * 0.333333,\n      imageWidth,\n      imageHeight * 0.333333\n    )\n    ctx.bezierCurveTo(\n      imageWidth,\n      imageHeight * 0.333333,\n      imageWidth,\n      imageHeight * 0.277777,\n      imageWidth * 0.975,\n      imageHeight * 0.277777\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.975,\n      imageHeight * 0.277777,\n      imageWidth * 0.925,\n      imageHeight * 0.277777,\n      imageWidth * 0.925,\n      imageHeight * 0.277777\n    )\n    ctx.lineTo(imageWidth * 0.925, 0)\n    ctx.closePath()\n    //\n    grad = ctx.createLinearGradient(0, 0, 0, imageHeight)\n    grad.addColorStop(0, '#ffffff')\n    grad.addColorStop(1, '#7e7e7e')\n    ctx.fillStyle = grad\n    ctx.fill()\n\n    // Main\n    ctx.beginPath()\n    let end = Math.max(\n      imageWidth * 0.875 * (value / 100),\n      Math.ceil(imageWidth * 0.01)\n    )\n    ctx.rect(\n      imageWidth * 0.025,\n      imageWidth * 0.025,\n      end,\n      imageHeight * 0.888888\n    )\n    ctx.closePath()\n    const BORDER_FRACTIONS = [0, 0.4, 1]\n    const BORDER_COLORS = [\n      new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](177, 25, 2, 1), // 0xB11902\n      new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](219, 167, 21, 1), // 0xDBA715\n      new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](121, 162, 75, 1) // 0x79A24B\n    ]\n    const border = new _tools__WEBPACK_IMPORTED_MODULE_0__[\"gradientWrapper\"](0, 100, BORDER_FRACTIONS, BORDER_COLORS)\n    ctx.fillStyle = border.getColorAt(value / 100).getRgbColor()\n    ctx.fill()\n    ctx.beginPath()\n    end = Math.max(end - imageWidth * 0.05, 0)\n    ctx.rect(imageWidth * 0.05, imageWidth * 0.05, end, imageHeight * 0.777777)\n    ctx.closePath()\n    const LIQUID_COLORS_DARK = [\n      new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](198, 39, 5, 1), // 0xC62705\n      new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](228, 189, 32, 1), // 0xE4BD20\n      new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](163, 216, 102, 1) // 0xA3D866\n    ]\n\n    const LIQUID_COLORS_LIGHT = [\n      new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](246, 121, 48, 1), // 0xF67930\n      new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](246, 244, 157, 1), // 0xF6F49D\n      new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](223, 233, 86, 1) // 0xDFE956\n    ]\n    const LIQUID_GRADIENT_FRACTIONS = [0, 0.4, 1]\n    const liquidDark = new _tools__WEBPACK_IMPORTED_MODULE_0__[\"gradientWrapper\"](\n      0,\n      100,\n      LIQUID_GRADIENT_FRACTIONS,\n      LIQUID_COLORS_DARK\n    )\n    const liquidLight = new _tools__WEBPACK_IMPORTED_MODULE_0__[\"gradientWrapper\"](\n      0,\n      100,\n      LIQUID_GRADIENT_FRACTIONS,\n      LIQUID_COLORS_LIGHT\n    )\n    grad = ctx.createLinearGradient(\n      imageWidth * 0.05,\n      0,\n      imageWidth * 0.875,\n      0\n    )\n    grad.addColorStop(0, liquidDark.getColorAt(value / 100).getRgbColor())\n    grad.addColorStop(0.5, liquidLight.getColorAt(value / 100).getRgbColor())\n    grad.addColorStop(1, liquidDark.getColorAt(value / 100).getRgbColor())\n    ctx.fillStyle = grad\n    ctx.fill()\n\n    // Foreground\n    ctx.beginPath()\n    ctx.rect(\n      imageWidth * 0.025,\n      imageWidth * 0.025,\n      imageWidth * 0.875,\n      imageHeight * 0.444444\n    )\n    ctx.closePath()\n    grad = ctx.createLinearGradient(\n      imageWidth * 0.025,\n      imageWidth * 0.025,\n      imageWidth * 0.875,\n      imageHeight * 0.444444\n    )\n    grad.addColorStop(0, 'rgba(255, 255, 255, 0)')\n    grad.addColorStop(1, 'rgba(255, 255, 255, 0.8)')\n    ctx.fillStyle = grad\n    ctx.fill()\n  }\n\n  // **************   Public methods  ********************\n  this.setValue = function (newValue) {\n    newValue = newValue < 0 ? 0 : newValue > 100 ? 100 : newValue\n    if (value !== newValue) {\n      value = newValue\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.repaint = function () {\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n    createBatteryImage(mainCtx, imageWidth, imageHeight, value)\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Battery);\n\n\n//# sourceURL=webpack://steelseries/./src/Battery.js?");

/***/ }),

/***/ "./src/Clock.js":
/*!**********************!*\
  !*** ./src/Clock.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony import */ var _drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawRadialCustomImage */ \"./src/drawRadialCustomImage.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\nconst Clock = function (canvas, parameters) {\n  parameters = parameters || {}\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let pointerType =\n    undefined === parameters.pointerType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"PointerType\"].TYPE1\n      : parameters.pointerType\n  let pointerColor =\n    undefined === parameters.pointerColor\n      ? pointerType === _definitions__WEBPACK_IMPORTED_MODULE_5__[\"PointerType\"].TYPE1\n        ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].GRAY\n        : _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].BLACK\n      : parameters.pointerColor\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? pointerType === _definitions__WEBPACK_IMPORTED_MODULE_5__[\"PointerType\"].TYPE1\n        ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"BackgroundColor\"].ANTHRACITE\n        : _definitions__WEBPACK_IMPORTED_MODULE_5__[\"BackgroundColor\"].LIGHT_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  const customLayer =\n    undefined === parameters.customLayer ? null : parameters.customLayer\n  let isAutomatic =\n    undefined === parameters.isAutomatic ? true : parameters.isAutomatic\n  let hour = undefined === parameters.hour ? 11 : parameters.hour\n  let minute = undefined === parameters.minute ? 5 : parameters.minute\n  let second = undefined === parameters.second ? 0 : parameters.second\n  let secondMovesContinuous =\n    undefined === parameters.secondMovesContinuous\n      ? false\n      : parameters.secondMovesContinuous\n  let timeZoneOffsetHour =\n    undefined === parameters.timeZoneOffsetHour\n      ? 0\n      : parameters.timeZoneOffsetHour\n  let timeZoneOffsetMinute =\n    undefined === parameters.timeZoneOffsetMinute\n      ? 0\n      : parameters.timeZoneOffsetMinute\n  let secondPointerVisible =\n    undefined === parameters.secondPointerVisible\n      ? true\n      : parameters.secondPointerVisible\n\n  // GaugeType specific private variables\n  let objDate = new Date()\n  let minutePointerAngle\n  let hourPointerAngle\n  let secondPointerAngle\n  let tickTimer\n  let tickInterval = secondMovesContinuous ? 100 : 1000\n  tickInterval = secondPointerVisible ? tickInterval : 100\n\n  const self = this\n\n  // Constants\n  const ANGLE_STEP = 6\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (size === 0) {\n    size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height)\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  const imageWidth = size\n  const imageHeight = size\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight / 2\n\n  let initialized = false\n\n  // Buffer for the frame\n  const frameBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let frameContext = frameBuffer.getContext('2d')\n\n  // Buffer for static background painting code\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  // Buffer for hour pointer image painting code\n  const hourBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let hourContext = hourBuffer.getContext('2d')\n\n  // Buffer for minute pointer image painting code\n  const minuteBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let minuteContext = minuteBuffer.getContext('2d')\n\n  // Buffer for second pointer image painting code\n  const secondBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let secondContext = secondBuffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  const drawTickmarksImage = function (ctx, ptrType) {\n    let tickAngle\n    let SMALL_TICK_HEIGHT\n    let BIG_TICK_HEIGHT\n    let INNER_POINT\n    const OUTER_POINT = imageWidth * 0.405\n    ctx.save()\n    ctx.translate(centerX, centerY)\n\n    switch (ptrType.type) {\n      case 'type1':\n        // Draw minutes tickmarks\n        SMALL_TICK_HEIGHT = imageWidth * 0.074766\n        INNER_POINT = OUTER_POINT - SMALL_TICK_HEIGHT\n        ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n        ctx.lineWidth = imageWidth * 0.014018\n\n        for (tickAngle = 0; tickAngle < 360; tickAngle += 30) {\n          ctx.beginPath()\n          ctx.moveTo(OUTER_POINT, 0)\n          ctx.lineTo(INNER_POINT, 0)\n          ctx.closePath()\n          ctx.stroke()\n          ctx.rotate(30 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"])\n        }\n\n        // Draw hours tickmarks\n        BIG_TICK_HEIGHT = imageWidth * 0.126168\n        INNER_POINT = OUTER_POINT - BIG_TICK_HEIGHT\n        ctx.lineWidth = imageWidth * 0.03271\n\n        for (tickAngle = 0; tickAngle < 360; tickAngle += 90) {\n          ctx.beginPath()\n          ctx.moveTo(OUTER_POINT, 0)\n          ctx.lineTo(INNER_POINT, 0)\n          ctx.closePath()\n          ctx.stroke()\n          ctx.rotate(90 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"])\n        }\n        break\n\n      case 'type2':\n      /* falls through */\n      default:\n        // Draw minutes tickmarks\n        SMALL_TICK_HEIGHT = imageWidth * 0.037383\n        INNER_POINT = OUTER_POINT - SMALL_TICK_HEIGHT\n        ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n        ctx.lineWidth = imageWidth * 0.009345\n\n        for (tickAngle = 0; tickAngle < 360; tickAngle += 6) {\n          ctx.beginPath()\n          ctx.moveTo(OUTER_POINT, 0)\n          ctx.lineTo(INNER_POINT, 0)\n          ctx.closePath()\n          ctx.stroke()\n          ctx.rotate(6 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"])\n        }\n\n        // Draw hours tickmarks\n        BIG_TICK_HEIGHT = imageWidth * 0.084112\n        INNER_POINT = OUTER_POINT - BIG_TICK_HEIGHT\n        ctx.lineWidth = imageWidth * 0.028037\n\n        for (tickAngle = 0; tickAngle < 360; tickAngle += 30) {\n          ctx.beginPath()\n          ctx.moveTo(OUTER_POINT, 0)\n          ctx.lineTo(INNER_POINT, 0)\n          ctx.closePath()\n          ctx.stroke()\n          ctx.rotate(30 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"])\n        }\n        break\n    }\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  const drawHourPointer = function (ctx, ptrType) {\n    ctx.save()\n    let grad\n\n    switch (ptrType.type) {\n      case 'type2':\n        ctx.beginPath()\n        ctx.lineWidth = imageWidth * 0.046728\n        ctx.moveTo(centerX, imageWidth * 0.289719)\n        ctx.lineTo(centerX, imageWidth * 0.289719 + imageWidth * 0.224299)\n        ctx.strokeStyle = pointerColor.medium.getRgbaColor()\n        ctx.closePath()\n        ctx.stroke()\n        break\n\n      case 'type1':\n      /* falls through */\n      default:\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.471962, imageHeight * 0.560747)\n        ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.214953)\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.182242)\n        ctx.lineTo(imageWidth * 0.528037, imageHeight * 0.214953)\n        ctx.lineTo(imageWidth * 0.528037, imageHeight * 0.560747)\n        ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.560747)\n        ctx.closePath()\n        grad = ctx.createLinearGradient(\n          imageWidth * 0.471962,\n          imageHeight * 0.560747,\n          imageWidth * 0.528037,\n          imageHeight * 0.214953\n        )\n        grad.addColorStop(1, pointerColor.veryLight.getRgbaColor())\n        grad.addColorStop(0, pointerColor.light.getRgbaColor())\n        ctx.fillStyle = grad\n        ctx.strokeStyle = pointerColor.light.getRgbaColor()\n        ctx.fill()\n        ctx.stroke()\n        break\n    }\n    ctx.restore()\n  }\n\n  const drawMinutePointer = function (ctx, ptrType) {\n    ctx.save()\n    let grad\n\n    switch (ptrType.type) {\n      case 'type2':\n        ctx.beginPath()\n        ctx.lineWidth = imageWidth * 0.03271\n        ctx.moveTo(centerX, imageWidth * 0.116822)\n        ctx.lineTo(centerX, imageWidth * 0.116822 + imageWidth * 0.38785)\n        ctx.strokeStyle = pointerColor.medium.getRgbaColor()\n        ctx.closePath()\n        ctx.stroke()\n        break\n\n      case 'type1':\n      /* falls through */\n      default:\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.518691, imageHeight * 0.574766)\n        ctx.lineTo(imageWidth * 0.523364, imageHeight * 0.135514)\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.107476)\n        ctx.lineTo(imageWidth * 0.476635, imageHeight * 0.140186)\n        ctx.lineTo(imageWidth * 0.476635, imageHeight * 0.574766)\n        ctx.lineTo(imageWidth * 0.518691, imageHeight * 0.574766)\n        ctx.closePath()\n        grad = ctx.createLinearGradient(\n          imageWidth * 0.518691,\n          imageHeight * 0.574766,\n          imageWidth * 0.476635,\n          imageHeight * 0.140186\n        )\n        grad.addColorStop(1, pointerColor.veryLight.getRgbaColor())\n        grad.addColorStop(0, pointerColor.light.getRgbaColor())\n        ctx.fillStyle = grad\n        ctx.strokeStyle = pointerColor.light.getRgbaColor()\n        ctx.fill()\n        ctx.stroke()\n        break\n    }\n    ctx.restore()\n  }\n\n  const drawSecondPointer = function (ctx, ptrType) {\n    ctx.save()\n    let grad\n\n    switch (ptrType.type) {\n      case 'type2':\n        // top rectangle\n        ctx.lineWidth = imageWidth * 0.009345\n        ctx.beginPath()\n        ctx.moveTo(centerX, imageWidth * 0.09813)\n        ctx.lineTo(centerX, imageWidth * 0.09813 + imageWidth * 0.126168)\n        ctx.closePath()\n        ctx.stroke()\n        // bottom rectangle\n        ctx.lineWidth = imageWidth * 0.018691\n        ctx.beginPath()\n        ctx.moveTo(centerX, imageWidth * 0.308411)\n        ctx.lineTo(centerX, imageWidth * 0.308411 + imageWidth * 0.191588)\n        ctx.closePath()\n        ctx.stroke()\n        // circle\n        ctx.lineWidth = imageWidth * 0.016\n        ctx.beginPath()\n        ctx.arc(\n          centerX,\n          imageWidth * 0.26,\n          (imageWidth * 0.085) / 2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"]\n        )\n        ctx.closePath()\n        ctx.stroke()\n        break\n\n      case 'type1':\n      /* falls through */\n      default:\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.509345, imageHeight * 0.116822)\n        ctx.lineTo(imageWidth * 0.509345, imageHeight * 0.574766)\n        ctx.lineTo(imageWidth * 0.490654, imageHeight * 0.574766)\n        ctx.lineTo(imageWidth * 0.490654, imageHeight * 0.116822)\n        ctx.lineTo(imageWidth * 0.509345, imageHeight * 0.116822)\n        ctx.closePath()\n        grad = ctx.createLinearGradient(\n          imageWidth * 0.509345,\n          imageHeight * 0.116822,\n          imageWidth * 0.490654,\n          imageHeight * 0.574766\n        )\n        grad.addColorStop(0, _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].RED.light.getRgbaColor())\n        grad.addColorStop(0.47, _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].RED.medium.getRgbaColor())\n        grad.addColorStop(1, _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].RED.dark.getRgbaColor())\n        ctx.fillStyle = grad\n        ctx.strokeStyle = _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].RED.dark.getRgbaColor()\n        ctx.fill()\n        ctx.stroke()\n        break\n    }\n    ctx.restore()\n  }\n\n  const drawKnob = function (ctx) {\n    // draw the knob\n    ctx.beginPath()\n    ctx.arc(centerX, centerY, imageWidth * 0.045, 0, _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"])\n    ctx.closePath()\n    const grad = ctx.createLinearGradient(\n      centerX - (imageWidth * 0.045) / 2,\n      centerY - (imageWidth * 0.045) / 2,\n      centerX + (imageWidth * 0.045) / 2,\n      centerY + (imageWidth * 0.045) / 2\n    )\n    grad.addColorStop(0, '#eef0f2')\n    grad.addColorStop(1, '#65696d')\n    ctx.fillStyle = grad\n    ctx.fill()\n  }\n\n  const drawTopKnob = function (ctx, ptrType) {\n    let grad\n\n    ctx.save()\n\n    switch (ptrType.type) {\n      case 'type2':\n        // draw knob\n        ctx.fillStyle = '#000000'\n        ctx.beginPath()\n        ctx.arc(centerX, centerY, (imageWidth * 0.088785) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"])\n        ctx.closePath()\n        ctx.fill()\n        break\n\n      case 'type1':\n      /* falls through */\n      default:\n        // draw knob\n        grad = ctx.createLinearGradient(\n          centerX - (imageWidth * 0.027) / 2,\n          centerY - (imageWidth * 0.027) / 2,\n          centerX + (imageWidth * 0.027) / 2,\n          centerY + (imageWidth * 0.027) / 2\n        )\n        grad.addColorStop(0, '#f3f4f7')\n        grad.addColorStop(0.11, '#f3f5f7')\n        grad.addColorStop(0.12, '#f1f3f5')\n        grad.addColorStop(0.2, '#c0c5cb')\n        grad.addColorStop(0.2, '#bec3c9')\n        grad.addColorStop(1, '#bec3c9')\n        ctx.fillStyle = grad\n        ctx.beginPath()\n        ctx.arc(centerX, centerY, imageWidth * 0.027, 0, _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"])\n        ctx.closePath()\n        ctx.fill()\n        break\n    }\n\n    ctx.restore()\n  }\n\n  const calculateAngles = function (hour, minute, second) {\n    secondPointerAngle = second * ANGLE_STEP * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]\n    minutePointerAngle = minute * ANGLE_STEP * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]\n    hourPointerAngle = (hour + minute / 60) * ANGLE_STEP * 5 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]\n  }\n\n  const tickTock = function () {\n    if (isAutomatic) {\n      objDate = new Date()\n    } else {\n      objDate.setHours(hour)\n      objDate.setMinutes(minute)\n      objDate.setSeconds(second)\n    }\n    // Seconds\n    second =\n      objDate.getSeconds() +\n      (secondMovesContinuous ? objDate.getMilliseconds() / 1000 : 0)\n\n    // Hours\n    if (timeZoneOffsetHour !== 0) {\n      hour = objDate.getUTCHours() + timeZoneOffsetHour\n    } else {\n      hour = objDate.getHours()\n    }\n    hour = hour % 12\n\n    // Minutes\n    if (timeZoneOffsetMinute !== 0) {\n      minute = objDate.getUTCMinutes() + timeZoneOffsetMinute\n    } else {\n      minute = objDate.getMinutes()\n    }\n    if (minute > 60) {\n      minute -= 60\n      hour++\n    }\n    if (minute < 0) {\n      minute += 60\n      hour--\n    }\n    hour = hour % 12\n    // Calculate angles from current hour and minute values\n    calculateAngles(hour, minute, second)\n\n    if (isAutomatic) {\n      tickTimer = setTimeout(tickTock, tickInterval)\n    }\n\n    self.repaint()\n  }\n\n  // **************   Initialization  ********************\n  // Draw all static painting code to background\n  const init = function (parameters) {\n    parameters = parameters || {}\n    const drawFrame2 =\n      undefined === parameters.frame ? false : parameters.frame\n    const drawBackground2 =\n      undefined === parameters.background ? false : parameters.background\n    const drawPointers =\n      undefined === parameters.pointers ? false : parameters.pointers\n    const drawForeground2 =\n      undefined === parameters.foreground ? false : parameters.foreground\n\n    initialized = true\n\n    if (drawFrame2 && frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\n        frameContext,\n        frameDesign,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    if (drawBackground2 && backgroundVisible) {\n      // Create background in background buffer (backgroundBuffer)\n      Object(_drawBackground__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      // Create custom layer in background buffer (backgroundBuffer)\n      Object(_drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        backgroundContext,\n        customLayer,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      drawTickmarksImage(backgroundContext, pointerType)\n    }\n\n    if (drawPointers) {\n      drawHourPointer(hourContext, pointerType)\n      drawMinutePointer(minuteContext, pointerType)\n      drawSecondPointer(secondContext, pointerType)\n    }\n\n    if (drawForeground2 && foregroundVisible) {\n      drawTopKnob(foregroundContext, pointerType)\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        false\n      )\n    }\n  }\n\n  const resetBuffers = function (buffers) {\n    buffers = buffers || {}\n    const resetFrame = undefined === buffers.frame ? false : buffers.frame\n    const resetBackground =\n      undefined === buffers.background ? false : buffers.background\n    const resetPointers =\n      undefined === buffers.pointers ? false : buffers.pointers\n    const resetForeground =\n      undefined === buffers.foreground ? false : buffers.foreground\n\n    if (resetFrame) {\n      frameBuffer.width = size\n      frameBuffer.height = size\n      frameContext = frameBuffer.getContext('2d')\n    }\n\n    if (resetBackground) {\n      backgroundBuffer.width = size\n      backgroundBuffer.height = size\n      backgroundContext = backgroundBuffer.getContext('2d')\n    }\n\n    if (resetPointers) {\n      hourBuffer.width = size\n      hourBuffer.height = size\n      hourContext = hourBuffer.getContext('2d')\n\n      minuteBuffer.width = size\n      minuteBuffer.height = size\n      minuteContext = minuteBuffer.getContext('2d')\n\n      secondBuffer.width = size\n      secondBuffer.height = size\n      secondContext = secondBuffer.getContext('2d')\n    }\n\n    if (resetForeground) {\n      foregroundBuffer.width = size\n      foregroundBuffer.height = size\n      foregroundContext = foregroundBuffer.getContext('2d')\n    }\n  }\n\n  //* *********************************** Public methods **************************************\n  this.getAutomatic = function () {\n    return isAutomatic\n  }\n\n  this.setAutomatic = function (newValue) {\n    newValue = !!newValue\n    if (isAutomatic && !newValue) {\n      // stop the clock!\n      clearTimeout(tickTimer)\n      isAutomatic = newValue\n    } else if (!isAutomatic && newValue) {\n      // start the clock\n      isAutomatic = newValue\n      tickTock()\n    }\n    return this\n  }\n\n  this.getHour = function () {\n    return hour\n  }\n\n  this.setHour = function (newValue) {\n    newValue = parseInt(newValue, 10) % 12\n    if (hour !== newValue) {\n      hour = newValue\n      calculateAngles(hour, minute, second)\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getMinute = function () {\n    return minute\n  }\n\n  this.setMinute = function (newValue) {\n    newValue = parseInt(newValue, 10) % 60\n    if (minute !== newValue) {\n      minute = newValue\n      calculateAngles(hour, minute, second)\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getSecond = function () {\n    return second\n  }\n\n  this.setSecond = function (newValue) {\n    newValue = parseInt(newValue, 10) % 60\n    if (second !== newValue) {\n      second = newValue\n      calculateAngles(hour, minute, second)\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getTimeZoneOffsetHour = function () {\n    return timeZoneOffsetHour\n  }\n\n  this.setTimeZoneOffsetHour = function (newValue) {\n    timeZoneOffsetHour = parseInt(newValue, 10)\n    this.repaint()\n    return this\n  }\n\n  this.getTimeZoneOffsetMinute = function () {\n    return timeZoneOffsetMinute\n  }\n\n  this.setTimeZoneOffsetMinute = function (newValue) {\n    timeZoneOffsetMinute = parseInt(newValue, 10)\n    this.repaint()\n    return this\n  }\n\n  this.getSecondPointerVisible = function () {\n    return secondPointerVisible\n  }\n\n  this.setSecondPointerVisible = function (newValue) {\n    secondPointerVisible = !!newValue\n    this.repaint()\n    return this\n  }\n\n  this.getSecondMovesContinuous = function () {\n    return secondMovesContinuous\n  }\n\n  this.setSecondMovesContinuous = function (newValue) {\n    secondMovesContinuous = !!newValue\n    tickInterval = secondMovesContinuous ? 100 : 1000\n    tickInterval = secondPointerVisible ? tickInterval : 100\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers({\n      frame: true\n    })\n    frameDesign = newFrameDesign\n    init({\n      frame: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers({\n      frame: true,\n      background: true\n    })\n    backgroundColor = newBackgroundColor\n    init({\n      frame: true,\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers({\n      foreground: true\n    })\n    foregroundType = newForegroundType\n    init({\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerType = function (newPointerType) {\n    resetBuffers({\n      background: true,\n      foreground: true,\n      pointers: true\n    })\n    pointerType = newPointerType\n    if (pointerType.type === 'type1') {\n      pointerColor = _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].GRAY\n      backgroundColor = _definitions__WEBPACK_IMPORTED_MODULE_5__[\"BackgroundColor\"].ANTHRACITE\n    } else {\n      pointerColor = _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].BLACK\n      backgroundColor = _definitions__WEBPACK_IMPORTED_MODULE_5__[\"BackgroundColor\"].LIGHT_GRAY\n    }\n    init({\n      background: true,\n      foreground: true,\n      pointers: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerColor = function (newPointerColor) {\n    resetBuffers({\n      pointers: true\n    })\n    pointerColor = newPointerColor\n    init({\n      pointers: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init({\n        frame: true,\n        background: true,\n        pointers: true,\n        foreground: true\n      })\n    }\n\n    // mainCtx.save();\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    // Draw frame\n    if (frameVisible) {\n      mainCtx.drawImage(frameBuffer, 0, 0)\n    }\n\n    // Draw buffered image to visible canvas\n    if (backgroundVisible) {\n      mainCtx.drawImage(backgroundBuffer, 0, 0)\n    }\n\n    // have to draw to a rotated temporary image area so we can translate in\n    // absolute x, y values when drawing to main context\n    const shadowOffset = imageWidth * 0.006\n\n    // draw hour pointer\n    // Define rotation center\n    mainCtx.save()\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(hourPointerAngle)\n    mainCtx.translate(-centerX, -centerY)\n    // Set the pointer shadow params\n    mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset\n    mainCtx.shadowBlur = shadowOffset * 2\n    // Draw the pointer\n    mainCtx.drawImage(hourBuffer, 0, 0)\n\n    // draw minute pointer\n    // Define rotation center\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(minutePointerAngle - hourPointerAngle)\n    mainCtx.translate(-centerX, -centerY)\n    mainCtx.drawImage(minuteBuffer, 0, 0)\n    mainCtx.restore()\n\n    if (pointerType.type === 'type1') {\n      drawKnob(mainCtx)\n    }\n\n    if (secondPointerVisible) {\n      // draw second pointer\n      // Define rotation center\n      mainCtx.save()\n      mainCtx.translate(centerX, centerY)\n      mainCtx.rotate(secondPointerAngle)\n      mainCtx.translate(-centerX, -centerY)\n      // Set the pointer shadow params\n      mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n      mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset\n      mainCtx.shadowBlur = shadowOffset * 2\n      // Draw the pointer\n      mainCtx.drawImage(secondBuffer, 0, 0)\n      mainCtx.restore()\n    }\n\n    // Draw foreground\n    if (foregroundVisible) {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n  }\n\n  // Visualize the component\n  tickTock()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Clock);\n\n\n//# sourceURL=webpack://steelseries/./src/Clock.js?");

/***/ }),

/***/ "./src/Compass.js":
/*!************************!*\
  !*** ./src/Compass.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony import */ var _drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawRadialCustomImage */ \"./src/drawRadialCustomImage.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _drawRoseImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./drawRoseImage */ \"./src/drawRoseImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\n\n\nconst Compass = function (canvas, parameters) {\n  parameters = parameters || {}\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_7__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_7__[\"BackgroundColor\"].DARK_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let pointerType =\n    undefined === parameters.pointerType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_7__[\"PointerType\"].TYPE2\n      : parameters.pointerType\n  let pointerColor =\n    undefined === parameters.pointerColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_7__[\"ColorDef\"].RED\n      : parameters.pointerColor\n  const knobType =\n    undefined === parameters.knobType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_7__[\"KnobType\"].STANDARD_KNOB\n      : parameters.knobType\n  const knobStyle =\n    undefined === parameters.knobStyle\n      ? _definitions__WEBPACK_IMPORTED_MODULE_7__[\"KnobStyle\"].SILVER\n      : parameters.knobStyle\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_7__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  let pointSymbols =\n    undefined === parameters.pointSymbols\n      ? ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']\n      : parameters.pointSymbols\n  const pointSymbolsVisible =\n    undefined === parameters.pointSymbolsVisible\n      ? true\n      : parameters.pointSymbolsVisible\n  const customLayer =\n    undefined === parameters.customLayer ? null : parameters.customLayer\n  const degreeScale =\n    undefined === parameters.degreeScale ? false : parameters.degreeScale\n  const roseVisible =\n    undefined === parameters.roseVisible ? true : parameters.roseVisible\n  const rotateFace =\n    undefined === parameters.rotateFace ? false : parameters.rotateFace\n\n  let tween\n  let repainting = false\n  let value = 0\n  const angleStep = _tools__WEBPACK_IMPORTED_MODULE_6__[\"RAD_FACTOR\"]\n  let angle = this.value\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_6__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (size === 0) {\n    size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height)\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  const imageWidth = size\n  const imageHeight = size\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight / 2\n\n  const shadowOffset = imageWidth * 0.006\n\n  let initialized = false\n\n  // **************   Buffer creation  ********************\n  // Buffer for all static background painting code\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_6__[\"createBuffer\"])(size, size)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  // Buffer for symbol/rose painting code\n  const roseBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_6__[\"createBuffer\"])(size, size)\n  let roseContext = roseBuffer.getContext('2d')\n\n  // Buffer for pointer image painting code\n  const pointerBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_6__[\"createBuffer\"])(size, size)\n  let pointerContext = pointerBuffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_6__[\"createBuffer\"])(size, size)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  // **************   Image creation  ********************\n  const drawTickmarksImage = function (ctx) {\n    let val\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n\n    let stdFont\n    let smlFont\n    let i\n\n    ctx.save()\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.translate(centerX, centerY)\n\n    if (!degreeScale) {\n      stdFont = 0.12 * imageWidth + 'px serif'\n      smlFont = 0.06 * imageWidth + 'px serif'\n\n      for (i = 0; i < 360; i += 2.5) {\n        if (i % 5 === 0) {\n          ctx.lineWidth = 1\n          ctx.beginPath()\n          ctx.moveTo(imageWidth * 0.38, 0)\n          ctx.lineTo(imageWidth * 0.36, 0)\n          ctx.closePath()\n          ctx.stroke()\n        }\n\n        // Draw the labels\n        ctx.save()\n        switch (i) {\n          case 0:\n            ctx.translate(imageWidth * 0.35, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n            ctx.font = stdFont\n            ctx.fillText(pointSymbols[2], 0, 0, imageWidth)\n            ctx.translate(-imageWidth * 0.35, 0)\n            break\n          case 45:\n            ctx.translate(imageWidth * 0.29, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n            ctx.font = smlFont\n            ctx.fillText(pointSymbols[3], 0, 0, imageWidth)\n            ctx.translate(-imageWidth * 0.29, 0)\n            break\n          case 90:\n            ctx.translate(imageWidth * 0.35, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n            ctx.font = stdFont\n            ctx.fillText(pointSymbols[4], 0, 0, imageWidth)\n            ctx.translate(-imageWidth * 0.35, 0)\n            break\n          case 135:\n            ctx.translate(imageWidth * 0.29, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n            ctx.font = smlFont\n            ctx.fillText(pointSymbols[5], 0, 0, imageWidth)\n            ctx.translate(-imageWidth * 0.29, 0)\n            break\n          case 180:\n            ctx.translate(imageWidth * 0.35, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n            ctx.font = stdFont\n            ctx.fillText(pointSymbols[6], 0, 0, imageWidth)\n            ctx.translate(-imageWidth * 0.35, 0)\n            break\n          case 225:\n            ctx.translate(imageWidth * 0.29, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n            ctx.font = smlFont\n            ctx.fillText(pointSymbols[7], 0, 0, imageWidth)\n            ctx.translate(-imageWidth * 0.29, 0)\n            break\n          case 270:\n            ctx.translate(imageWidth * 0.35, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n            ctx.font = stdFont\n            ctx.fillText(pointSymbols[0], 0, 0, imageWidth)\n            ctx.translate(-imageWidth * 0.35, 0)\n            break\n          case 315:\n            ctx.translate(imageWidth * 0.29, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n            ctx.font = smlFont\n            ctx.fillText(pointSymbols[1], 0, 0, imageWidth)\n            ctx.translate(-imageWidth * 0.29, 0)\n            break\n        }\n        ctx.restore()\n\n        if (\n          roseVisible &&\n          (i === 0 ||\n            i === 22.5 ||\n            i === 45 ||\n            i === 67.5 ||\n            i === 90 ||\n            i === 112.5 ||\n            i === 135 ||\n            i === 157.5 ||\n            i === 180 ||\n            i === 202.5 ||\n            i === 225 ||\n            i === 247.5 ||\n            i === 270 ||\n            i === 292.5 ||\n            i === 315 ||\n            i === 337.5 ||\n            i === 360)\n        ) {\n          // ROSE_LINE\n          ctx.save()\n          ctx.beginPath()\n          // indent the 16 half quadrant lines a bit for visual effect\n          if (i % 45) {\n            ctx.moveTo(imageWidth * 0.29, 0)\n          } else {\n            ctx.moveTo(imageWidth * 0.38, 0)\n          }\n          ctx.lineTo(imageWidth * 0.1, 0)\n          ctx.closePath()\n          ctx.restore()\n          ctx.lineWidth = 1\n          ctx.strokeStyle = backgroundColor.symbolColor.getRgbaColor()\n          ctx.stroke()\n        }\n        ctx.rotate(angleStep * 2.5)\n      }\n    } else {\n      stdFont = 0.08 * imageWidth + 'px serif'\n      smlFont = imageWidth * 0.033 + 'px serif'\n\n      ctx.rotate(angleStep * 10)\n\n      for (i = 10; i <= 360; i += 10) {\n        // Draw the labels\n        ctx.save()\n        if (pointSymbolsVisible) {\n          switch (i) {\n            case 360:\n              ctx.translate(imageWidth * 0.35, 0)\n              ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n              ctx.font = stdFont\n              ctx.fillText(pointSymbols[2], 0, 0, imageWidth)\n              ctx.translate(-imageWidth * 0.35, 0)\n              break\n            case 90:\n              ctx.translate(imageWidth * 0.35, 0)\n              ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n              ctx.font = stdFont\n              ctx.fillText(pointSymbols[4], 0, 0, imageWidth)\n              ctx.translate(-imageWidth * 0.35, 0)\n              break\n            case 180:\n              ctx.translate(imageWidth * 0.35, 0)\n              ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n              ctx.font = stdFont\n              ctx.fillText(pointSymbols[6], 0, 0, imageWidth)\n              ctx.translate(-imageWidth * 0.35, 0)\n              break\n            case 270:\n              ctx.translate(imageWidth * 0.35, 0)\n              ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n              ctx.font = stdFont\n              ctx.fillText(pointSymbols[0], 0, 0, imageWidth)\n              ctx.translate(-imageWidth * 0.35, 0)\n              break\n            default:\n              val = (i + 90) % 360\n              ctx.translate(imageWidth * 0.37, 0)\n              ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n              ctx.font = smlFont\n              ctx.fillText('0'.substring(val >= 100) + val, 0, 0, imageWidth)\n              ctx.translate(-imageWidth * 0.37, 0)\n          }\n        } else {\n          val = (i + 90) % 360\n          ctx.translate(imageWidth * 0.37, 0)\n          ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"])\n          ctx.font = smlFont\n          ctx.fillText('0'.substring(val >= 100) + val, 0, 0, imageWidth)\n          ctx.translate(-imageWidth * 0.37, 0)\n        }\n        ctx.restore()\n        ctx.rotate(angleStep * 10)\n      }\n    }\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  const drawPointerImage = function (ctx) {\n    ctx.save()\n\n    switch (pointerType.type) {\n      case 'type2': {\n        // NORTHPOINTER\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.53271, imageHeight * 0.453271)\n        ctx.bezierCurveTo(\n          imageWidth * 0.53271,\n          imageHeight * 0.453271,\n          imageWidth * 0.5,\n          imageHeight * 0.149532,\n          imageWidth * 0.5,\n          imageHeight * 0.149532\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.5,\n          imageHeight * 0.149532,\n          imageWidth * 0.467289,\n          imageHeight * 0.453271,\n          imageWidth * 0.467289,\n          imageHeight * 0.453271\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.453271,\n          imageHeight * 0.462616,\n          imageWidth * 0.443925,\n          imageHeight * 0.481308,\n          imageWidth * 0.443925,\n          imageHeight * 0.5\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.443925,\n          imageHeight * 0.5,\n          imageWidth * 0.556074,\n          imageHeight * 0.5,\n          imageWidth * 0.556074,\n          imageHeight * 0.5\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.556074,\n          imageHeight * 0.481308,\n          imageWidth * 0.546728,\n          imageHeight * 0.462616,\n          imageWidth * 0.53271,\n          imageHeight * 0.453271\n        )\n        ctx.closePath()\n        const NORTHPOINTER2_GRADIENT = ctx.createLinearGradient(\n          0.471962 * imageWidth,\n          0,\n          0.528036 * imageWidth,\n          0\n        )\n        NORTHPOINTER2_GRADIENT.addColorStop(\n          0,\n          pointerColor.light.getRgbaColor()\n        )\n        NORTHPOINTER2_GRADIENT.addColorStop(\n          0.46,\n          pointerColor.light.getRgbaColor()\n        )\n        NORTHPOINTER2_GRADIENT.addColorStop(\n          0.47,\n          pointerColor.medium.getRgbaColor()\n        )\n        NORTHPOINTER2_GRADIENT.addColorStop(\n          1,\n          pointerColor.medium.getRgbaColor()\n        )\n        ctx.fillStyle = NORTHPOINTER2_GRADIENT\n        ctx.strokeStyle = pointerColor.dark.getRgbaColor()\n        ctx.lineWidth = 1\n        ctx.lineCap = 'square'\n        ctx.lineJoin = 'miter'\n        ctx.fill()\n        ctx.stroke()\n\n        // SOUTHPOINTER\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.467289, imageHeight * 0.546728)\n        ctx.bezierCurveTo(\n          imageWidth * 0.467289,\n          imageHeight * 0.546728,\n          imageWidth * 0.5,\n          imageHeight * 0.850467,\n          imageWidth * 0.5,\n          imageHeight * 0.850467\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.5,\n          imageHeight * 0.850467,\n          imageWidth * 0.53271,\n          imageHeight * 0.546728,\n          imageWidth * 0.53271,\n          imageHeight * 0.546728\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.546728,\n          imageHeight * 0.537383,\n          imageWidth * 0.556074,\n          imageHeight * 0.518691,\n          imageWidth * 0.556074,\n          imageHeight * 0.5\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.556074,\n          imageHeight * 0.5,\n          imageWidth * 0.443925,\n          imageHeight * 0.5,\n          imageWidth * 0.443925,\n          imageHeight * 0.5\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.443925,\n          imageHeight * 0.518691,\n          imageWidth * 0.453271,\n          imageHeight * 0.537383,\n          imageWidth * 0.467289,\n          imageHeight * 0.546728\n        )\n        ctx.closePath()\n        const SOUTHPOINTER2_GRADIENT = ctx.createLinearGradient(\n          0.471962 * imageWidth,\n          0,\n          0.528036 * imageWidth,\n          0\n        )\n        SOUTHPOINTER2_GRADIENT.addColorStop(0, '#e3e5e8')\n        SOUTHPOINTER2_GRADIENT.addColorStop(0.48, '#e3e5e8')\n        SOUTHPOINTER2_GRADIENT.addColorStop(0.48, '#abb1b8')\n        SOUTHPOINTER2_GRADIENT.addColorStop(1, '#abb1b8')\n        ctx.fillStyle = SOUTHPOINTER2_GRADIENT\n        const strokeColor_SOUTHPOINTER2 = '#abb1b8'\n        ctx.strokeStyle = strokeColor_SOUTHPOINTER2\n        ctx.lineWidth = 1\n        ctx.lineCap = 'square'\n        ctx.lineJoin = 'miter'\n        ctx.fill()\n        ctx.stroke()\n      }\n        break\n\n      case 'type3': {\n        // NORTHPOINTER\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.5, imageHeight * 0.149532)\n        ctx.bezierCurveTo(\n          imageWidth * 0.5,\n          imageHeight * 0.149532,\n          imageWidth * 0.443925,\n          imageHeight * 0.490654,\n          imageWidth * 0.443925,\n          imageHeight * 0.5\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.443925,\n          imageHeight * 0.53271,\n          imageWidth * 0.467289,\n          imageHeight * 0.556074,\n          imageWidth * 0.5,\n          imageHeight * 0.556074\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.53271,\n          imageHeight * 0.556074,\n          imageWidth * 0.556074,\n          imageHeight * 0.53271,\n          imageWidth * 0.556074,\n          imageHeight * 0.5\n        )\n        ctx.bezierCurveTo(\n          imageWidth * 0.556074,\n          imageHeight * 0.490654,\n          imageWidth * 0.5,\n          imageHeight * 0.149532,\n          imageWidth * 0.5,\n          imageHeight * 0.149532\n        )\n        ctx.closePath()\n        const NORTHPOINTER3_GRADIENT = ctx.createLinearGradient(\n          0.471962 * imageWidth,\n          0,\n          0.528036 * imageWidth,\n          0\n        )\n        NORTHPOINTER3_GRADIENT.addColorStop(\n          0,\n          pointerColor.light.getRgbaColor()\n        )\n        NORTHPOINTER3_GRADIENT.addColorStop(\n          0.46,\n          pointerColor.light.getRgbaColor()\n        )\n        NORTHPOINTER3_GRADIENT.addColorStop(\n          0.47,\n          pointerColor.medium.getRgbaColor()\n        )\n        NORTHPOINTER3_GRADIENT.addColorStop(\n          1,\n          pointerColor.medium.getRgbaColor()\n        )\n        ctx.fillStyle = NORTHPOINTER3_GRADIENT\n        ctx.strokeStyle = pointerColor.dark.getRgbaColor()\n        ctx.lineWidth = 1\n        ctx.lineCap = 'square'\n        ctx.lineJoin = 'miter'\n        ctx.fill()\n        ctx.stroke()\n      }\n        break\n\n      case 'type1:':\n      /* falls through */\n      default: {\n        // NORTHPOINTER\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.5, imageHeight * 0.495327)\n        ctx.lineTo(imageWidth * 0.528037, imageHeight * 0.495327)\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.149532)\n        ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.495327)\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.495327)\n        ctx.closePath()\n        const NORTHPOINTER1_GRADIENT = ctx.createLinearGradient(\n          0.471962 * imageWidth,\n          0,\n          0.528036 * imageWidth,\n          0\n        )\n        NORTHPOINTER1_GRADIENT.addColorStop(\n          0,\n          pointerColor.light.getRgbaColor()\n        )\n        NORTHPOINTER1_GRADIENT.addColorStop(\n          0.46,\n          pointerColor.light.getRgbaColor()\n        )\n        NORTHPOINTER1_GRADIENT.addColorStop(\n          0.47,\n          pointerColor.medium.getRgbaColor()\n        )\n        NORTHPOINTER1_GRADIENT.addColorStop(\n          1,\n          pointerColor.medium.getRgbaColor()\n        )\n        ctx.fillStyle = NORTHPOINTER1_GRADIENT\n        ctx.strokeStyle = pointerColor.dark.getRgbaColor()\n        ctx.lineWidth = 1\n        ctx.lineCap = 'square'\n        ctx.lineJoin = 'miter'\n        ctx.fill()\n        ctx.stroke()\n\n        // SOUTHPOINTER\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.5, imageHeight * 0.504672)\n        ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.504672)\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.850467)\n        ctx.lineTo(imageWidth * 0.528037, imageHeight * 0.504672)\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.504672)\n        ctx.closePath()\n        const SOUTHPOINTER1_GRADIENT = ctx.createLinearGradient(\n          0.471962 * imageWidth,\n          0,\n          0.528036 * imageWidth,\n          0\n        )\n        SOUTHPOINTER1_GRADIENT.addColorStop(0, '#e3e5e8')\n        SOUTHPOINTER1_GRADIENT.addColorStop(0.48, '#e3e5e8')\n        SOUTHPOINTER1_GRADIENT.addColorStop(0.480099, '#abb1b8')\n        SOUTHPOINTER1_GRADIENT.addColorStop(1, '#abb1b8')\n        ctx.fillStyle = SOUTHPOINTER1_GRADIENT\n        const strokeColor_SOUTHPOINTER = '#abb1b8'\n        ctx.strokeStyle = strokeColor_SOUTHPOINTER\n        ctx.lineWidth = 1\n        ctx.lineCap = 'square'\n        ctx.lineJoin = 'miter'\n        ctx.fill()\n        ctx.stroke()\n      }\n        break\n    }\n    ctx.restore()\n  }\n\n  // **************   Initialization  ********************\n  // Draw all static painting code to background\n  const init = function () {\n    initialized = true\n\n    if (frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        backgroundContext,\n        frameDesign,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    if (backgroundVisible) {\n      Object(_drawBackground__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n      Object(_drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        backgroundContext,\n        customLayer,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      if (roseVisible) {\n        Object(_drawRoseImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n          roseContext,\n          centerX,\n          centerY,\n          imageWidth,\n          imageHeight,\n          backgroundColor\n        )\n      }\n\n      drawTickmarksImage(roseContext)\n    }\n\n    drawPointerImage(pointerContext, false)\n\n    if (foregroundVisible) {\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        true,\n        knobType,\n        knobStyle\n      )\n    }\n  }\n\n  const resetBuffers = function () {\n    // Buffer for all static background painting code\n    backgroundBuffer.width = size\n    backgroundBuffer.height = size\n    backgroundContext = backgroundBuffer.getContext('2d')\n\n    // Buffer for symbols/rose painting code\n    roseBuffer.width = size\n    roseBuffer.height = size\n    roseContext = roseBuffer.getContext('2d')\n\n    // Buffer for pointer image painting code\n    pointerBuffer.width = size\n    pointerBuffer.height = size\n    pointerContext = pointerBuffer.getContext('2d')\n\n    // Buffer for static foreground painting code\n    foregroundBuffer.width = size\n    foregroundBuffer.height = size\n    foregroundContext = foregroundBuffer.getContext('2d')\n  }\n\n  //* *********************************** Public methods **************************************\n  this.setValue = function (newValue) {\n    newValue = parseFloat(newValue) % 360\n    if (value !== newValue) {\n      value = newValue\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.setValueAnimated = function (newValue, callback) {\n    const targetValue = newValue % 360\n    const gauge = this\n    let diff\n    if (value !== targetValue) {\n      if (undefined !== tween && tween.isPlaying) {\n        tween.stop()\n      }\n\n      diff = Object(_tools__WEBPACK_IMPORTED_MODULE_6__[\"getShortestAngle\"])(value, targetValue)\n      if (rotateFace) {\n        tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n          {},\n          '',\n          _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n          value,\n          value + diff,\n          2\n        )\n      } else {\n        tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({}, '', _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].elasticEaseOut, value, value + diff, 2)\n      }\n      tween.onMotionChanged = function (event) {\n        value = event.target._pos % 360\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_6__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tween.onMotionFinished = callback\n      }\n\n      tween.start()\n    }\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers()\n    frameDesign = newFrameDesign\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers()\n    backgroundColor = newBackgroundColor\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers()\n    foregroundType = newForegroundType\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setPointerColor = function (newPointerColor) {\n    resetBuffers()\n    pointerColor = newPointerColor\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setPointerType = function (newPointerType) {\n    resetBuffers()\n    pointerType = newPointerType\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setPointSymbols = function (newPointSymbols) {\n    resetBuffers()\n    pointSymbols = newPointSymbols\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init()\n    }\n\n    mainCtx.save()\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n    // Define rotation center\n    angle = _tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"] + value * angleStep - _tools__WEBPACK_IMPORTED_MODULE_6__[\"HALF_PI\"]\n\n    if (backgroundVisible || frameVisible) {\n      mainCtx.drawImage(backgroundBuffer, 0, 0)\n    }\n\n    if (rotateFace) {\n      mainCtx.save()\n      mainCtx.translate(centerX, centerY)\n      mainCtx.rotate(-angle)\n      mainCtx.translate(-centerX, -centerY)\n      if (backgroundVisible) {\n        mainCtx.drawImage(roseBuffer, 0, 0)\n      }\n      mainCtx.restore()\n    } else {\n      if (backgroundVisible) {\n        mainCtx.drawImage(roseBuffer, 0, 0)\n      }\n      mainCtx.translate(centerX, centerY)\n      mainCtx.rotate(angle)\n      mainCtx.translate(-centerX, -centerY)\n    }\n    // Set the pointer shadow params\n    mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset\n    mainCtx.shadowBlur = shadowOffset * 2\n    // Draw the pointer\n    mainCtx.drawImage(pointerBuffer, 0, 0)\n    // Undo the translations & shadow settings\n    mainCtx.restore()\n\n    if (foregroundVisible) {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Compass);\n\n\n//# sourceURL=webpack://steelseries/./src/Compass.js?");

/***/ }),

/***/ "./src/DisplayMulti.js":
/*!*****************************!*\
  !*** ./src/DisplayMulti.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createLcdBackgroundImage */ \"./src/createLcdBackgroundImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\nconst DisplayMulti = function (canvas, parameters) {\n  parameters = parameters || {}\n  let width = undefined === parameters.width ? 0 : parameters.width\n  let height = undefined === parameters.height ? 0 : parameters.height\n  let lcdColor =\n    undefined === parameters.lcdColor ? _definitions__WEBPACK_IMPORTED_MODULE_2__[\"LcdColor\"].STANDARD : parameters.lcdColor\n  const lcdDecimals =\n    undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals\n  const headerString =\n    undefined === parameters.headerString ? '' : parameters.headerString\n  const headerStringVisible =\n    undefined === parameters.headerStringVisible\n      ? false\n      : parameters.headerStringVisible\n  const detailString =\n    undefined === parameters.detailString ? '' : parameters.detailString\n  const detailStringVisible =\n    undefined === parameters.detailStringVisible\n      ? false\n      : parameters.detailStringVisible\n  const detailUnitString = undefined === parameters.detailUnitString ? '' : parameters.detailUnitString\n const linkAltValue =\n    undefined === parameters.linkAltValue ? true : parameters.linkAltValue\n  const unitString =\n    undefined === parameters.unitString ? '' : parameters.unitString\n  const unitStringVisible =\n    undefined === parameters.unitStringVisible\n      ? false\n      : parameters.unitStringVisible\n  const digitalFont =\n    undefined === parameters.digitalFont ? false : parameters.digitalFont\n  const valuesNumeric =\n    undefined === parameters.valuesNumeric ? true : parameters.valuesNumeric\n  let value = undefined === parameters.value ? 0 : parameters.value\n  let altValue = undefined === parameters.altValue ? 0 : parameters.altValue\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (width === 0) {\n    width = mainCtx.canvas.width\n  }\n  if (height === 0) {\n    height = mainCtx.canvas.height\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = width\n  mainCtx.canvas.height = height\n\n  const imageWidth = width\n  const imageHeight = height\n\n  const stdFont = Math.floor(imageHeight / 1.875) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n  const lcdFont = Math.floor(imageHeight / 1.875) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"lcdFontName\"]\n  const stdAltFont = Math.floor(imageHeight / 3.5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n  const lcdAltFont = Math.floor(imageHeight / 3.5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"lcdFontName\"]\n\n  let initialized = false\n\n  // **************   Buffer creation  ********************\n  // Buffer for the lcd\n  let lcdBuffer\n\n  // **************   Image creation  ********************\n  const drawLcdText = function (value) {\n    mainCtx.save()\n    mainCtx.textAlign = 'right'\n    mainCtx.textBaseline = 'middle'\n    mainCtx.strokeStyle = lcdColor.textColor\n    mainCtx.fillStyle = lcdColor.textColor\n\n    if (\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_2__[\"LcdColor\"].STANDARD ||\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_2__[\"LcdColor\"].STANDARD_GREEN\n    ) {\n      mainCtx.shadowColor = 'gray'\n      mainCtx.shadowOffsetX = imageHeight * 0.025\n      mainCtx.shadowOffsetY = imageHeight * 0.025\n      mainCtx.shadowBlur = imageHeight * 0.05\n    }\n\n    if (valuesNumeric) {\n      // Numeric value\n      if (headerStringVisible) {\n        mainCtx.font = Math.floor(imageHeight / 3) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n      } else {\n        mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n      }\n      let unitWidth = 0\n      if (unitStringVisible) {\n        if (headerStringVisible) {\n          mainCtx.font = Math.floor(imageHeight / 3) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n          unitWidth = mainCtx.measureText(unitString).width\n        } else {\n          mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n          unitWidth = mainCtx.measureText(unitString).width\n        }\n      }\n      mainCtx.font = digitalFont ? lcdFont : stdFont\n      const valueText = value.toFixed(lcdDecimals)\n      if (headerStringVisible) {\n        mainCtx.fillText(\n          valueText,\n          imageWidth - unitWidth - 4,\n          imageHeight * 0.5\n        )\n      } else {\n        mainCtx.fillText(\n          valueText,\n          imageWidth - unitWidth - 4,\n          imageHeight * 0.38\n        )\n      }\n\n      if (unitStringVisible) {\n        mainCtx.font = Math.floor(imageHeight / 3) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n        mainCtx.fillText(unitString, imageWidth - 2, imageHeight * 0.55)\n      }\n\n      let altValueText = altValue.toFixed(lcdDecimals)\n      if (detailStringVisible) {\n        altValueText = detailString + altValueText + detailUnitString\n      }\n      if (digitalFont) {\n        mainCtx.font = lcdAltFont\n      } else {\n        if (headerStringVisible) {\n          mainCtx.font = Math.floor(imageHeight / 5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n        } else {\n          mainCtx.font = stdAltFont\n        }\n      }\n      mainCtx.textAlign = 'center'\n      if (headerStringVisible) {\n        mainCtx.fillText(altValueText, imageWidth / 2, imageHeight * 0.83)\n        mainCtx.fillText(headerString, imageWidth / 2, imageHeight * 0.16)\n      } else {\n        mainCtx.fillText(altValueText, imageWidth / 2, imageHeight * 0.8)\n      }\n    } else {\n      if (headerStringVisible) {\n        // Text value\n        mainCtx.font = Math.floor(imageHeight / 3.5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n        mainCtx.fillText(value, imageWidth - 2, imageHeight * 0.48)\n\n        // mainCtx.font = stdAltFont;\n        mainCtx.font = Math.floor(imageHeight / 5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n        mainCtx.textAlign = 'center'\n        mainCtx.fillText(altValue, imageWidth / 2, imageHeight * 0.83)\n        mainCtx.fillText(headerString, imageWidth / 2, imageHeight * 0.17)\n      } else {\n        // Text value\n        mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n        mainCtx.fillText(value, imageWidth - 2, imageHeight * 0.38)\n\n        mainCtx.font = stdAltFont\n        mainCtx.textAlign = 'center'\n        mainCtx.fillText(altValue, imageWidth / 2, imageHeight * 0.8)\n      }\n    }\n    mainCtx.restore()\n  }\n\n  // **************   Initialization  ********************\n  const init = function () {\n    initialized = true\n\n    // Create lcd background if selected in background buffer (backgroundBuffer)\n    lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(width, height, lcdColor)\n  }\n\n  // **************   Public methods  ********************\n  this.setValue = function (newValue) {\n    if (value !== newValue) {\n      if (linkAltValue) {\n        altValue = value\n      }\n      value = newValue\n      this.repaint()\n    }\n    return this\n  }\n\n  this.setAltValue = function (altValueNew) {\n    if (altValue !== altValueNew) {\n      altValue = altValueNew\n      this.repaint()\n    }\n    return this\n  }\n\n  this.setLcdColor = function (newLcdColor) {\n    lcdColor = newLcdColor\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init()\n    }\n\n    // mainCtx.save();\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    // Draw lcd background\n    mainCtx.drawImage(lcdBuffer, 0, 0)\n\n    // Draw lcd text\n    drawLcdText(value)\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (DisplayMulti);\n\n\n//# sourceURL=webpack://steelseries/./src/DisplayMulti.js?");

/***/ }),

/***/ "./src/DisplaySingle.js":
/*!******************************!*\
  !*** ./src/DisplaySingle.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createLcdBackgroundImage */ \"./src/createLcdBackgroundImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\nconst DisplaySingle = function (canvas, parameters) {\n  parameters = parameters || {}\n  let width = undefined === parameters.width ? 0 : parameters.width\n  let height = undefined === parameters.height ? 0 : parameters.height\n  let lcdColor =\n    undefined === parameters.lcdColor ? _definitions__WEBPACK_IMPORTED_MODULE_2__[\"LcdColor\"].STANDARD : parameters.lcdColor\n  const lcdDecimals =\n    undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals\n  const unitString =\n    undefined === parameters.unitString ? '' : parameters.unitString\n  const unitStringVisible =\n    undefined === parameters.unitStringVisible\n      ? false\n      : parameters.unitStringVisible\n  const headerString =\n    undefined === parameters.headerString ? '' : parameters.headerString\n  const headerStringVisible =\n    undefined === parameters.headerStringVisible\n      ? false\n      : parameters.headerStringVisible\n  const digitalFont =\n    undefined === parameters.digitalFont ? false : parameters.digitalFont\n  const valuesNumeric =\n    undefined === parameters.valuesNumeric ? true : parameters.valuesNumeric\n  let value = undefined === parameters.value ? 0 : parameters.value\n  const alwaysScroll =\n    undefined === parameters.alwaysScroll ? false : parameters.alwaysScroll\n  const autoScroll =\n    undefined === parameters.autoScroll ? false : parameters.autoScroll\n  let section = undefined === parameters.section ? null : parameters.section\n\n  let scrolling = false\n  let scrollX = 0\n  let scrollTimer\n  let repainting = false\n\n  const self = this\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (width === 0) {\n    width = mainCtx.canvas.width\n  }\n  if (height === 0) {\n    height = mainCtx.canvas.height\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = width\n  mainCtx.canvas.height = height\n\n  const imageWidth = width\n  const imageHeight = height\n  let textWidth = 0\n\n  const fontHeight = Math.floor(imageHeight / 1.5)\n  const stdFont = fontHeight + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n  const lcdFont = fontHeight + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"lcdFontName\"]\n\n  let initialized = false\n\n  // **************   Buffer creation  ********************\n  // Buffer for the lcd\n  let lcdBuffer\n  const sectionBuffer = []\n  const sectionForegroundColor = []\n\n  // **************   Image creation  ********************\n  const drawLcdText = function (value, color) {\n    mainCtx.save()\n    mainCtx.textAlign = 'right'\n    // mainCtx.textBaseline = 'top';\n    mainCtx.strokeStyle = color\n    mainCtx.fillStyle = color\n\n    mainCtx.beginPath()\n    mainCtx.rect(2, 0, imageWidth - 4, imageHeight)\n    mainCtx.closePath()\n    mainCtx.clip()\n\n    if (\n      (lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_2__[\"LcdColor\"].STANDARD ||\n        lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_2__[\"LcdColor\"].STANDARD_GREEN) &&\n      section === null\n    ) {\n      mainCtx.shadowColor = 'gray'\n      mainCtx.shadowOffsetX = imageHeight * 0.035\n      mainCtx.shadowOffsetY = imageHeight * 0.035\n      mainCtx.shadowBlur = imageHeight * 0.055\n    }\n\n    mainCtx.font = digitalFont ? lcdFont : stdFont\n\n    if (valuesNumeric) {\n      // Numeric value\n      let unitWidth = 0\n      textWidth = 0\n      if (unitStringVisible) {\n        mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n        unitWidth = mainCtx.measureText(unitString).width\n      }\n      mainCtx.font = digitalFont ? lcdFont : stdFont\n      const lcdText = value.toFixed(lcdDecimals)\n      textWidth = mainCtx.measureText(lcdText).width\n      let vPos = 0.38\n      if (headerStringVisible) {\n        vPos = 0.52\n      }\n\n      mainCtx.fillText(\n        lcdText,\n        imageWidth - unitWidth - 4 - scrollX,\n        imageHeight * 0.5 + fontHeight * vPos\n      )\n\n      if (unitStringVisible) {\n        mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n        mainCtx.fillText(\n          unitString,\n          imageWidth - 2 - scrollX,\n          imageHeight * 0.5 + fontHeight * vPos\n        )\n      }\n      if (headerStringVisible) {\n        mainCtx.textAlign = 'center'\n        mainCtx.font = Math.floor(imageHeight / 3.5) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_1__[\"stdFontName\"]\n        mainCtx.fillText(headerString, imageWidth / 2, imageHeight * 0.3)\n      }\n    } else {\n      // Text value\n      textWidth = mainCtx.measureText(value).width\n      if (alwaysScroll || (autoScroll && textWidth > imageWidth - 4)) {\n        if (!scrolling) {\n          if (textWidth > imageWidth * 0.8) {\n            // leave 20% blank leading space to give time to read start of message\n            scrollX = imageWidth - textWidth - imageWidth * 0.2\n          } else {\n            scrollX = 0\n          }\n          scrolling = true\n          clearTimeout(scrollTimer) // kill any pending animate\n          scrollTimer = setTimeout(animate, 200)\n        }\n      } else if (autoScroll && textWidth <= imageWidth - 4) {\n        scrollX = 0\n        scrolling = false\n      }\n      mainCtx.fillText(\n        value,\n        imageWidth - 2 - scrollX,\n        imageHeight * 0.5 + fontHeight * 0.38\n      )\n    }\n    mainCtx.restore()\n  }\n\n  const createLcdSectionImage = function (width, height, color, lcdColor) {\n    const lcdSectionBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"createBuffer\"])(width, height)\n    const lcdCtx = lcdSectionBuffer.getContext('2d')\n\n    lcdCtx.save()\n    const xB = 0\n    const yB = 0\n    const wB = width\n    const hB = height\n    const rB = Math.min(width, height) * 0.095\n\n    const lcdBackground = lcdCtx.createLinearGradient(0, yB, 0, yB + hB)\n\n    lcdBackground.addColorStop(0, '#4c4c4c')\n    lcdBackground.addColorStop(0.08, '#666666')\n    lcdBackground.addColorStop(0.92, '#666666')\n    lcdBackground.addColorStop(1, '#e6e6e6')\n    lcdCtx.fillStyle = lcdBackground\n\n    Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"roundedRectangle\"])(lcdCtx, xB, yB, wB, hB, rB)\n\n    lcdCtx.fill()\n    lcdCtx.restore()\n\n    lcdCtx.save()\n\n    const rgb = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getColorValues\"])(color)\n    const hsb = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"rgbToHsb\"])(rgb[0], rgb[1], rgb[2])\n\n    const rgbStart = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getColorValues\"])(lcdColor.gradientStartColor)\n    const hsbStart = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"rgbToHsb\"])(rgbStart[0], rgbStart[1], rgbStart[2])\n    const rgbFraction1 = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getColorValues\"])(lcdColor.gradientFraction1Color)\n    const hsbFraction1 = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"rgbToHsb\"])(\n      rgbFraction1[0],\n      rgbFraction1[1],\n      rgbFraction1[2]\n    )\n    const rgbFraction2 = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getColorValues\"])(lcdColor.gradientFraction2Color)\n    const hsbFraction2 = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"rgbToHsb\"])(\n      rgbFraction2[0],\n      rgbFraction2[1],\n      rgbFraction2[2]\n    )\n    const rgbFraction3 = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getColorValues\"])(lcdColor.gradientFraction3Color)\n    const hsbFraction3 = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"rgbToHsb\"])(\n      rgbFraction3[0],\n      rgbFraction3[1],\n      rgbFraction3[2]\n    )\n    const rgbStop = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getColorValues\"])(lcdColor.gradientStopColor)\n    const hsbStop = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"rgbToHsb\"])(rgbStop[0], rgbStop[1], rgbStop[2])\n\n    const startColor = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"hsbToRgb\"])(hsb[0], hsb[1], hsbStart[2] - 0.31)\n    const fraction1Color = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"hsbToRgb\"])(hsb[0], hsb[1], hsbFraction1[2] - 0.31)\n    const fraction2Color = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"hsbToRgb\"])(hsb[0], hsb[1], hsbFraction2[2] - 0.31)\n    const fraction3Color = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"hsbToRgb\"])(hsb[0], hsb[1], hsbFraction3[2] - 0.31)\n    const stopColor = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"hsbToRgb\"])(hsb[0], hsb[1], hsbStop[2] - 0.31)\n\n    const xF = 1\n    const yF = 1\n    const wF = width - 2\n    const hF = height - 2\n    const rF = rB - 1\n    const lcdForeground = lcdCtx.createLinearGradient(0, yF, 0, yF + hF)\n    lcdForeground.addColorStop(\n      0,\n      'rgb(' + startColor[0] + ', ' + startColor[1] + ', ' + startColor[2] + ')'\n    )\n    lcdForeground.addColorStop(\n      0.03,\n      'rgb(' +\n        fraction1Color[0] +\n        ',' +\n        fraction1Color[1] +\n        ',' +\n        fraction1Color[2] +\n        ')'\n    )\n    lcdForeground.addColorStop(\n      0.49,\n      'rgb(' +\n        fraction2Color[0] +\n        ',' +\n        fraction2Color[1] +\n        ',' +\n        fraction2Color[2] +\n        ')'\n    )\n    lcdForeground.addColorStop(\n      0.5,\n      'rgb(' +\n        fraction3Color[0] +\n        ',' +\n        fraction3Color[1] +\n        ',' +\n        fraction3Color[2] +\n        ')'\n    )\n    lcdForeground.addColorStop(\n      1,\n      'rgb(' + stopColor[0] + ',' + stopColor[1] + ',' + stopColor[2] + ')'\n    )\n    lcdCtx.fillStyle = lcdForeground\n\n    Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"roundedRectangle\"])(lcdCtx, xF, yF, wF, hF, rF)\n\n    lcdCtx.fill()\n    lcdCtx.restore()\n\n    return lcdSectionBuffer\n  }\n\n  const createSectionForegroundColor = function (sectionColor) {\n    const rgbSection = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getColorValues\"])(sectionColor)\n    const hsbSection = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"rgbToHsb\"])(rgbSection[0], rgbSection[1], rgbSection[2])\n    const sectionForegroundRgb = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"hsbToRgb\"])(hsbSection[0], 0.57, 0.83)\n    return (\n      'rgb(' +\n      sectionForegroundRgb[0] +\n      ', ' +\n      sectionForegroundRgb[1] +\n      ', ' +\n      sectionForegroundRgb[2] +\n      ')'\n    )\n  }\n\n  const animate = function () {\n    if (scrolling) {\n      if (scrollX > imageWidth) {\n        scrollX = -textWidth\n      }\n      scrollX += 2\n      scrollTimer = setTimeout(animate, 50)\n    } else {\n      scrollX = 0\n    }\n    if (!repainting) {\n      repainting = true\n      Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"requestAnimFrame\"])(self.repaint)\n    }\n  }\n\n  // **************   Initialization  ********************\n  const init = function () {\n    let sectionIndex\n    initialized = true\n\n    // Create lcd background if selected in background buffer (backgroundBuffer)\n    lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(width, height, lcdColor)\n\n    if (section !== null && section.length > 0) {\n      for (sectionIndex = 0; sectionIndex < section.length; sectionIndex++) {\n        sectionBuffer[sectionIndex] = createLcdSectionImage(\n          width,\n          height,\n          section[sectionIndex].color,\n          lcdColor\n        )\n        sectionForegroundColor[sectionIndex] = createSectionForegroundColor(\n          section[sectionIndex].color\n        )\n      }\n    }\n  }\n\n  // **************   Public methods  ********************\n  this.setValue = function (newValue) {\n    if (value !== newValue) {\n      value = newValue\n      this.repaint()\n    }\n    return this\n  }\n\n  this.setLcdColor = function (newLcdColor) {\n    lcdColor = newLcdColor\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setSection = function (newSection) {\n    section = newSection\n    init({\n      background: true,\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setScrolling = function (scroll) {\n    if (scroll) {\n      if (scrolling) {\n        return\n      } else {\n        scrolling = scroll\n        animate()\n      }\n    } else {\n      // disable scrolling\n      scrolling = scroll\n    }\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init()\n    }\n\n    // mainCtx.save();\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    let lcdBackgroundBuffer = lcdBuffer\n    let lcdTextColor = lcdColor.textColor\n    let sectionIndex\n    // Draw sections\n    if (section !== null && section.length > 0) {\n      for (sectionIndex = 0; sectionIndex < section.length; sectionIndex++) {\n        if (\n          value >= section[sectionIndex].start &&\n          value <= section[sectionIndex].stop\n        ) {\n          lcdBackgroundBuffer = sectionBuffer[sectionIndex]\n          lcdTextColor = sectionForegroundColor[sectionIndex]\n          break\n        }\n      }\n    }\n\n    // Draw lcd background\n    mainCtx.drawImage(lcdBackgroundBuffer, 0, 0)\n\n    // Draw lcd text\n    drawLcdText(value, lcdTextColor)\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (DisplaySingle);\n\n\n//# sourceURL=webpack://steelseries/./src/DisplaySingle.js?");

/***/ }),

/***/ "./src/Horizon.js":
/*!************************!*\
  !*** ./src/Horizon.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\nconst Horizon = function (canvas, parameters) {\n  parameters = parameters || {}\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_4__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_4__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  const pointerColor =\n    undefined === parameters.pointerColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_4__[\"ColorDef\"].WHITE\n      : parameters.pointerColor\n\n  let tweenRoll\n  let tweenPitch\n  let repainting = false\n  let roll = 0\n  let pitch = 0\n  const pitchPixel = (_tools__WEBPACK_IMPORTED_MODULE_3__[\"PI\"] * size) / 360\n  let pitchOffset = 0\n  let upsidedown = false\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (size === 0) {\n    size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height)\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  const imageWidth = size\n  const imageHeight = size\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight / 2\n\n  let initialized = false\n\n  // **************   Buffer creation  ********************\n  // Buffer for all static background painting code\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"createBuffer\"])(size, size)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  // Buffer for pointer image painting code\n  const valueBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"createBuffer\"])(size, size * _tools__WEBPACK_IMPORTED_MODULE_3__[\"PI\"])\n  let valueContext = valueBuffer.getContext('2d')\n\n  // Buffer for indicator painting code\n  const indicatorBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"createBuffer\"])(size * 0.037383, size * 0.056074)\n  let indicatorContext = indicatorBuffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"createBuffer\"])(size, size)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  // **************   Image creation  ********************\n  const drawHorizonBackgroundImage = function (ctx) {\n    ctx.save()\n\n    const imgWidth = size\n    const imgHeight = size * _tools__WEBPACK_IMPORTED_MODULE_3__[\"PI\"]\n    let y\n\n    // HORIZON\n    ctx.beginPath()\n    ctx.rect(0, 0, imgWidth, imgHeight)\n    ctx.closePath()\n    const HORIZON_GRADIENT = ctx.createLinearGradient(0, 0, 0, imgHeight)\n    HORIZON_GRADIENT.addColorStop(0, '#7fd5f0')\n    HORIZON_GRADIENT.addColorStop(0.5, '#7fd5f0')\n    HORIZON_GRADIENT.addColorStop(0.5, '#3c4439')\n    HORIZON_GRADIENT.addColorStop(1, '#3c4439')\n    ctx.fillStyle = HORIZON_GRADIENT\n    ctx.fill()\n\n    ctx.lineWidth = 1\n    const stepSizeY = (imgHeight / 360) * 5\n    let stepTen = false\n    let step = 10\n\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    const fontSize = imgWidth * 0.04\n    ctx.font = fontSize + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_3__[\"stdFontName\"]\n    ctx.fillStyle = '#37596e'\n    for (y = imgHeight / 2 - stepSizeY; y > 0; y -= stepSizeY) {\n      if (step <= 90) {\n        if (stepTen) {\n          ctx.fillText(\n            step,\n            (imgWidth - imgWidth * 0.2) / 2 - 8,\n            y,\n            imgWidth * 0.375\n          )\n          ctx.fillText(\n            step,\n            imgWidth - (imgWidth - imgWidth * 0.2) / 2 + 8,\n            y,\n            imgWidth * 0.375\n          )\n          ctx.beginPath()\n          ctx.moveTo((imgWidth - imgWidth * 0.2) / 2, y)\n          ctx.lineTo(imgWidth - (imgWidth - imgWidth * 0.2) / 2, y)\n          ctx.closePath()\n          step += 10\n        } else {\n          ctx.beginPath()\n          ctx.moveTo((imgWidth - imgWidth * 0.1) / 2, y)\n          ctx.lineTo(imgWidth - (imgWidth - imgWidth * 0.1) / 2, y)\n          ctx.closePath()\n        }\n        ctx.stroke()\n      }\n      stepTen ^= true\n    }\n    stepTen = false\n    step = 10\n    ctx.strokeStyle = '#FFFFFF'\n    ctx.lineWidth = 1.5\n    ctx.beginPath()\n    ctx.moveTo(0, imgHeight / 2)\n    ctx.lineTo(imgWidth, imgHeight / 2)\n    ctx.closePath()\n    ctx.stroke()\n    ctx.fillStyle = '#FFFFFF'\n    ctx.lineWidth = 1\n    for (y = imgHeight / 2 + stepSizeY; y <= imgHeight; y += stepSizeY) {\n      if (step <= 90) {\n        if (stepTen) {\n          ctx.fillText(\n            -step,\n            (imgWidth - imgWidth * 0.2) / 2 - 8,\n            y,\n            imgWidth * 0.375\n          )\n          ctx.fillText(\n            -step,\n            imgWidth - (imgWidth - imgWidth * 0.2) / 2 + 8,\n            y,\n            imgWidth * 0.375\n          )\n          ctx.beginPath()\n          ctx.moveTo((imgWidth - imgWidth * 0.2) / 2, y)\n          ctx.lineTo(imgWidth - (imgWidth - imgWidth * 0.2) / 2, y)\n          ctx.closePath()\n          step += 10\n        } else {\n          ctx.beginPath()\n          ctx.moveTo((imgWidth - imgWidth * 0.1) / 2, y)\n          ctx.lineTo(imgWidth - (imgWidth - imgWidth * 0.1) / 2, y)\n          ctx.closePath()\n        }\n        ctx.stroke()\n      }\n      stepTen ^= true\n    }\n\n    ctx.restore()\n  }\n\n  const drawHorizonForegroundImage = function (ctx) {\n    ctx.save()\n\n    ctx.fillStyle = pointerColor.light.getRgbaColor()\n\n    // CENTERINDICATOR\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.476635, imageHeight * 0.5)\n    ctx.bezierCurveTo(\n      imageWidth * 0.476635,\n      imageHeight * 0.514018,\n      imageWidth * 0.485981,\n      imageHeight * 0.523364,\n      imageWidth * 0.5,\n      imageHeight * 0.523364\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.514018,\n      imageHeight * 0.523364,\n      imageWidth * 0.523364,\n      imageHeight * 0.514018,\n      imageWidth * 0.523364,\n      imageHeight * 0.5\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.523364,\n      imageHeight * 0.485981,\n      imageWidth * 0.514018,\n      imageHeight * 0.476635,\n      imageWidth * 0.5,\n      imageHeight * 0.476635\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.485981,\n      imageHeight * 0.476635,\n      imageWidth * 0.476635,\n      imageHeight * 0.485981,\n      imageWidth * 0.476635,\n      imageHeight * 0.5\n    )\n    ctx.closePath()\n    ctx.moveTo(imageWidth * 0.415887, imageHeight * 0.504672)\n    ctx.lineTo(imageWidth * 0.415887, imageHeight * 0.495327)\n    ctx.bezierCurveTo(\n      imageWidth * 0.415887,\n      imageHeight * 0.495327,\n      imageWidth * 0.467289,\n      imageHeight * 0.495327,\n      imageWidth * 0.467289,\n      imageHeight * 0.495327\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.471962,\n      imageHeight * 0.481308,\n      imageWidth * 0.481308,\n      imageHeight * 0.471962,\n      imageWidth * 0.495327,\n      imageHeight * 0.467289\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.495327,\n      imageHeight * 0.467289,\n      imageWidth * 0.495327,\n      imageHeight * 0.415887,\n      imageWidth * 0.495327,\n      imageHeight * 0.415887\n    )\n    ctx.lineTo(imageWidth * 0.504672, imageHeight * 0.415887)\n    ctx.bezierCurveTo(\n      imageWidth * 0.504672,\n      imageHeight * 0.415887,\n      imageWidth * 0.504672,\n      imageHeight * 0.467289,\n      imageWidth * 0.504672,\n      imageHeight * 0.467289\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.518691,\n      imageHeight * 0.471962,\n      imageWidth * 0.528037,\n      imageHeight * 0.481308,\n      imageWidth * 0.53271,\n      imageHeight * 0.495327\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.53271,\n      imageHeight * 0.495327,\n      imageWidth * 0.584112,\n      imageHeight * 0.495327,\n      imageWidth * 0.584112,\n      imageHeight * 0.495327\n    )\n    ctx.lineTo(imageWidth * 0.584112, imageHeight * 0.504672)\n    ctx.bezierCurveTo(\n      imageWidth * 0.584112,\n      imageHeight * 0.504672,\n      imageWidth * 0.53271,\n      imageHeight * 0.504672,\n      imageWidth * 0.53271,\n      imageHeight * 0.504672\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.528037,\n      imageHeight * 0.518691,\n      imageWidth * 0.518691,\n      imageHeight * 0.53271,\n      imageWidth * 0.5,\n      imageHeight * 0.53271\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.481308,\n      imageHeight * 0.53271,\n      imageWidth * 0.471962,\n      imageHeight * 0.518691,\n      imageWidth * 0.467289,\n      imageHeight * 0.504672\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.467289,\n      imageHeight * 0.504672,\n      imageWidth * 0.415887,\n      imageHeight * 0.504672,\n      imageWidth * 0.415887,\n      imageHeight * 0.504672\n    )\n    ctx.closePath()\n    ctx.fill()\n\n    // Tickmarks\n    const step = 5\n    const stepRad = 5 * _tools__WEBPACK_IMPORTED_MODULE_3__[\"RAD_FACTOR\"]\n    ctx.translate(centerX, centerY)\n    ctx.rotate(-_tools__WEBPACK_IMPORTED_MODULE_3__[\"HALF_PI\"])\n    ctx.translate(-centerX, -centerY)\n    let angle\n    for (angle = -90; angle <= 90; angle += step) {\n      if (angle % 45 === 0 || angle === 0) {\n        ctx.strokeStyle = pointerColor.medium.getRgbaColor()\n        ctx.lineWidth = 2\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.5, imageHeight * 0.088785)\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.113)\n        ctx.closePath()\n        ctx.stroke()\n      } else if (angle % 15 === 0) {\n        ctx.strokeStyle = '#FFFFFF'\n        ctx.lineWidth = 1\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.5, imageHeight * 0.088785)\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.103785)\n        ctx.closePath()\n        ctx.stroke()\n      } else {\n        ctx.strokeStyle = '#FFFFFF'\n        ctx.lineWidth = 0.5\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.5, imageHeight * 0.088785)\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.093785)\n        ctx.closePath()\n        ctx.stroke()\n      }\n      ctx.translate(centerX, centerY)\n      ctx.rotate(stepRad, centerX, centerY)\n      ctx.translate(-centerX, -centerY)\n    }\n\n    ctx.restore()\n  }\n\n  const drawIndicatorImage = function (ctx) {\n    ctx.save()\n\n    const imgWidth = imageWidth * 0.037383\n    const imgHeight = imageHeight * 0.056074\n\n    ctx.beginPath()\n    ctx.moveTo(imgWidth * 0.5, 0)\n    ctx.lineTo(0, imgHeight)\n    ctx.lineTo(imgWidth, imgHeight)\n    ctx.closePath()\n\n    ctx.fillStyle = pointerColor.light.getRgbaColor()\n    ctx.fill()\n    ctx.strokeStyle = pointerColor.medium.getRgbaColor()\n    ctx.stroke()\n\n    ctx.restore()\n  }\n\n  // **************   Initialization  ********************\n  // Draw all static painting code to background\n  const init = function () {\n    initialized = true\n\n    if (frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        backgroundContext,\n        frameDesign,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    drawHorizonBackgroundImage(valueContext)\n\n    drawIndicatorImage(indicatorContext)\n\n    drawHorizonForegroundImage(foregroundContext)\n\n    if (foregroundVisible) {\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        true,\n        _definitions__WEBPACK_IMPORTED_MODULE_4__[\"KnobType\"],\n        _definitions__WEBPACK_IMPORTED_MODULE_4__[\"KnobStyle\"],\n        _definitions__WEBPACK_IMPORTED_MODULE_4__[\"GaugeType\"]\n      )\n    }\n  }\n\n  const resetBuffers = function () {\n    // Buffer for all static background painting code\n    backgroundBuffer.width = size\n    backgroundBuffer.height = size\n    backgroundContext = backgroundBuffer.getContext('2d')\n\n    // Buffer for pointer image painting code\n    valueBuffer.width = size\n    valueBuffer.height = size * _tools__WEBPACK_IMPORTED_MODULE_3__[\"PI\"]\n    valueContext = valueBuffer.getContext('2d')\n\n    // Buffer for the indicator\n    indicatorBuffer.width = size * 0.037383\n    indicatorBuffer.height = size * 0.056074\n    indicatorContext = indicatorBuffer.getContext('2d')\n\n    // Buffer for static foreground painting code\n    foregroundBuffer.width = size\n    foregroundBuffer.height = size\n    foregroundContext = foregroundBuffer.getContext('2d')\n  }\n\n  //* *********************************** Public methods **************************************\n  this.setRoll = function (newRoll) {\n    newRoll = parseFloat(newRoll) % 360\n    if (roll !== newRoll) {\n      roll = newRoll\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getRoll = function () {\n    return roll\n  }\n\n  this.setRollAnimated = function (newRoll, callback) {\n    const gauge = this\n    newRoll = parseFloat(newRoll) % 360\n    if (roll !== newRoll) {\n      if (undefined !== tweenRoll && tweenRoll.isPlaying) {\n        tweenRoll.stop()\n      }\n\n      tweenRoll = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({}, '', _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut, roll, newRoll, 1)\n\n      tweenRoll.onMotionChanged = function (event) {\n        roll = event.target._pos\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tweenRoll.onMotionFinished = callback\n      }\n\n      tweenRoll.start()\n    }\n    return this\n  }\n\n  this.setPitch = function (newPitch) {\n    // constrain to range -180..180\n    // normal range -90..90 and -180..-90/90..180 indicate inverted\n    newPitch = ((parseFloat(newPitch) + 180 - pitchOffset) % 360) - 180\n    // pitch = -(newPitch + pitchOffset) % 180;\n    if (pitch !== newPitch) {\n      pitch = newPitch\n      if (pitch > 90) {\n        pitch = 90 - (pitch - 90)\n        if (!upsidedown) {\n          this.setRoll(roll - 180)\n        }\n        upsidedown = true\n      } else if (pitch < -90) {\n        pitch = -90 + (-90 - pitch)\n        if (!upsidedown) {\n          this.setRoll(roll + 180)\n        }\n        upsidedown = true\n      } else {\n        upsidedown = false\n      }\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getPitch = function () {\n    return pitch\n  }\n\n  this.setPitchAnimated = function (newPitch, callback) {\n    const gauge = this\n    newPitch = parseFloat(newPitch)\n    // perform all range checking in setPitch()\n    if (pitch !== newPitch) {\n      if (undefined !== tweenPitch && tweenPitch.isPlaying) {\n        tweenPitch.stop()\n      }\n      tweenPitch = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n        {},\n        '',\n        _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n        pitch,\n        newPitch,\n        1\n      )\n      tweenPitch.onMotionChanged = function (event) {\n        pitch = event.target._pos\n        if (pitch > 90) {\n          pitch = 90 - (pitch - 90)\n          if (!upsidedown) {\n            this.setRoll(roll - 180)\n          }\n          upsidedown = true\n        } else if (pitch < -90) {\n          pitch = -90 + (-90 - pitch)\n          if (!upsidedown) {\n            this.setRoll(roll + 180)\n          }\n          upsidedown = true\n        } else {\n          upsidedown = false\n        }\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n        gauge.setPitch(event.target._pos)\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tweenPitch.onMotionFinished = callback\n      }\n\n      tweenPitch.start()\n    }\n    return this\n  }\n\n  this.setPitchOffset = function (newPitchOffset) {\n    pitchOffset = parseFloat(newPitchOffset)\n    this.repaint()\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers()\n    frameDesign = newFrameDesign\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers()\n    foregroundType = newForegroundType\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init()\n    }\n\n    mainCtx.save()\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    mainCtx.drawImage(backgroundBuffer, 0, 0)\n\n    mainCtx.save()\n\n    // Set the clipping area\n    mainCtx.beginPath()\n    mainCtx.arc(centerX, centerY, (imageWidth * 0.831775) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"], true)\n    mainCtx.closePath()\n    mainCtx.clip()\n\n    // Rotate around roll\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(-(roll * _tools__WEBPACK_IMPORTED_MODULE_3__[\"RAD_FACTOR\"]))\n    mainCtx.translate(-centerX, 0)\n    // Translate about dive\n    mainCtx.translate(0, pitch * pitchPixel)\n\n    // Draw horizon\n    mainCtx.drawImage(valueBuffer, 0, -valueBuffer.height / 2)\n\n    // Draw the scale and angle indicator\n    mainCtx.translate(0, -(pitch * pitchPixel) - centerY)\n    mainCtx.drawImage(\n      indicatorBuffer,\n      imageWidth * 0.5 - indicatorBuffer.width / 2,\n      imageWidth * 0.107476\n    )\n    mainCtx.restore()\n\n    mainCtx.drawImage(foregroundBuffer, 0, 0)\n\n    mainCtx.restore()\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Horizon);\n\n\n//# sourceURL=webpack://steelseries/./src/Horizon.js?");

/***/ }),

/***/ "./src/Led.js":
/*!********************!*\
  !*** ./src/Led.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createLedImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createLedImage */ \"./src/createLedImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\nconst Led = function (canvas, parameters) {\n  parameters = parameters || {}\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let ledColor =\n    undefined === parameters.ledColor ? _definitions__WEBPACK_IMPORTED_MODULE_2__[\"LedColor\"].RED_LED : parameters.ledColor\n\n  let ledBlinking = false\n  let ledTimerId = 0\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (size === 0) {\n    size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height)\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  let initialized = false\n\n  // Buffer for led on painting code\n  const ledBufferOn = _tools__WEBPACK_IMPORTED_MODULE_1__[\"doc\"].createElement('canvas')\n  ledBufferOn.width = size\n  ledBufferOn.height = size\n  const ledContextOn = ledBufferOn.getContext('2d')\n\n  // Buffer for led off painting code\n  const ledBufferOff = _tools__WEBPACK_IMPORTED_MODULE_1__[\"doc\"].createElement('canvas')\n  ledBufferOff.width = size\n  ledBufferOff.height = size\n  const ledContextOff = ledBufferOff.getContext('2d')\n\n  // Buffer for current led painting code\n  let ledBuffer = ledBufferOff\n\n  const init = function () {\n    initialized = true\n\n    // Draw LED ON in ledBuffer_ON\n    ledContextOn.clearRect(\n      0,\n      0,\n      ledContextOn.canvas.width,\n      ledContextOn.canvas.height\n    )\n    ledContextOn.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(size, 1, ledColor), 0, 0)\n\n    // Draw LED ON in ledBuffer_OFF\n    ledContextOff.clearRect(\n      0,\n      0,\n      ledContextOff.canvas.width,\n      ledContextOff.canvas.height\n    )\n    ledContextOff.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(size, 0, ledColor), 0, 0)\n  }\n\n  this.toggleLed = function () {\n    if (ledBuffer === ledBufferOn) {\n      ledBuffer = ledBufferOff\n    } else {\n      ledBuffer = ledBufferOn\n    }\n    repaint()\n    return this\n  }\n\n  this.setLedColor = function (newColor) {\n    ledColor = newColor\n    initialized = false\n    repaint()\n    return this\n  }\n\n  this.setLedOnOff = function (on) {\n    if (on) {\n      ledBuffer = ledBufferOn\n    } else {\n      ledBuffer = ledBufferOff\n    }\n    repaint()\n    return this\n  }\n\n  this.blink = function (blink) {\n    if (blink) {\n      if (!ledBlinking) {\n        ledTimerId = setInterval(this.toggleLed, 1000)\n        ledBlinking = true\n      }\n    } else {\n      if (ledBlinking) {\n        clearInterval(ledTimerId)\n        ledBlinking = false\n        ledBuffer = ledBufferOff\n      }\n    }\n    return this\n  }\n\n  const repaint = function () {\n    if (!initialized) {\n      init()\n    }\n\n    mainCtx.save()\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    mainCtx.drawImage(ledBuffer, 0, 0)\n\n    mainCtx.restore()\n  }\n\n  repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Led);\n\n\n//# sourceURL=webpack://steelseries/./src/Led.js?");

/***/ }),

/***/ "./src/Level.js":
/*!**********************!*\
  !*** ./src/Level.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\nconst Level = function (canvas, parameters) {\n  parameters = parameters || {}\n  let size = undefined === parameters.size ? 0 : parameters.size\n  const decimalsVisible =\n    undefined === parameters.decimalsVisible\n      ? false\n      : parameters.decimalsVisible\n  const textOrientationFixed =\n    undefined === parameters.textOrientationFixed\n      ? false\n      : parameters.textOrientationFixed\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"BackgroundColor\"].DARK_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let pointerColor =\n    undefined === parameters.pointerColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].RED\n      : parameters.pointerColor\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  const rotateFace =\n    undefined === parameters.rotateFace ? false : parameters.rotateFace\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (size === 0) {\n    size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height)\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  let tween\n  let repainting = false\n\n  let value = 0\n  let stepValue = 0\n  let visibleValue = 0\n  const angleStep = _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"] / 360\n  let angle = this.value\n  const decimals = decimalsVisible ? 1 : 0\n\n  const imageWidth = size\n  const imageHeight = size\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight / 2\n\n  let initialized = false\n\n  // **************   Buffer creation  ********************\n  // Buffer for all static background painting code\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  // Buffer for pointer image painting code\n  const pointerBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let pointerContext = pointerBuffer.getContext('2d')\n\n  // Buffer for step pointer image painting code\n  const stepPointerBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let stepPointerContext = stepPointerBuffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  // **************   Image creation  ********************\n  const drawTickmarksImage = function (ctx) {\n    let stdFont\n    let smlFont\n    let i\n\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.save()\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.translate(centerX, centerY)\n\n    for (i = 0; i < 360; i++) {\n      ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n      ctx.lineWidth = 0.5\n      ctx.beginPath()\n      ctx.moveTo(imageWidth * 0.38, 0)\n      ctx.lineTo(imageWidth * 0.37, 0)\n      ctx.closePath()\n      ctx.stroke()\n\n      if (i % 5 === 0) {\n        ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n        ctx.lineWidth = 1\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.38, 0)\n        ctx.lineTo(imageWidth * 0.36, 0)\n        ctx.closePath()\n        ctx.stroke()\n      }\n\n      if (i % 45 === 0) {\n        ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n        ctx.lineWidth = 1\n        ctx.beginPath()\n        ctx.moveTo(imageWidth * 0.38, 0)\n        ctx.lineTo(imageWidth * 0.34, 0)\n        ctx.closePath()\n        ctx.stroke()\n      }\n\n      // Draw the labels\n      if (imageWidth > 300) {\n        stdFont = '14px ' + stdFont\n        smlFont = '12px ' + stdFont\n      }\n      if (imageWidth <= 300) {\n        stdFont = '12px ' + stdFont\n        smlFont = '10px ' + stdFont\n      }\n      if (imageWidth <= 200) {\n        stdFont = '10px ' + stdFont\n        smlFont = '8px ' + stdFont\n      }\n      if (imageWidth <= 100) {\n        stdFont = '8px ' + stdFont\n        smlFont = '6px ' + stdFont\n      }\n      ctx.save()\n      switch (i) {\n        case 0:\n          ctx.translate(imageWidth * 0.31, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] + _tools__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"])\n          ctx.font = stdFont\n          ctx.fillText('0\\u00B0', 0, 0, imageWidth)\n          ctx.rotate(-(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]) + _tools__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"])\n          ctx.translate(-imageWidth * 0.31, 0)\n\n          ctx.translate(imageWidth * 0.41, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] - _tools__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"])\n          ctx.font = smlFont\n          ctx.fillText('0%', 0, 0, imageWidth)\n          break\n        case 45:\n          ctx.translate(imageWidth * 0.31, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] + 0.25 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = stdFont\n          ctx.fillText('45\\u00B0', 0, 0, imageWidth)\n          ctx.rotate(-(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]) + 0.25 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.translate(-imageWidth * 0.31, 0)\n\n          ctx.translate(imageWidth * 0.31, imageWidth * 0.085)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] - 0.25 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = smlFont\n          ctx.fillText('100%', 0, 0, imageWidth)\n          break\n        case 90:\n          ctx.translate(imageWidth * 0.31, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"])\n          ctx.font = stdFont\n          ctx.fillText('90\\u00B0', 0, 0, imageWidth)\n          ctx.rotate(-(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]))\n          ctx.translate(-imageWidth * 0.31, 0)\n\n          ctx.translate(imageWidth * 0.21, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"])\n          ctx.font = smlFont\n          ctx.fillText('\\u221E', 0, 0, imageWidth)\n          break\n        case 135:\n          ctx.translate(imageWidth * 0.31, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] - 0.25 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = stdFont\n          ctx.fillText('45\\u00B0', 0, 0, imageWidth)\n          ctx.rotate(-(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]) - 0.25 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.translate(-imageWidth * 0.31, 0)\n\n          ctx.translate(imageWidth * 0.31, -imageWidth * 0.085)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] + 0.25 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = smlFont\n          ctx.fillText('100%', 0, 0, imageWidth)\n          break\n        case 180:\n          ctx.translate(imageWidth * 0.31, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] - _tools__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"])\n          ctx.font = stdFont\n          ctx.fillText('0\\u00B0', 0, 0, imageWidth)\n          ctx.rotate(-(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]) - _tools__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"])\n          ctx.translate(-imageWidth * 0.31, 0)\n\n          ctx.translate(imageWidth * 0.41, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] + _tools__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"])\n          ctx.font = smlFont\n          ctx.fillText('0%', 0, 0, imageWidth)\n          ctx.translate(-imageWidth * 0.41, 0)\n          break\n        case 225:\n          ctx.translate(imageWidth * 0.31, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] - 0.75 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = stdFont\n          ctx.fillText('45\\u00B0', 0, 0, imageWidth)\n          ctx.rotate(-(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]) - 0.75 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.translate(-imageWidth * 0.31, 0)\n\n          ctx.translate(imageWidth * 0.31, imageWidth * 0.085)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] + 0.75 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = smlFont\n          ctx.fillText('100%', 0, 0, imageWidth)\n          break\n        case 270:\n          ctx.translate(imageWidth * 0.31, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] - _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = stdFont\n          ctx.fillText('90\\u00B0', 0, 0, imageWidth)\n          ctx.rotate(-(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]) - _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.translate(-imageWidth * 0.31, 0)\n\n          ctx.translate(imageWidth * 0.21, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] - _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = smlFont\n          ctx.fillText('\\u221E', 0, 0, imageWidth)\n          break\n        case 315:\n          ctx.translate(imageWidth * 0.31, 0)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] - 1.25 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = stdFont\n          ctx.fillText('45\\u00B0', 0, 0, imageWidth)\n          ctx.rotate(-(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]) - 1.25 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.translate(-imageWidth * 0.31, 0)\n\n          ctx.translate(imageWidth * 0.31, -imageWidth * 0.085)\n          ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"] + 1.25 * _tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"])\n          ctx.font = smlFont\n          ctx.fillText('100%', 0, 0, imageWidth)\n          break\n      }\n      ctx.restore()\n\n      ctx.rotate(angleStep)\n    }\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  const drawMarkerImage = function (ctx) {\n    ctx.save()\n\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n\n    // FRAMELEFT\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.200934, imageHeight * 0.434579)\n    ctx.lineTo(imageWidth * 0.163551, imageHeight * 0.434579)\n    ctx.lineTo(imageWidth * 0.163551, imageHeight * 0.560747)\n    ctx.lineTo(imageWidth * 0.200934, imageHeight * 0.560747)\n    ctx.lineWidth = 1\n    ctx.lineCap = 'square'\n    ctx.lineJoin = 'miter'\n    ctx.stroke()\n\n    // TRIANGLELEFT\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.163551, imageHeight * 0.471962)\n    ctx.lineTo(imageWidth * 0.205607, imageHeight * 0.5)\n    ctx.lineTo(imageWidth * 0.163551, imageHeight * 0.523364)\n    ctx.lineTo(imageWidth * 0.163551, imageHeight * 0.471962)\n    ctx.closePath()\n    ctx.fill()\n\n    // FRAMERIGHT\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.799065, imageHeight * 0.434579)\n    ctx.lineTo(imageWidth * 0.836448, imageHeight * 0.434579)\n    ctx.lineTo(imageWidth * 0.836448, imageHeight * 0.560747)\n    ctx.lineTo(imageWidth * 0.799065, imageHeight * 0.560747)\n    ctx.lineWidth = 1\n    ctx.lineCap = 'square'\n    ctx.lineJoin = 'miter'\n    ctx.stroke()\n\n    // TRIANGLERIGHT\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.836448, imageHeight * 0.471962)\n    ctx.lineTo(imageWidth * 0.794392, imageHeight * 0.5)\n    ctx.lineTo(imageWidth * 0.836448, imageHeight * 0.523364)\n    ctx.lineTo(imageWidth * 0.836448, imageHeight * 0.471962)\n    ctx.closePath()\n    ctx.fill()\n\n    ctx.restore()\n  }\n\n  const drawPointerImage = function (ctx) {\n    ctx.save()\n\n    // POINTER_LEVEL\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.523364, imageHeight * 0.350467)\n    ctx.lineTo(imageWidth * 0.5, imageHeight * 0.130841)\n    ctx.lineTo(imageWidth * 0.476635, imageHeight * 0.350467)\n    ctx.bezierCurveTo(\n      imageWidth * 0.476635,\n      imageHeight * 0.350467,\n      imageWidth * 0.490654,\n      imageHeight * 0.345794,\n      imageWidth * 0.5,\n      imageHeight * 0.345794\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.509345,\n      imageHeight * 0.345794,\n      imageWidth * 0.523364,\n      imageHeight * 0.350467,\n      imageWidth * 0.523364,\n      imageHeight * 0.350467\n    )\n    ctx.closePath()\n    const POINTER_LEVEL_GRADIENT = ctx.createLinearGradient(\n      0,\n      0.154205 * imageHeight,\n      0,\n      0.350466 * imageHeight\n    )\n    const tmpDarkColor = pointerColor.dark\n    const tmpLightColor = pointerColor.light\n    tmpDarkColor.setAlpha(0.70588)\n    tmpLightColor.setAlpha(0.70588)\n    POINTER_LEVEL_GRADIENT.addColorStop(0, tmpDarkColor.getRgbaColor())\n    POINTER_LEVEL_GRADIENT.addColorStop(0.3, tmpLightColor.getRgbaColor())\n    POINTER_LEVEL_GRADIENT.addColorStop(0.59, tmpLightColor.getRgbaColor())\n    POINTER_LEVEL_GRADIENT.addColorStop(1, tmpDarkColor.getRgbaColor())\n    ctx.fillStyle = POINTER_LEVEL_GRADIENT\n    const strokeColor_POINTER_LEVEL = pointerColor.light.getRgbaColor()\n    ctx.lineWidth = 1\n    ctx.lineCap = 'square'\n    ctx.lineJoin = 'miter'\n    ctx.strokeStyle = strokeColor_POINTER_LEVEL\n    ctx.fill()\n    ctx.stroke()\n\n    tmpDarkColor.setAlpha(1)\n    tmpLightColor.setAlpha(1)\n\n    ctx.restore()\n  }\n\n  const drawStepPointerImage = function (ctx) {\n    ctx.save()\n\n    const tmpDarkColor = pointerColor.dark\n    const tmpLightColor = pointerColor.light\n    tmpDarkColor.setAlpha(0.70588)\n    tmpLightColor.setAlpha(0.70588)\n\n    // POINTER_LEVEL_LEFT\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.285046, imageHeight * 0.514018)\n    ctx.lineTo(imageWidth * 0.21028, imageHeight * 0.5)\n    ctx.lineTo(imageWidth * 0.285046, imageHeight * 0.481308)\n    ctx.bezierCurveTo(\n      imageWidth * 0.285046,\n      imageHeight * 0.481308,\n      imageWidth * 0.280373,\n      imageHeight * 0.490654,\n      imageWidth * 0.280373,\n      imageHeight * 0.495327\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.280373,\n      imageHeight * 0.504672,\n      imageWidth * 0.285046,\n      imageHeight * 0.514018,\n      imageWidth * 0.285046,\n      imageHeight * 0.514018\n    )\n    ctx.closePath()\n    const POINTER_LEVEL_LEFT_GRADIENT = ctx.createLinearGradient(\n      0.224299 * imageWidth,\n      0,\n      0.289719 * imageWidth,\n      0\n    )\n    POINTER_LEVEL_LEFT_GRADIENT.addColorStop(0, tmpDarkColor.getRgbaColor())\n    POINTER_LEVEL_LEFT_GRADIENT.addColorStop(0.3, tmpLightColor.getRgbaColor())\n    POINTER_LEVEL_LEFT_GRADIENT.addColorStop(\n      0.59,\n      tmpLightColor.getRgbaColor()\n    )\n    POINTER_LEVEL_LEFT_GRADIENT.addColorStop(1, tmpDarkColor.getRgbaColor())\n    ctx.fillStyle = POINTER_LEVEL_LEFT_GRADIENT\n    const strokeColor_POINTER_LEVEL_LEFT = pointerColor.light.getRgbaColor()\n    ctx.lineWidth = 1\n    ctx.lineCap = 'square'\n    ctx.lineJoin = 'miter'\n    ctx.strokeStyle = strokeColor_POINTER_LEVEL_LEFT\n    ctx.fill()\n    ctx.stroke()\n\n    // POINTER_LEVEL_RIGHT\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.714953, imageHeight * 0.514018)\n    ctx.lineTo(imageWidth * 0.789719, imageHeight * 0.5)\n    ctx.lineTo(imageWidth * 0.714953, imageHeight * 0.481308)\n    ctx.bezierCurveTo(\n      imageWidth * 0.714953,\n      imageHeight * 0.481308,\n      imageWidth * 0.719626,\n      imageHeight * 0.490654,\n      imageWidth * 0.719626,\n      imageHeight * 0.495327\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.719626,\n      imageHeight * 0.504672,\n      imageWidth * 0.714953,\n      imageHeight * 0.514018,\n      imageWidth * 0.714953,\n      imageHeight * 0.514018\n    )\n    ctx.closePath()\n    const POINTER_LEVEL_RIGHT_GRADIENT = ctx.createLinearGradient(\n      0.7757 * imageWidth,\n      0,\n      0.71028 * imageWidth,\n      0\n    )\n    POINTER_LEVEL_RIGHT_GRADIENT.addColorStop(0, tmpDarkColor.getRgbaColor())\n    POINTER_LEVEL_RIGHT_GRADIENT.addColorStop(\n      0.3,\n      tmpLightColor.getRgbaColor()\n    )\n    POINTER_LEVEL_RIGHT_GRADIENT.addColorStop(\n      0.59,\n      tmpLightColor.getRgbaColor()\n    )\n    POINTER_LEVEL_RIGHT_GRADIENT.addColorStop(1, tmpDarkColor.getRgbaColor())\n    ctx.fillStyle = POINTER_LEVEL_RIGHT_GRADIENT\n    const strokeColor_POINTER_LEVEL_RIGHT = pointerColor.light.getRgbaColor()\n    ctx.lineWidth = 1\n    ctx.lineCap = 'square'\n    ctx.lineJoin = 'miter'\n    ctx.strokeStyle = strokeColor_POINTER_LEVEL_RIGHT\n    ctx.fill()\n    ctx.stroke()\n\n    tmpDarkColor.setAlpha(1)\n    tmpLightColor.setAlpha(1)\n\n    ctx.restore()\n  }\n\n  // **************   Initialization  ********************\n  // Draw all static painting code to background\n  const init = function () {\n    initialized = true\n\n    if (frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        backgroundContext,\n        frameDesign,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    if (backgroundVisible) {\n      Object(_drawBackground__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n      drawTickmarksImage(backgroundContext)\n    }\n\n    drawMarkerImage(pointerContext)\n\n    drawPointerImage(pointerContext)\n\n    drawStepPointerImage(stepPointerContext)\n\n    if (foregroundVisible) {\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        false\n      )\n    }\n  }\n\n  const resetBuffers = function () {\n    backgroundBuffer.width = size\n    backgroundBuffer.height = size\n    backgroundContext = backgroundBuffer.getContext('2d')\n\n    // Buffer for pointer image painting code\n    pointerBuffer.width = size\n    pointerBuffer.height = size\n    pointerContext = pointerBuffer.getContext('2d')\n\n    // Buffer for step pointer image painting code\n    stepPointerBuffer.width = size\n    stepPointerBuffer.height = size\n    stepPointerContext = stepPointerBuffer.getContext('2d')\n\n    // Buffer for static foreground painting code\n    foregroundBuffer.width = size\n    foregroundBuffer.height = size\n    foregroundContext = foregroundBuffer.getContext('2d')\n  }\n\n  //* *********************************** Public methods **************************************\n  this.setValue = function (newValue) {\n    let targetValue\n    newValue = parseFloat(newValue)\n    targetValue = newValue < 0 ? 360 + newValue : newValue\n    targetValue = newValue > 359.9 ? newValue - 360 : newValue\n\n    if (value !== targetValue) {\n      value = targetValue\n      stepValue = 2 * ((Math.abs(value) * 10) % 10)\n      if (stepValue > 10) {\n        stepValue -= 20\n      }\n\n      if (value === 0) {\n        visibleValue = 90\n      }\n\n      if (value > 0 && value <= 90) {\n        visibleValue = 90 - value\n      }\n\n      if (value > 90 && value <= 180) {\n        visibleValue = value - 90\n      }\n\n      if (value > 180 && value <= 270) {\n        visibleValue = 270 - value\n      }\n\n      if (value > 270 && value <= 360) {\n        visibleValue = value - 270\n      }\n\n      if (value < 0 && value >= -90) {\n        visibleValue = 90 - Math.abs(value)\n      }\n\n      if (value < -90 && value >= -180) {\n        visibleValue = Math.abs(value) - 90\n      }\n\n      if (value < -180 && value >= -270) {\n        visibleValue = 270 - Math.abs(value)\n      }\n\n      if (value < -270 && value >= -360) {\n        visibleValue = Math.abs(value) - 270\n      }\n\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.setValueAnimated = function (newValue, callback) {\n    newValue = parseFloat(newValue)\n    if (360 - newValue + value < newValue - value) {\n      newValue = 360 - newValue\n    }\n    if (value !== newValue) {\n      if (undefined !== tween && tween.isPlaying) {\n        tween.stop()\n      }\n\n      // tween = new Tween(new Object(),'',Tween.elasticEaseOut,this.value,targetValue, 1);\n      tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({}, '', _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut, value, newValue, 1)\n      // tween = new Tween(new Object(), '', Tween.strongEaseInOut, this.value, targetValue, 1);\n\n      const gauge = this\n\n      tween.onMotionChanged = function (event) {\n        value = event.target._pos\n        stepValue = 2 * ((Math.abs(value) * 10) % 10)\n        if (stepValue > 10) {\n          stepValue -= 20\n        }\n\n        if (value === 0) {\n          visibleValue = 90\n        }\n\n        if (value > 0 && value <= 90) {\n          visibleValue = 90 - value\n        }\n\n        if (value > 90 && value <= 180) {\n          visibleValue = value - 90\n        }\n\n        if (value > 180 && value <= 270) {\n          visibleValue = 270 - value\n        }\n\n        if (value > 270 && value <= 360) {\n          visibleValue = value - 270\n        }\n\n        if (value < 0 && value >= -90) {\n          visibleValue = 90 - Math.abs(value)\n        }\n\n        if (value < -90 && value >= -180) {\n          visibleValue = Math.abs(value) - 90\n        }\n\n        if (value < -180 && value >= -270) {\n          visibleValue = 270 - Math.abs(value)\n        }\n\n        if (value < -270 && value >= -360) {\n          visibleValue = Math.abs(value) - 270\n        }\n\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tween.onMotionFinished = callback\n      }\n\n      tween.start()\n    }\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers()\n    frameDesign = newFrameDesign\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers()\n    backgroundColor = newBackgroundColor\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers()\n    foregroundType = newForegroundType\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setPointerColor = function (newPointerColor) {\n    resetBuffers()\n    pointerColor = newPointerColor\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init()\n    }\n\n    mainCtx.save()\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    angle = _tools__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"] + value * angleStep - _tools__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"]\n    if (rotateFace) {\n      mainCtx.translate(centerX, centerY)\n      mainCtx.rotate(-angle)\n      mainCtx.translate(-centerX, -centerY)\n    }\n    // Draw buffered image to visible canvas\n    if (frameVisible || backgroundVisible) {\n      mainCtx.drawImage(backgroundBuffer, 0, 0)\n    }\n\n    mainCtx.save()\n    // Define rotation center\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(angle)\n\n    // Draw pointer\n    mainCtx.translate(-centerX, -centerY)\n    mainCtx.drawImage(pointerBuffer, 0, 0)\n\n    mainCtx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n    mainCtx.textAlign = 'center'\n    mainCtx.textBaseline = 'middle'\n\n    if (textOrientationFixed) {\n      mainCtx.restore()\n      if (decimalsVisible) {\n        mainCtx.font = imageWidth * 0.1 + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_4__[\"stdFontName\"]\n      } else {\n        mainCtx.font = imageWidth * 0.15 + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_4__[\"stdFontName\"]\n      }\n      mainCtx.fillText(\n        visibleValue.toFixed(decimals) + '\\u00B0',\n        centerX,\n        centerY,\n        imageWidth * 0.35\n      )\n    } else {\n      if (decimalsVisible) {\n        mainCtx.font = imageWidth * 0.15 + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_4__[\"stdFontName\"]\n      } else {\n        mainCtx.font = imageWidth * 0.2 + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_4__[\"stdFontName\"]\n      }\n      mainCtx.fillText(\n        visibleValue.toFixed(decimals) + '\\u00B0',\n        centerX,\n        centerY,\n        imageWidth * 0.35\n      )\n      mainCtx.restore()\n    }\n\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(angle + stepValue * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"])\n    mainCtx.translate(-centerX, -centerY)\n    mainCtx.drawImage(stepPointerBuffer, 0, 0)\n    mainCtx.restore()\n\n    // Draw foreground\n    if (foregroundVisible) {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n\n    mainCtx.restore()\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Level);\n\n\n//# sourceURL=webpack://steelseries/./src/Level.js?");

/***/ }),

/***/ "./src/LightBulb.js":
/*!**************************!*\
  !*** ./src/LightBulb.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst Lightbulb = function (canvas, parameters) {\n  parameters = parameters || {}\n  // parameters\n  let width = undefined === parameters.width ? 0 : parameters.width\n  let height = undefined === parameters.height ? 0 : parameters.height\n  let glowColor =\n    undefined === parameters.glowColor ? '#ffff00' : parameters.glowColor\n  //\n  let initialized = false\n  let lightOn = false\n  let alpha = 1\n  const offBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const offCtx = offBuffer.getContext('2d')\n  const onBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const onCtx = onBuffer.getContext('2d')\n  const bulbBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const bulbCtx = bulbBuffer.getContext('2d')\n  // End of variables\n\n  // Get the canvas context and clear it\n  const mainCtx = document.getElementById(canvas).getContext('2d')\n\n  // Has a size been specified?\n  if (width === 0) {\n    width = mainCtx.canvas.width\n  }\n  if (height === 0) {\n    height = mainCtx.canvas.height\n  }\n\n  // Get the size\n  mainCtx.canvas.width = width\n  mainCtx.canvas.height = height\n  const size = width < height ? width : height\n  const imageWidth = size\n  const imageHeight = size\n\n  function drawToBuffer (width, height, drawFunction) {\n    const buffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n    buffer.width = width\n    buffer.height = height\n    drawFunction(buffer.getContext('2d'))\n    return buffer\n  }\n\n  const getColorValues = function (color) {\n    const lookupBuffer = drawToBuffer(1, 1, function (ctx) {\n      ctx.fillStyle = color\n      ctx.beginPath()\n      ctx.rect(0, 0, 1, 1)\n      ctx.fill()\n    })\n\n    const colorData = lookupBuffer.getContext('2d').getImageData(0, 0, 2, 2).data\n    return [colorData[0], colorData[1], colorData[2]]\n  }\n\n  offBuffer.width = imageWidth\n  offBuffer.height = imageHeight\n\n  onBuffer.width = imageWidth\n  onBuffer.height = imageHeight\n\n  bulbBuffer.width = imageWidth\n  bulbBuffer.height = imageHeight\n\n  const drawOff = function (ctx) {\n    ctx.save()\n\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0.289473 * imageWidth, 0.438596 * imageHeight)\n    ctx.bezierCurveTo(\n      0.289473 * imageWidth,\n      0.561403 * imageHeight,\n      0.385964 * imageWidth,\n      0.605263 * imageHeight,\n      0.385964 * imageWidth,\n      0.745614 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.385964 * imageWidth,\n      0.745614 * imageHeight,\n      0.587719 * imageWidth,\n      0.745614 * imageHeight,\n      0.587719 * imageWidth,\n      0.745614 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.587719 * imageWidth,\n      0.605263 * imageHeight,\n      0.692982 * imageWidth,\n      0.561403 * imageHeight,\n      0.692982 * imageWidth,\n      0.438596 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.692982 * imageWidth,\n      0.324561 * imageHeight,\n      0.605263 * imageWidth,\n      0.22807 * imageHeight,\n      0.5 * imageWidth,\n      0.22807 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.385964 * imageWidth,\n      0.22807 * imageHeight,\n      0.289473 * imageWidth,\n      0.324561 * imageHeight,\n      0.289473 * imageWidth,\n      0.438596 * imageHeight\n    )\n    ctx.closePath()\n    const glassOffFill = ctx.createLinearGradient(\n      0,\n      0.289473 * imageHeight,\n      0,\n      0.701754 * imageHeight\n    )\n    glassOffFill.addColorStop(0, '#eeeeee')\n    glassOffFill.addColorStop(0.99, '#999999')\n    glassOffFill.addColorStop(1, '#999999')\n    ctx.fillStyle = glassOffFill\n    ctx.fill()\n    ctx.lineCap = 'butt'\n    ctx.lineJoin = 'round'\n    ctx.lineWidth = 0.008771 * imageWidth\n    ctx.strokeStyle = '#cccccc'\n    ctx.stroke()\n    ctx.restore()\n    ctx.restore()\n  }\n\n  const drawOn = function (ctx) {\n    const data = getColorValues(glowColor)\n    const red = data[0]\n    const green = data[1]\n    const blue = data[2]\n    const hsl = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbToHsl\"])(red, green, blue)\n\n    ctx.save()\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0.289473 * imageWidth, 0.438596 * imageHeight)\n    ctx.bezierCurveTo(\n      0.289473 * imageWidth,\n      0.561403 * imageHeight,\n      0.385964 * imageWidth,\n      0.605263 * imageHeight,\n      0.385964 * imageWidth,\n      0.745614 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.385964 * imageWidth,\n      0.745614 * imageHeight,\n      0.587719 * imageWidth,\n      0.745614 * imageHeight,\n      0.587719 * imageWidth,\n      0.745614 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.587719 * imageWidth,\n      0.605263 * imageHeight,\n      0.692982 * imageWidth,\n      0.561403 * imageHeight,\n      0.692982 * imageWidth,\n      0.438596 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.692982 * imageWidth,\n      0.324561 * imageHeight,\n      0.605263 * imageWidth,\n      0.22807 * imageHeight,\n      0.5 * imageWidth,\n      0.22807 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.385964 * imageWidth,\n      0.22807 * imageHeight,\n      0.289473 * imageWidth,\n      0.324561 * imageHeight,\n      0.289473 * imageWidth,\n      0.438596 * imageHeight\n    )\n    ctx.closePath()\n\n    const glassOnFill = ctx.createLinearGradient(\n      0,\n      0.289473 * imageHeight,\n      0,\n      0.701754 * imageHeight\n    )\n\n    if (red === green && green === blue) {\n      glassOnFill.addColorStop(0, 'hsl(0, 60%, 0%)')\n      glassOnFill.addColorStop(1, 'hsl(0, 40%, 0%)')\n    } else {\n      glassOnFill.addColorStop(\n        0,\n        'hsl(' + hsl[0] * 255 + ', ' + hsl[1] * 100 + '%, 70%)'\n      )\n      glassOnFill.addColorStop(\n        1,\n        'hsl(' + hsl[0] * 255 + ', ' + hsl[1] * 100 + '%, 80%)'\n      )\n    }\n    ctx.fillStyle = glassOnFill\n\n    // sets shadow properties\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowBlur = 30\n    ctx.shadowColor = glowColor\n\n    ctx.fill()\n\n    ctx.lineCap = 'butt'\n    ctx.lineJoin = 'round'\n    ctx.lineWidth = 0.008771 * imageWidth\n    ctx.strokeStyle = 'rgba(' + red + ', ' + green + ', ' + blue + ', 0.4)'\n    ctx.stroke()\n\n    ctx.restore()\n\n    ctx.restore()\n  }\n\n  const drawBulb = function (ctx) {\n    ctx.save()\n\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0.350877 * imageWidth, 0.333333 * imageHeight)\n    ctx.bezierCurveTo(\n      0.350877 * imageWidth,\n      0.280701 * imageHeight,\n      0.41228 * imageWidth,\n      0.236842 * imageHeight,\n      0.5 * imageWidth,\n      0.236842 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.578947 * imageWidth,\n      0.236842 * imageHeight,\n      0.64035 * imageWidth,\n      0.280701 * imageHeight,\n      0.64035 * imageWidth,\n      0.333333 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.64035 * imageWidth,\n      0.385964 * imageHeight,\n      0.578947 * imageWidth,\n      0.429824 * imageHeight,\n      0.5 * imageWidth,\n      0.429824 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.41228 * imageWidth,\n      0.429824 * imageHeight,\n      0.350877 * imageWidth,\n      0.385964 * imageHeight,\n      0.350877 * imageWidth,\n      0.333333 * imageHeight\n    )\n    ctx.closePath()\n    const highlight = ctx.createLinearGradient(\n      0,\n      0.245614 * imageHeight,\n      0,\n      0.429824 * imageHeight\n    )\n    highlight.addColorStop(0, '#ffffff')\n    highlight.addColorStop(0.99, 'rgba(255, 255, 255, 0)')\n    highlight.addColorStop(1, 'rgba(255, 255, 255, 0)')\n    ctx.fillStyle = highlight\n    ctx.fill()\n    ctx.restore()\n\n    // winding\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0.377192 * imageWidth, 0.745614 * imageHeight)\n    ctx.bezierCurveTo(\n      0.377192 * imageWidth,\n      0.745614 * imageHeight,\n      0.429824 * imageWidth,\n      0.72807 * imageHeight,\n      0.491228 * imageWidth,\n      0.72807 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.561403 * imageWidth,\n      0.72807 * imageHeight,\n      0.605263 * imageWidth,\n      0.736842 * imageHeight,\n      0.605263 * imageWidth,\n      0.736842 * imageHeight\n    )\n    ctx.lineTo(0.605263 * imageWidth, 0.763157 * imageHeight)\n    ctx.lineTo(0.596491 * imageWidth, 0.780701 * imageHeight)\n    ctx.lineTo(0.605263 * imageWidth, 0.798245 * imageHeight)\n    ctx.lineTo(0.596491 * imageWidth, 0.815789 * imageHeight)\n    ctx.lineTo(0.605263 * imageWidth, 0.833333 * imageHeight)\n    ctx.lineTo(0.596491 * imageWidth, 0.850877 * imageHeight)\n    ctx.lineTo(0.605263 * imageWidth, 0.868421 * imageHeight)\n    ctx.lineTo(0.596491 * imageWidth, 0.885964 * imageHeight)\n    ctx.lineTo(0.605263 * imageWidth, 0.894736 * imageHeight)\n    ctx.bezierCurveTo(\n      0.605263 * imageWidth,\n      0.894736 * imageHeight,\n      0.570175 * imageWidth,\n      0.95614 * imageHeight,\n      0.535087 * imageWidth,\n      0.991228 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.526315 * imageWidth,\n      0.991228 * imageHeight,\n      0.517543 * imageWidth,\n      imageHeight,\n      0.5 * imageWidth,\n      imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.482456 * imageWidth,\n      imageHeight,\n      0.473684 * imageWidth,\n      imageHeight,\n      0.464912 * imageWidth,\n      0.991228 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.421052 * imageWidth,\n      0.947368 * imageHeight,\n      0.394736 * imageWidth,\n      0.903508 * imageHeight,\n      0.394736 * imageWidth,\n      0.903508 * imageHeight\n    )\n    ctx.lineTo(0.394736 * imageWidth, 0.894736 * imageHeight)\n    ctx.lineTo(0.385964 * imageWidth, 0.885964 * imageHeight)\n    ctx.lineTo(0.394736 * imageWidth, 0.868421 * imageHeight)\n    ctx.lineTo(0.385964 * imageWidth, 0.850877 * imageHeight)\n    ctx.lineTo(0.394736 * imageWidth, 0.833333 * imageHeight)\n    ctx.lineTo(0.385964 * imageWidth, 0.815789 * imageHeight)\n    ctx.lineTo(0.394736 * imageWidth, 0.798245 * imageHeight)\n    ctx.lineTo(0.377192 * imageWidth, 0.789473 * imageHeight)\n    ctx.lineTo(0.394736 * imageWidth, 0.771929 * imageHeight)\n    ctx.lineTo(0.377192 * imageWidth, 0.763157 * imageHeight)\n    ctx.lineTo(0.377192 * imageWidth, 0.745614 * imageHeight)\n    ctx.closePath()\n    const winding = ctx.createLinearGradient(\n      0.473684 * imageWidth,\n      0.72807 * imageHeight,\n      0.484702 * imageWidth,\n      0.938307 * imageHeight\n    )\n    winding.addColorStop(0, '#333333')\n    winding.addColorStop(0.04, '#d9dad6')\n    winding.addColorStop(0.19, '#e4e5e0')\n    winding.addColorStop(0.24, '#979996')\n    winding.addColorStop(0.31, '#fbffff')\n    winding.addColorStop(0.4, '#818584')\n    winding.addColorStop(0.48, '#f5f7f4')\n    winding.addColorStop(0.56, '#959794')\n    winding.addColorStop(0.64, '#f2f2f0')\n    winding.addColorStop(0.7, '#828783')\n    winding.addColorStop(0.78, '#fcfcfc')\n    winding.addColorStop(1, '#666666')\n    ctx.fillStyle = winding\n    ctx.fill()\n    ctx.restore()\n\n    // winding\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0.377192 * imageWidth, 0.745614 * imageHeight)\n    ctx.bezierCurveTo(\n      0.377192 * imageWidth,\n      0.745614 * imageHeight,\n      0.429824 * imageWidth,\n      0.72807 * imageHeight,\n      0.491228 * imageWidth,\n      0.72807 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.561403 * imageWidth,\n      0.72807 * imageHeight,\n      0.605263 * imageWidth,\n      0.736842 * imageHeight,\n      0.605263 * imageWidth,\n      0.736842 * imageHeight\n    )\n    ctx.lineTo(0.605263 * imageWidth, 0.763157 * imageHeight)\n    ctx.lineTo(0.596491 * imageWidth, 0.780701 * imageHeight)\n    ctx.lineTo(0.605263 * imageWidth, 0.798245 * imageHeight)\n    ctx.lineTo(0.596491 * imageWidth, 0.815789 * imageHeight)\n    ctx.lineTo(0.605263 * imageWidth, 0.833333 * imageHeight)\n    ctx.lineTo(0.596491 * imageWidth, 0.850877 * imageHeight)\n    ctx.lineTo(0.605263 * imageWidth, 0.868421 * imageHeight)\n    ctx.lineTo(0.596491 * imageWidth, 0.885964 * imageHeight)\n    ctx.lineTo(0.605263 * imageWidth, 0.894736 * imageHeight)\n    ctx.bezierCurveTo(\n      0.605263 * imageWidth,\n      0.894736 * imageHeight,\n      0.570175 * imageWidth,\n      0.95614 * imageHeight,\n      0.535087 * imageWidth,\n      0.991228 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.526315 * imageWidth,\n      0.991228 * imageHeight,\n      0.517543 * imageWidth,\n      imageHeight,\n      0.5 * imageWidth,\n      imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.482456 * imageWidth,\n      imageHeight,\n      0.473684 * imageWidth,\n      imageHeight,\n      0.464912 * imageWidth,\n      0.991228 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.421052 * imageWidth,\n      0.947368 * imageHeight,\n      0.394736 * imageWidth,\n      0.903508 * imageHeight,\n      0.394736 * imageWidth,\n      0.903508 * imageHeight\n    )\n    ctx.lineTo(0.394736 * imageWidth, 0.894736 * imageHeight)\n    ctx.lineTo(0.385964 * imageWidth, 0.885964 * imageHeight)\n    ctx.lineTo(0.394736 * imageWidth, 0.868421 * imageHeight)\n    ctx.lineTo(0.385964 * imageWidth, 0.850877 * imageHeight)\n    ctx.lineTo(0.394736 * imageWidth, 0.833333 * imageHeight)\n    ctx.lineTo(0.385964 * imageWidth, 0.815789 * imageHeight)\n    ctx.lineTo(0.394736 * imageWidth, 0.798245 * imageHeight)\n    ctx.lineTo(0.377192 * imageWidth, 0.789473 * imageHeight)\n    ctx.lineTo(0.394736 * imageWidth, 0.771929 * imageHeight)\n    ctx.lineTo(0.377192 * imageWidth, 0.763157 * imageHeight)\n    ctx.lineTo(0.377192 * imageWidth, 0.745614 * imageHeight)\n    ctx.closePath()\n    const winding1 = ctx.createLinearGradient(\n      0.377192 * imageWidth,\n      0.789473 * imageHeight,\n      0.605263 * imageWidth,\n      0.789473 * imageHeight\n    )\n    winding1.addColorStop(0, 'rgba(0, 0, 0, 0.4)')\n    winding1.addColorStop(0.15, 'rgba(0, 0, 0, 0.32)')\n    winding1.addColorStop(0.85, 'rgba(0, 0, 0, 0.33)')\n    winding1.addColorStop(1, 'rgba(0, 0, 0, 0.4)')\n    ctx.fillStyle = winding1\n    ctx.fill()\n    ctx.restore()\n\n    // contact plate\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0.421052 * imageWidth, 0.947368 * imageHeight)\n    ctx.bezierCurveTo(\n      0.438596 * imageWidth,\n      0.95614 * imageHeight,\n      0.447368 * imageWidth,\n      0.973684 * imageHeight,\n      0.464912 * imageWidth,\n      0.991228 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.473684 * imageWidth,\n      imageHeight,\n      0.482456 * imageWidth,\n      imageHeight,\n      0.5 * imageWidth,\n      imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.517543 * imageWidth,\n      imageHeight,\n      0.526315 * imageWidth,\n      0.991228 * imageHeight,\n      0.535087 * imageWidth,\n      0.991228 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.543859 * imageWidth,\n      0.982456 * imageHeight,\n      0.561403 * imageWidth,\n      0.95614 * imageHeight,\n      0.578947 * imageWidth,\n      0.947368 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.552631 * imageWidth,\n      0.938596 * imageHeight,\n      0.526315 * imageWidth,\n      0.938596 * imageHeight,\n      0.5 * imageWidth,\n      0.938596 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.473684 * imageWidth,\n      0.938596 * imageHeight,\n      0.447368 * imageWidth,\n      0.938596 * imageHeight,\n      0.421052 * imageWidth,\n      0.947368 * imageHeight\n    )\n    ctx.closePath()\n    const contactPlate = ctx.createLinearGradient(\n      0,\n      0.938596 * imageHeight,\n      0,\n      imageHeight\n    )\n    contactPlate.addColorStop(0, '#050a06')\n    contactPlate.addColorStop(0.61, '#070602')\n    contactPlate.addColorStop(0.71, '#999288')\n    contactPlate.addColorStop(0.83, '#010101')\n    contactPlate.addColorStop(1, '#000000')\n    ctx.fillStyle = contactPlate\n    ctx.fill()\n    ctx.restore()\n    ctx.restore()\n  }\n\n  const clearCanvas = function (ctx) {\n    // Store the current transformation matrix\n    ctx.save()\n\n    // Use the identity matrix while clearing the canvas\n    ctx.setTransform(1, 0, 0, 1, 0, 0)\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n\n    // Restore the transform\n    ctx.restore()\n  }\n\n  const init = function () {\n    initialized = true\n    drawOff(offCtx)\n    drawOn(onCtx)\n    drawBulb(bulbCtx)\n  }\n\n  // **************   P U B L I C   M E T H O D S   ********************************\n  this.setOn = function (on) {\n    lightOn = !!on\n    this.repaint()\n    return this\n  }\n\n  this.isOn = function () {\n    return lightOn\n  }\n\n  this.setAlpha = function (a) {\n    alpha = a\n    this.repaint()\n    return this\n  }\n\n  this.getAlpha = function () {\n    return alpha\n  }\n\n  this.setGlowColor = function (color) {\n    glowColor = color\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.getGlowColor = function () {\n    return glowColor\n  }\n\n  // Component visualization\n  this.repaint = function () {\n    if (!initialized) {\n      init()\n    }\n\n    clearCanvas(mainCtx)\n\n    mainCtx.save()\n\n    mainCtx.drawImage(offBuffer, 0, 0)\n\n    mainCtx.globalAlpha = alpha\n    if (lightOn) {\n      mainCtx.drawImage(onBuffer, 0, 0)\n    }\n    mainCtx.globalAlpha = 1\n    mainCtx.drawImage(bulbBuffer, 0, 0)\n    mainCtx.restore()\n  }\n\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Lightbulb);\n\n\n//# sourceURL=webpack://steelseries/./src/LightBulb.js?");

/***/ }),

/***/ "./src/Linear.js":
/*!***********************!*\
  !*** ./src/Linear.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawLinearBackgroundImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawLinearBackgroundImage */ \"./src/drawLinearBackgroundImage.js\");\n/* harmony import */ var _drawLinearForegroundImage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawLinearForegroundImage */ \"./src/drawLinearForegroundImage.js\");\n/* harmony import */ var _drawLinearFrameImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawLinearFrameImage */ \"./src/drawLinearFrameImage.js\");\n/* harmony import */ var _createLedImage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createLedImage */ \"./src/createLedImage.js\");\n/* harmony import */ var _createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createLcdBackgroundImage */ \"./src/createLcdBackgroundImage.js\");\n/* harmony import */ var _createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createMeasuredValueImage */ \"./src/createMeasuredValueImage.js\");\n/* harmony import */ var _drawTitleImage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./drawTitleImage */ \"./src/drawTitleImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst Linear = function (canvas, parameters) {\n  parameters = parameters || {}\n  let gaugeType =\n    undefined === parameters.gaugeType ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"GaugeType\"].TYPE1 : parameters.gaugeType\n  let width = undefined === parameters.width ? 0 : parameters.width\n  let height = undefined === parameters.height ? 0 : parameters.height\n  let minValue = undefined === parameters.minValue ? 0 : parameters.minValue\n  let maxValue =\n    undefined === parameters.maxValue ? minValue + 100 : parameters.maxValue\n  const niceScale =\n    undefined === parameters.niceScale ? true : parameters.niceScale\n  let threshold =\n    undefined === parameters.threshold\n      ? (maxValue - minValue) / 2 + minValue\n      : parameters.threshold\n  let titleString =\n    undefined === parameters.titleString ? '' : parameters.titleString\n  let unitString =\n    undefined === parameters.unitString ? '' : parameters.unitString\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].DARK_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let valueColor =\n    undefined === parameters.valueColor ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].RED : parameters.valueColor\n  let lcdColor =\n    undefined === parameters.lcdColor ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LcdColor\"].STANDARD : parameters.lcdColor\n  const lcdVisible =\n    undefined === parameters.lcdVisible ? true : parameters.lcdVisible\n  let lcdDecimals =\n    undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals\n  const digitalFont =\n    undefined === parameters.digitalFont ? false : parameters.digitalFont\n  let ledColor =\n    undefined === parameters.ledColor ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LedColor\"].RED_LED : parameters.ledColor\n  let ledVisible =\n    undefined === parameters.ledVisible ? true : parameters.ledVisible\n  let thresholdVisible =\n    undefined === parameters.thresholdVisible\n      ? true\n      : parameters.thresholdVisible\n  let thresholdRising =\n    undefined === parameters.thresholdRising\n      ? true\n      : parameters.thresholdRising\n  let minMeasuredValueVisible =\n    undefined === parameters.minMeasuredValueVisible\n      ? false\n      : parameters.minMeasuredValueVisible\n  let maxMeasuredValueVisible =\n    undefined === parameters.maxMeasuredValueVisible\n      ? false\n      : parameters.maxMeasuredValueVisible\n  const labelNumberFormat =\n    undefined === parameters.labelNumberFormat\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LabelNumberFormat\"].STANDARD\n      : parameters.labelNumberFormat\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  const playAlarm =\n    undefined === parameters.playAlarm ? false : parameters.playAlarm\n  const alarmSound =\n    undefined === parameters.alarmSound ? false : parameters.alarmSound\n  const fullScaleDeflectionTime =\n    undefined === parameters.fullScaleDeflectionTime\n      ? 2.5\n      : parameters.fullScaleDeflectionTime\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (width === 0) {\n    width = mainCtx.canvas.width\n  }\n  if (height === 0) {\n    height = mainCtx.canvas.height\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = width\n  mainCtx.canvas.height = height\n\n  const imageWidth = width\n  const imageHeight = height\n  let audioElement\n\n  // Create audio tag for alarm sound\n  if (playAlarm && alarmSound !== false) {\n    audioElement = _tools__WEBPACK_IMPORTED_MODULE_8__[\"doc\"].createElement('audio')\n    audioElement.setAttribute('src', alarmSound)\n    // audioElement.setAttribute('src', 'js/alarm.mp3');\n    audioElement.setAttribute('preload', 'auto')\n  }\n\n  const self = this\n  let value = minValue\n\n  // Properties\n  let minMeasuredValue = maxValue\n  let maxMeasuredValue = minValue\n\n  // Check gaugeType is 1 or 2\n  if (gaugeType.type !== 'type1' && gaugeType.type !== 'type2') {\n    gaugeType = _definitions__WEBPACK_IMPORTED_MODULE_9__[\"GaugeType\"].TYPE1\n  }\n\n  let tween\n  let ledBlinking = false\n  let repainting = false\n\n  let ledTimerId = 0\n\n  const vertical = width <= height\n\n  // Constants\n  let ledPosX\n  let ledPosY\n  const ledSize = Math.round((vertical ? height : width) * 0.05)\n  const minMaxIndSize = Math.round((vertical ? width : height) * 0.05)\n  let stdFont\n  let lcdFont\n\n  // Misc\n  if (vertical) {\n    ledPosX = imageWidth / 2 - ledSize / 2\n    ledPosY = (gaugeType.type === 'type1' ? 0.053 : 0.038) * imageHeight\n    stdFont = Math.floor(imageHeight / 22) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n    lcdFont = Math.floor(imageHeight / 22) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"lcdFontName\"]\n  } else {\n    ledPosX = 0.89 * imageWidth\n    ledPosY = imageHeight / 2 - ledSize / 2\n    stdFont = Math.floor(imageHeight / 10) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n    lcdFont = Math.floor(imageHeight / 10) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"lcdFontName\"]\n  }\n\n  let initialized = false\n\n  // Tickmark specific private variables\n  let niceMinValue = minValue\n  let niceMaxValue = maxValue\n  let niceRange = maxValue - minValue\n  let minorTickSpacing = 0\n  let majorTickSpacing = 0\n  const maxNoOfMinorTicks = 10\n  const maxNoOfMajorTicks = 10\n\n  // Method to calculate nice values for min, max and range for the tickmarks\n  const calculate = function calculate () {\n    if (niceScale) {\n      niceRange = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"calcNiceNumber\"])(maxValue - minValue, false)\n      majorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"calcNiceNumber\"])(\n        niceRange / (maxNoOfMajorTicks - 1),\n        true\n      )\n      niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing\n      niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing\n      minorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"calcNiceNumber\"])(\n        majorTickSpacing / (maxNoOfMinorTicks - 1),\n        true\n      )\n      minValue = niceMinValue\n      maxValue = niceMaxValue\n    } else {\n      niceRange = maxValue - minValue\n      niceMinValue = minValue\n      niceMaxValue = maxValue\n      minorTickSpacing = 1\n      majorTickSpacing = 10\n    }\n    // Make sure values are still in range\n    value = value < minValue ? minValue : value > maxValue ? maxValue : value\n    minMeasuredValue =\n      minMeasuredValue < minValue\n        ? minValue\n        : minMeasuredValue > maxValue\n          ? maxValue\n          : minMeasuredValue\n    maxMeasuredValue =\n      maxMeasuredValue < minValue\n        ? minValue\n        : maxMeasuredValue > maxValue\n          ? maxValue\n          : maxMeasuredValue\n    threshold =\n      threshold < minValue\n        ? minValue\n        : threshold > maxValue\n          ? maxValue\n          : threshold\n  }\n\n  // **************   Buffer creation  ********************\n  // Buffer for the frame\n  const frameBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(width, height)\n  let frameContext = frameBuffer.getContext('2d')\n\n  // Buffer for the background\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(width, height)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  let lcdBuffer\n\n  // Buffer for led on painting code\n  const ledBufferOn = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(ledSize, ledSize)\n  let ledContextOn = ledBufferOn.getContext('2d')\n\n  // Buffer for led off painting code\n  const ledBufferOff = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(ledSize, ledSize)\n  let ledContextOff = ledBufferOff.getContext('2d')\n\n  // Buffer for current led painting code\n  let ledBuffer = ledBufferOff\n\n  // Buffer for the minMeasuredValue indicator\n  const minMeasuredValueBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(minMaxIndSize, minMaxIndSize)\n  const minMeasuredValueCtx = minMeasuredValueBuffer.getContext('2d')\n\n  // Buffer for the maxMeasuredValue indicator\n  const maxMeasuredValueBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(minMaxIndSize, minMaxIndSize)\n  const maxMeasuredValueCtx = maxMeasuredValueBuffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(width, height)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  // **************   Image creation  ********************\n  const drawLcdText = function (ctx, value, vertical) {\n    ctx.save()\n    ctx.textAlign = 'right'\n    ctx.textBaseline = 'middle'\n    ctx.strokeStyle = lcdColor.textColor\n    ctx.fillStyle = lcdColor.textColor\n\n    if (\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LcdColor\"].STANDARD ||\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LcdColor\"].STANDARD_GREEN\n    ) {\n      ctx.shadowColor = 'gray'\n      if (vertical) {\n        ctx.shadowOffsetX = imageHeight * 0.003\n        ctx.shadowOffsetY = imageHeight * 0.003\n        ctx.shadowBlur = imageHeight * 0.004\n      } else {\n        ctx.shadowOffsetX = imageHeight * 0.007\n        ctx.shadowOffsetY = imageHeight * 0.007\n        ctx.shadowBlur = imageHeight * 0.009\n      }\n    }\n\n    let lcdTextX\n    let lcdTextY\n    let lcdTextWidth\n\n    if (digitalFont) {\n      ctx.font = lcdFont\n    } else {\n      ctx.font = stdFont\n    }\n\n    if (vertical) {\n      lcdTextX =\n        (imageWidth - imageWidth * 0.571428) / 2 + imageWidth * 0.571428 - 2\n      lcdTextY = imageHeight * 0.88 + 1 + (imageHeight * 0.055 - 2) / 2\n      lcdTextWidth = imageWidth * 0.7 - 2\n    } else {\n      lcdTextX = imageWidth * 0.695 + imageWidth * 0.18 - 2\n      lcdTextY = imageHeight * 0.22 + 1 + (imageHeight * 0.15 - 2) / 2\n      lcdTextWidth = imageHeight * 0.22 - 2\n    }\n\n    ctx.fillText(value.toFixed(lcdDecimals), lcdTextX, lcdTextY, lcdTextWidth)\n\n    ctx.restore()\n  }\n\n  const createThresholdImage = function (vertical) {\n    const thresholdBuffer = _tools__WEBPACK_IMPORTED_MODULE_8__[\"doc\"].createElement('canvas')\n    const thresholdCtx = thresholdBuffer.getContext('2d')\n    thresholdBuffer.height = thresholdBuffer.width = minMaxIndSize\n\n    thresholdCtx.save()\n    const gradThreshold = thresholdCtx.createLinearGradient(\n      0,\n      0.1,\n      0,\n      thresholdBuffer.height * 0.9\n    )\n    gradThreshold.addColorStop(0, '#520000')\n    gradThreshold.addColorStop(0.3, '#fc1d00')\n    gradThreshold.addColorStop(0.59, '#fc1d00')\n    gradThreshold.addColorStop(1, '#520000')\n    thresholdCtx.fillStyle = gradThreshold\n\n    if (vertical) {\n      thresholdCtx.beginPath()\n      thresholdCtx.moveTo(0.1, thresholdBuffer.height * 0.5)\n      thresholdCtx.lineTo(thresholdBuffer.width * 0.9, 0.1)\n      thresholdCtx.lineTo(\n        thresholdBuffer.width * 0.9,\n        thresholdBuffer.height * 0.9\n      )\n      thresholdCtx.closePath()\n    } else {\n      thresholdCtx.beginPath()\n      thresholdCtx.moveTo(0.1, 0.1)\n      thresholdCtx.lineTo(thresholdBuffer.width * 0.9, 0.1)\n      thresholdCtx.lineTo(\n        thresholdBuffer.width * 0.5,\n        thresholdBuffer.height * 0.9\n      )\n      thresholdCtx.closePath()\n    }\n\n    thresholdCtx.fill()\n    thresholdCtx.strokeStyle = '#FFFFFF'\n    thresholdCtx.stroke()\n\n    thresholdCtx.restore()\n\n    return thresholdBuffer\n  }\n\n  const drawTickmarksImage = function (ctx, labelNumberFormat, vertical) {\n    backgroundColor.labelColor.setAlpha(1)\n    ctx.save()\n    ctx.textBaseline = 'middle'\n    const TEXT_WIDTH = imageWidth * 0.1\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n\n    let valueCounter = minValue\n    let majorTickCounter = maxNoOfMinorTicks - 1\n    let tickCounter\n    let currentPos\n    let scaleBoundsX\n    let scaleBoundsY\n    let scaleBoundsW\n    let scaleBoundsH\n    let tickSpaceScaling = 1\n\n    let minorTickStart\n    let minorTickStop\n    let mediumTickStart\n    let mediumTickStop\n    let majorTickStart\n    let majorTickStop\n    if (vertical) {\n      minorTickStart = 0.34 * imageWidth\n      minorTickStop = 0.36 * imageWidth\n      mediumTickStart = 0.33 * imageWidth\n      mediumTickStop = 0.36 * imageWidth\n      majorTickStart = 0.32 * imageWidth\n      majorTickStop = 0.36 * imageWidth\n      ctx.textAlign = 'right'\n      scaleBoundsX = 0\n      scaleBoundsY = imageHeight * 0.12864\n      scaleBoundsW = 0\n      if (gaugeType.type === 'type1') {\n        scaleBoundsH = imageHeight * 0.856796 - imageHeight * 0.12864\n      } else {\n        scaleBoundsH = imageHeight * 0.7475 - imageHeight * 0.12864\n      }\n      tickSpaceScaling = scaleBoundsH / (maxValue - minValue)\n    } else {\n      minorTickStart = 0.65 * imageHeight\n      minorTickStop = 0.63 * imageHeight\n      mediumTickStart = 0.66 * imageHeight\n      mediumTickStop = 0.63 * imageHeight\n      majorTickStart = 0.67 * imageHeight\n      majorTickStop = 0.63 * imageHeight\n      ctx.textAlign = 'center'\n      scaleBoundsY = 0\n      if (gaugeType.type === 'type1') {\n        scaleBoundsX = imageWidth * 0.142857\n        scaleBoundsW = imageWidth * 0.871012 - scaleBoundsX\n      } else {\n        scaleBoundsX = imageWidth * 0.19857\n        scaleBoundsW = imageWidth * 0.82 - scaleBoundsX\n      }\n      scaleBoundsH = 0\n      tickSpaceScaling = scaleBoundsW / (maxValue - minValue)\n    }\n\n    let labelCounter\n    for (\n      labelCounter = minValue, tickCounter = 0;\n      labelCounter <= maxValue;\n      labelCounter += minorTickSpacing, tickCounter += minorTickSpacing\n    ) {\n      // Calculate the bounds of the scaling\n      if (vertical) {\n        currentPos =\n          scaleBoundsY + scaleBoundsH - tickCounter * tickSpaceScaling\n      } else {\n        currentPos = scaleBoundsX + tickCounter * tickSpaceScaling\n      }\n\n      majorTickCounter++\n\n      // Draw tickmark every major tickmark spacing\n      if (majorTickCounter === maxNoOfMinorTicks) {\n        // Draw the major tickmarks\n        ctx.lineWidth = 1.5\n        drawLinearTicks(\n          ctx,\n          majorTickStart,\n          majorTickStop,\n          currentPos,\n          vertical\n        )\n\n        // Draw the standard tickmark labels\n        if (vertical) {\n          // Vertical orientation\n          switch (labelNumberFormat.format) {\n            case 'fractional':\n              ctx.fillText(\n                valueCounter.toFixed(2),\n                imageWidth * 0.28,\n                currentPos,\n                TEXT_WIDTH\n              )\n              break\n\n            case 'scientific':\n              ctx.fillText(\n                valueCounter.toPrecision(2),\n                imageWidth * 0.28,\n                currentPos,\n                TEXT_WIDTH\n              )\n              break\n\n            case 'standard':\n            /* falls through */\n            default:\n              ctx.fillText(\n                valueCounter.toFixed(0),\n                imageWidth * 0.28,\n                currentPos,\n                TEXT_WIDTH\n              )\n              break\n          }\n        } else {\n          // Horizontal orientation\n          switch (labelNumberFormat.format) {\n            case 'fractional':\n              ctx.fillText(\n                valueCounter.toFixed(2),\n                currentPos,\n                imageHeight * 0.73,\n                TEXT_WIDTH\n              )\n              break\n\n            case 'scientific':\n              ctx.fillText(\n                valueCounter.toPrecision(2),\n                currentPos,\n                imageHeight * 0.73,\n                TEXT_WIDTH\n              )\n              break\n\n            case 'standard':\n            /* falls through */\n            default:\n              ctx.fillText(\n                valueCounter.toFixed(0),\n                currentPos,\n                imageHeight * 0.73,\n                TEXT_WIDTH\n              )\n              break\n          }\n        }\n\n        valueCounter += majorTickSpacing\n        majorTickCounter = 0\n        continue\n      }\n\n      // Draw tickmark every minor tickmark spacing\n      if (\n        maxNoOfMinorTicks % 2 === 0 &&\n        majorTickCounter === maxNoOfMinorTicks / 2\n      ) {\n        ctx.lineWidth = 1\n        drawLinearTicks(\n          ctx,\n          mediumTickStart,\n          mediumTickStop,\n          currentPos,\n          vertical\n        )\n      } else {\n        ctx.lineWidth = 0.5\n        drawLinearTicks(\n          ctx,\n          minorTickStart,\n          minorTickStop,\n          currentPos,\n          vertical\n        )\n      }\n    }\n\n    ctx.restore()\n  }\n\n  const drawLinearTicks = function (\n    ctx,\n    tickStart,\n    tickStop,\n    currentPos,\n    vertical\n  ) {\n    if (vertical) {\n      // Vertical orientation\n      ctx.beginPath()\n      ctx.moveTo(tickStart, currentPos)\n      ctx.lineTo(tickStop, currentPos)\n      ctx.closePath()\n      ctx.stroke()\n    } else {\n      // Horizontal orientation\n      ctx.beginPath()\n      ctx.moveTo(currentPos, tickStart)\n      ctx.lineTo(currentPos, tickStop)\n      ctx.closePath()\n      ctx.stroke()\n    }\n  }\n\n  // **************   Initialization  ********************\n  const init = function (parameters) {\n    parameters = parameters || {}\n    const drawFrame2 =\n      undefined === parameters.frame ? false : parameters.frame\n    const drawBackground2 =\n      undefined === parameters.background ? false : parameters.background\n    const drawLed = undefined === parameters.led ? false : parameters.led\n    const drawForeground2 =\n      undefined === parameters.foreground ? false : parameters.foreground\n\n    let yOffset\n    let yRange\n    let valuePos\n\n    initialized = true\n\n    // Calculate the current min and max values and the range\n    calculate()\n\n    // Create frame in frame buffer (backgroundBuffer)\n    if (drawFrame2 && frameVisible) {\n      Object(_drawLinearFrameImage__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        frameContext,\n        frameDesign,\n        imageWidth,\n        imageHeight,\n        vertical\n      )\n    }\n\n    // Create background in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      Object(_drawLinearBackgroundImage__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        imageWidth,\n        imageHeight,\n        vertical\n      )\n    }\n\n    // draw Thermometer outline\n    if (drawBackground2 && gaugeType.type === 'type2') {\n      drawBackgroundImage(backgroundContext)\n    }\n\n    if (drawLed) {\n      if (vertical) {\n        // Draw LED ON in ledBuffer_ON\n        ledContextOn.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ledSize, 1, ledColor), 0, 0)\n\n        // Draw LED ON in ledBuffer_OFF\n        ledContextOff.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ledSize, 0, ledColor), 0, 0)\n      } else {\n        // Draw LED ON in ledBuffer_ON\n        ledContextOn.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ledSize, 1, ledColor), 0, 0)\n\n        // Draw LED ON in ledBuffer_OFF\n        ledContextOff.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ledSize, 0, ledColor), 0, 0)\n      }\n    }\n\n    // Draw min measured value indicator in minMeasuredValueBuffer\n    if (minMeasuredValueVisible) {\n      if (vertical) {\n        minMeasuredValueCtx.drawImage(\n          Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n            minMaxIndSize,\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].BLUE.dark.getRgbaColor(),\n            false,\n            vertical\n          ),\n          0,\n          0\n        )\n      } else {\n        minMeasuredValueCtx.drawImage(\n          Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n            minMaxIndSize,\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].BLUE.dark.getRgbaColor(),\n            false,\n            vertical\n          ),\n          0,\n          0\n        )\n      }\n    }\n\n    // Draw max measured value indicator in maxMeasuredValueBuffer\n    if (maxMeasuredValueVisible) {\n      if (vertical) {\n        maxMeasuredValueCtx.drawImage(\n          Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n            minMaxIndSize,\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].RED.medium.getRgbaColor(),\n            false,\n            vertical\n          ),\n          0,\n          0\n        )\n      } else {\n        maxMeasuredValueCtx.drawImage(\n          Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n            minMaxIndSize,\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].RED.medium.getRgbaColor(),\n            false,\n            vertical\n          ),\n          0,\n          0\n        )\n      }\n    }\n\n    // Create alignment posts in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      // Create tickmarks in background buffer (backgroundBuffer)\n      drawTickmarksImage(backgroundContext, labelNumberFormat, vertical)\n\n      // Create title in background buffer (backgroundBuffer)\n      if (vertical) {\n        Object(_drawTitleImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n          backgroundContext,\n          imageWidth,\n          imageHeight,\n          titleString,\n          unitString,\n          backgroundColor,\n          vertical,\n          null,\n          lcdVisible,\n          gaugeType\n        )\n      } else {\n        Object(_drawTitleImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n          backgroundContext,\n          imageWidth,\n          imageHeight,\n          titleString,\n          unitString,\n          backgroundColor,\n          vertical,\n          null,\n          lcdVisible,\n          gaugeType\n        )\n      }\n    }\n\n    // Draw threshold image to background context\n    if (drawBackground2 && thresholdVisible) {\n      backgroundContext.save()\n      if (vertical) {\n        // Vertical orientation\n        yOffset = gaugeType.type === 'type1' ? 0.856796 : 0.7475\n        yRange = yOffset - 0.12864\n        valuePos =\n          imageHeight * yOffset -\n          (imageHeight * yRange * (threshold - minValue)) /\n            (maxValue - minValue)\n        backgroundContext.translate(\n          imageWidth * 0.365,\n          valuePos - minMaxIndSize / 2\n        )\n      } else {\n        // Horizontal orientation\n        yOffset = gaugeType.type === 'type1' ? 0.871012 : 0.82\n        yRange = yOffset - (gaugeType.type === 'type1' ? 0.142857 : 0.19857)\n        valuePos =\n          (imageWidth * yRange * (threshold - minValue)) /\n          (maxValue - minValue)\n        backgroundContext.translate(\n          imageWidth * (gaugeType.type === 'type1' ? 0.142857 : 0.19857) -\n            minMaxIndSize / 2 +\n            valuePos,\n          imageHeight * 0.58\n        )\n      }\n      backgroundContext.drawImage(createThresholdImage(vertical), 0, 0)\n      backgroundContext.restore()\n    }\n\n    // Create lcd background if selected in background buffer (backgroundBuffer)\n    if (drawBackground2 && lcdVisible) {\n      if (vertical) {\n        lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n          imageWidth * 0.571428,\n          imageHeight * 0.055,\n          lcdColor\n        )\n        backgroundContext.drawImage(\n          lcdBuffer,\n          (imageWidth - imageWidth * 0.571428) / 2,\n          imageHeight * 0.88\n        )\n      } else {\n        lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n          imageWidth * 0.18,\n          imageHeight * 0.15,\n          lcdColor\n        )\n        backgroundContext.drawImage(\n          lcdBuffer,\n          imageWidth * 0.695,\n          imageHeight * 0.22\n        )\n      }\n    }\n\n    // add thermometer stem foreground\n    if (drawForeground2 && gaugeType.type === 'type2') {\n      drawForegroundImage(foregroundContext)\n    }\n\n    // Create foreground in foreground buffer (foregroundBuffer)\n    if (drawForeground2 && foregroundVisible) {\n      Object(_drawLinearForegroundImage__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        foregroundContext,\n        imageWidth,\n        imageHeight,\n        vertical,\n        false\n      )\n    }\n  }\n\n  const resetBuffers = function (buffers) {\n    buffers = buffers || {}\n    const resetFrame = undefined === buffers.frame ? false : buffers.frame\n    const resetBackground =\n      undefined === buffers.background ? false : buffers.background\n    const resetLed = undefined === buffers.led ? false : buffers.led\n    const resetForeground =\n      undefined === buffers.foreground ? false : buffers.foreground\n\n    if (resetFrame) {\n      frameBuffer.width = width\n      frameBuffer.height = height\n      frameContext = frameBuffer.getContext('2d')\n    }\n\n    if (resetBackground) {\n      backgroundBuffer.width = width\n      backgroundBuffer.height = height\n      backgroundContext = backgroundBuffer.getContext('2d')\n    }\n\n    if (resetLed) {\n      ledBufferOn.width = Math.ceil(width * 0.093457)\n      ledBufferOn.height = Math.ceil(height * 0.093457)\n      ledContextOn = ledBufferOn.getContext('2d')\n\n      ledBufferOff.width = Math.ceil(width * 0.093457)\n      ledBufferOff.height = Math.ceil(height * 0.093457)\n      ledContextOff = ledBufferOff.getContext('2d')\n\n      // Buffer for current led painting code\n      ledBuffer = ledBufferOff\n    }\n\n    if (resetForeground) {\n      foregroundBuffer.width = width\n      foregroundBuffer.height = height\n      foregroundContext = foregroundBuffer.getContext('2d')\n    }\n  }\n\n  const blink = function (blinking) {\n    if (blinking) {\n      ledTimerId = setInterval(toggleAndRepaintLed, 1000)\n    } else {\n      clearInterval(ledTimerId)\n      ledBuffer = ledBufferOff\n    }\n  }\n\n  const toggleAndRepaintLed = function () {\n    if (ledVisible) {\n      if (ledBuffer === ledBufferOn) {\n        ledBuffer = ledBufferOff\n      } else {\n        ledBuffer = ledBufferOn\n      }\n      if (!repainting) {\n        repainting = true\n        Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(self.repaint)\n      }\n    }\n  }\n\n  const drawValue = function (ctx, imageWidth, imageHeight) {\n    let top // position of max value\n    let bottom // position of min value\n    const labelColor = backgroundColor.labelColor\n    let fullSize\n    let valueSize\n    let valueTop\n    let valueStartX\n    let valueStartY\n    let valueStopX\n    let valueStopY\n    let valueBackgroundStartX\n    let valueBackgroundStartY\n    let valueBackgroundStopX\n    let valueBackgroundStopY\n    let valueBorderStartX\n    let valueBorderStartY\n    let valueBorderStopX\n    let valueBorderStopY\n    let valueForegroundStartX\n    let valueForegroundStartY\n    let valueForegroundStopX\n    let valueForegroundStopY\n\n    // Orientation dependend definitions\n    if (vertical) {\n      // Vertical orientation\n      top = imageHeight * 0.12864 // position of max value\n      if (gaugeType.type === 'type1') {\n        bottom = imageHeight * 0.856796 // position of min value\n      } else {\n        bottom = imageHeight * 0.7475\n      }\n      fullSize = bottom - top\n      valueSize = (fullSize * (value - minValue)) / (maxValue - minValue)\n      valueTop = bottom - valueSize\n      valueBackgroundStartX = 0\n      valueBackgroundStartY = top\n      valueBackgroundStopX = 0\n      valueBackgroundStopY = bottom\n    } else {\n      // Horizontal orientation\n      if (gaugeType.type === 'type1') {\n        top = imageWidth * 0.871012 // position of max value\n        bottom = imageWidth * 0.142857 // position of min value\n      } else {\n        top = imageWidth * 0.82 // position of max value\n        bottom = imageWidth * 0.19857 // position of min value\n      }\n      fullSize = top - bottom\n      valueSize = (fullSize * (value - minValue)) / (maxValue - minValue)\n      valueTop = bottom\n      valueBackgroundStartX = top\n      valueBackgroundStartY = 0\n      valueBackgroundStopX = bottom\n      valueBackgroundStopY = 0\n    }\n    if (gaugeType.type === 'type1') {\n      const darker =\n        backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].CARBON ||\n        backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].PUNCHED_SHEET ||\n        backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].STAINLESS ||\n        backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].BRUSHED_STAINLESS ||\n        backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].TURNED\n          ? 0.3\n          : 0\n      const valueBackgroundTrackGradient = ctx.createLinearGradient(\n        valueBackgroundStartX,\n        valueBackgroundStartY,\n        valueBackgroundStopX,\n        valueBackgroundStopY\n      )\n      labelColor.setAlpha(0.05 + darker)\n      valueBackgroundTrackGradient.addColorStop(0, labelColor.getRgbaColor())\n      labelColor.setAlpha(0.15 + darker)\n      valueBackgroundTrackGradient.addColorStop(\n        0.48,\n        labelColor.getRgbaColor()\n      )\n      labelColor.setAlpha(0.15 + darker)\n      valueBackgroundTrackGradient.addColorStop(\n        0.49,\n        labelColor.getRgbaColor()\n      )\n      labelColor.setAlpha(0.05 + darker)\n      valueBackgroundTrackGradient.addColorStop(1, labelColor.getRgbaColor())\n      ctx.fillStyle = valueBackgroundTrackGradient\n\n      if (vertical) {\n        ctx.fillRect(\n          imageWidth * 0.435714,\n          top,\n          imageWidth * 0.142857,\n          fullSize\n        )\n      } else {\n        ctx.fillRect(\n          imageWidth * 0.142857,\n          imageHeight * 0.435714,\n          fullSize,\n          imageHeight * 0.142857\n        )\n      }\n\n      if (vertical) {\n        // Vertical orientation\n        valueBorderStartX = 0\n        valueBorderStartY = top\n        valueBorderStopX = 0\n        valueBorderStopY = top + fullSize\n      } else {\n        // Horizontal orientation\n        valueBorderStartX = imageWidth * 0.142857 + fullSize\n        valueBorderStartY = 0\n        valueBorderStopX = imageWidth * 0.142857\n        valueBorderStopY = 0\n      }\n      const valueBorderGradient = ctx.createLinearGradient(\n        valueBorderStartX,\n        valueBorderStartY,\n        valueBorderStopX,\n        valueBorderStopY\n      )\n      labelColor.setAlpha(0.3 + darker)\n      valueBorderGradient.addColorStop(0, labelColor.getRgbaColor())\n      labelColor.setAlpha(0.69)\n      valueBorderGradient.addColorStop(0.48, labelColor.getRgbaColor())\n      labelColor.setAlpha(0.7)\n      valueBorderGradient.addColorStop(0.49, labelColor.getRgbaColor())\n      labelColor.setAlpha(0.4)\n      valueBorderGradient.addColorStop(1, labelColor.getRgbaColor())\n      ctx.fillStyle = valueBorderGradient\n      if (vertical) {\n        ctx.fillRect(\n          imageWidth * 0.435714,\n          top,\n          imageWidth * 0.007142,\n          fullSize\n        )\n        ctx.fillRect(\n          imageWidth * 0.571428,\n          top,\n          imageWidth * 0.007142,\n          fullSize\n        )\n      } else {\n        ctx.fillRect(\n          imageWidth * 0.142857,\n          imageHeight * 0.435714,\n          fullSize,\n          imageHeight * 0.007142\n        )\n        ctx.fillRect(\n          imageWidth * 0.142857,\n          imageHeight * 0.571428,\n          fullSize,\n          imageHeight * 0.007142\n        )\n      }\n    }\n    if (vertical) {\n      // Vertical orientation\n      if (gaugeType.type === 'type1') {\n        valueStartX = imageWidth * 0.45\n        valueStartY = 0\n        valueStopX = imageWidth * 0.45 + imageWidth * 0.114285\n        valueStopY = 0\n      } else {\n        valueStartX = imageWidth / 2 - (imageHeight * 0.0486) / 2\n        valueStartY = 0\n        valueStopX = valueStartX + imageHeight * 0.053\n        valueStopY = 0\n      }\n    } else {\n      // Horizontal orientation\n      if (gaugeType.type === 'type1') {\n        valueStartX = 0\n        valueStartY = imageHeight * 0.45\n        valueStopX = 0\n        valueStopY = imageHeight * 0.45 + imageHeight * 0.114285\n      } else {\n        valueStartX = 0\n        valueStartY = imageHeight / 2 - imageWidth * 0.025\n        valueStopX = 0\n        valueStopY = valueStartY + imageWidth * 0.053\n      }\n    }\n\n    const valueBackgroundGradient = ctx.createLinearGradient(\n      valueStartX,\n      valueStartY,\n      valueStopX,\n      valueStopY\n    )\n    valueBackgroundGradient.addColorStop(0, valueColor.medium.getRgbaColor())\n    valueBackgroundGradient.addColorStop(1, valueColor.light.getRgbaColor())\n    ctx.fillStyle = valueBackgroundGradient\n    const thermoTweak =\n      gaugeType.type === 'type1'\n        ? 0\n        : vertical\n          ? imageHeight * 0.05\n          : imageWidth * 0.05\n    if (vertical) {\n      ctx.fillRect(\n        valueStartX,\n        valueTop,\n        valueStopX - valueStartX,\n        valueSize + thermoTweak\n      )\n    } else {\n      ctx.fillRect(\n        valueTop - thermoTweak,\n        valueStartY,\n        valueSize + thermoTweak,\n        valueStopY - valueStartY\n      )\n    }\n\n    if (gaugeType.type === 'type1') {\n      // The light effect on the value\n      if (vertical) {\n        // Vertical orientation\n        valueForegroundStartX = imageWidth * 0.45\n        valueForegroundStartY = 0\n        valueForegroundStopX = valueForegroundStartX + imageWidth * 0.05\n        valueForegroundStopY = 0\n      } else {\n        // Horizontal orientation\n        valueForegroundStartX = 0\n        valueForegroundStartY = imageHeight * 0.45\n        valueForegroundStopX = 0\n        valueForegroundStopY = valueForegroundStartY + imageHeight * 0.05\n      }\n      const valueForegroundGradient = ctx.createLinearGradient(\n        valueForegroundStartX,\n        valueForegroundStartY,\n        valueForegroundStopX,\n        valueForegroundStopY\n      )\n      valueForegroundGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)')\n      valueForegroundGradient.addColorStop(0.98, 'rgba(255, 255, 255, 0.0)')\n      ctx.fillStyle = valueForegroundGradient\n      if (vertical) {\n        ctx.fillRect(\n          valueForegroundStartX,\n          valueTop,\n          valueForegroundStopX,\n          valueSize\n        )\n      } else {\n        ctx.fillRect(\n          valueTop,\n          valueForegroundStartY,\n          valueSize,\n          valueForegroundStopY - valueForegroundStartY\n        )\n      }\n    }\n  }\n\n  const drawForegroundImage = function (ctx) {\n    const foreSize = vertical ? imageHeight : imageWidth\n\n    ctx.save()\n    if (vertical) {\n      ctx.translate(imageWidth / 2, 0)\n    } else {\n      ctx.translate(imageWidth / 2, imageHeight / 2)\n      ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n      ctx.translate(0, -imageWidth / 2 + imageWidth * 0.05)\n    }\n\n    // draw bulb\n    ctx.beginPath()\n    ctx.moveTo(-0.049 * foreSize, 0.825 * foreSize)\n    ctx.bezierCurveTo(\n      -0.049 * foreSize,\n      0.7975 * foreSize,\n      -0.0264 * foreSize,\n      0.775 * foreSize,\n      0.0013 * foreSize,\n      0.775 * foreSize\n    )\n    ctx.bezierCurveTo(\n      0.0264 * foreSize,\n      0.775 * foreSize,\n      0.049 * foreSize,\n      0.7975 * foreSize,\n      0.049 * foreSize,\n      0.825 * foreSize\n    )\n    ctx.bezierCurveTo(\n      0.049 * foreSize,\n      0.85 * foreSize,\n      0.0264 * foreSize,\n      0.8725 * foreSize,\n      0.0013 * foreSize,\n      0.8725 * foreSize\n    )\n    ctx.bezierCurveTo(\n      -0.0264 * foreSize,\n      0.8725 * foreSize,\n      -0.049 * foreSize,\n      0.85 * foreSize,\n      -0.049 * foreSize,\n      0.825 * foreSize\n    )\n    ctx.closePath()\n    let grad = ctx.createRadialGradient(\n      0 * foreSize,\n      0.825 * foreSize,\n      0,\n      0 * foreSize,\n      0.825 * foreSize,\n      0.049 * foreSize\n    )\n    grad.addColorStop(0, valueColor.medium.getRgbaColor())\n    grad.addColorStop(0.3, valueColor.medium.getRgbaColor())\n    grad.addColorStop(1, valueColor.light.getRgbaColor())\n    ctx.fillStyle = grad\n    ctx.fill()\n\n    // draw bulb highlight\n    ctx.beginPath()\n    if (vertical) {\n      ctx.moveTo(-0.0365 * foreSize, 0.8075 * foreSize)\n      ctx.bezierCurveTo(\n        -0.0365 * foreSize,\n        0.7925 * foreSize,\n        -0.0214 * foreSize,\n        0.7875 * foreSize,\n        -0.0214 * foreSize,\n        0.7825 * foreSize\n      )\n      ctx.bezierCurveTo(\n        0.0189 * foreSize,\n        0.785 * foreSize,\n        0.0365 * foreSize,\n        0.7925 * foreSize,\n        0.0365 * foreSize,\n        0.8075 * foreSize\n      )\n      ctx.bezierCurveTo(\n        0.0365 * foreSize,\n        0.8175 * foreSize,\n        0.0214 * foreSize,\n        0.815 * foreSize,\n        0.0013 * foreSize,\n        0.8125 * foreSize\n      )\n      ctx.bezierCurveTo(\n        -0.0189 * foreSize,\n        0.8125 * foreSize,\n        -0.0365 * foreSize,\n        0.8175 * foreSize,\n        -0.0365 * foreSize,\n        0.8075 * foreSize\n      )\n      grad = ctx.createRadialGradient(\n        0,\n        0.8 * foreSize,\n        0,\n        0,\n        0.8 * foreSize,\n        0.0377 * foreSize\n      )\n    } else {\n      ctx.beginPath()\n      ctx.moveTo(-0.0214 * foreSize, 0.86 * foreSize)\n      ctx.bezierCurveTo(\n        -0.0365 * foreSize,\n        0.86 * foreSize,\n        -0.0415 * foreSize,\n        0.845 * foreSize,\n        -0.0465 * foreSize,\n        0.825 * foreSize\n      )\n      ctx.bezierCurveTo(\n        -0.0465 * foreSize,\n        0.805 * foreSize,\n        -0.0365 * foreSize,\n        0.7875 * foreSize,\n        -0.0214 * foreSize,\n        0.7875 * foreSize\n      )\n      ctx.bezierCurveTo(\n        -0.0113 * foreSize,\n        0.7875 * foreSize,\n        -0.0163 * foreSize,\n        0.8025 * foreSize,\n        -0.0163 * foreSize,\n        0.8225 * foreSize\n      )\n      ctx.bezierCurveTo(\n        -0.0163 * foreSize,\n        0.8425 * foreSize,\n        -0.0113 * foreSize,\n        0.86 * foreSize,\n        -0.0214 * foreSize,\n        0.86 * foreSize\n      )\n      grad = ctx.createRadialGradient(\n        -0.03 * foreSize,\n        0.8225 * foreSize,\n        0,\n        -0.03 * foreSize,\n        0.8225 * foreSize,\n        0.0377 * foreSize\n      )\n    }\n    grad.addColorStop(0.0, 'rgba(255, 255, 255, 0.55)')\n    grad.addColorStop(1.0, 'rgba(255, 255, 255, 0.05)')\n    ctx.fillStyle = grad\n    ctx.closePath()\n    ctx.fill()\n\n    // stem highlight\n    ctx.beginPath()\n    ctx.moveTo(-0.0214 * foreSize, 0.115 * foreSize)\n    ctx.bezierCurveTo(\n      -0.0214 * foreSize,\n      0.1075 * foreSize,\n      -0.0163 * foreSize,\n      0.1025 * foreSize,\n      -0.0113 * foreSize,\n      0.1025 * foreSize\n    )\n    ctx.bezierCurveTo(\n      -0.0113 * foreSize,\n      0.1025 * foreSize,\n      -0.0113 * foreSize,\n      0.1025 * foreSize,\n      -0.0113 * foreSize,\n      0.1025 * foreSize\n    )\n    ctx.bezierCurveTo(\n      -0.0038 * foreSize,\n      0.1025 * foreSize,\n      0.0013 * foreSize,\n      0.1075 * foreSize,\n      0.0013 * foreSize,\n      0.115 * foreSize\n    )\n    ctx.bezierCurveTo(\n      0.0013 * foreSize,\n      0.115 * foreSize,\n      0.0013 * foreSize,\n      0.76 * foreSize,\n      0.0013 * foreSize,\n      0.76 * foreSize\n    )\n    ctx.bezierCurveTo(\n      0.0013 * foreSize,\n      0.7675 * foreSize,\n      -0.0038 * foreSize,\n      0.7725 * foreSize,\n      -0.0113 * foreSize,\n      0.7725 * foreSize\n    )\n    ctx.bezierCurveTo(\n      -0.0113 * foreSize,\n      0.7725 * foreSize,\n      -0.0113 * foreSize,\n      0.7725 * foreSize,\n      -0.0113 * foreSize,\n      0.7725 * foreSize\n    )\n    ctx.bezierCurveTo(\n      -0.0163 * foreSize,\n      0.7725 * foreSize,\n      -0.0214 * foreSize,\n      0.7675 * foreSize,\n      -0.0214 * foreSize,\n      0.76 * foreSize\n    )\n    ctx.bezierCurveTo(\n      -0.0214 * foreSize,\n      0.76 * foreSize,\n      -0.0214 * foreSize,\n      0.115 * foreSize,\n      -0.0214 * foreSize,\n      0.115 * foreSize\n    )\n    ctx.closePath()\n    grad = ctx.createLinearGradient(\n      -0.0189 * foreSize,\n      0,\n      0.0013 * foreSize,\n      0\n    )\n    grad.addColorStop(0.0, 'rgba(255, 255, 255, 0.1)')\n    grad.addColorStop(0.34, 'rgba(255, 255, 255, 0.5)')\n    grad.addColorStop(1.0, 'rgba(255, 255, 255, 0.1)')\n    ctx.fillStyle = grad\n    ctx.fill()\n\n    ctx.restore()\n  }\n\n  const drawBackgroundImage = function (ctx) {\n    const backSize = vertical ? imageHeight : imageWidth\n    ctx.save()\n    if (vertical) {\n      ctx.translate(imageWidth / 2, 0)\n    } else {\n      ctx.translate(imageWidth / 2, imageHeight / 2)\n      ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n      ctx.translate(0, -imageWidth / 2 + imageWidth * 0.05)\n    }\n    ctx.beginPath()\n    ctx.moveTo(-0.0516 * backSize, 0.825 * backSize)\n    ctx.bezierCurveTo(\n      -0.0516 * backSize,\n      0.8525 * backSize,\n      -0.0289 * backSize,\n      0.875 * backSize,\n      0.0013 * backSize,\n      0.875 * backSize\n    )\n    ctx.bezierCurveTo(\n      0.0289 * backSize,\n      0.875 * backSize,\n      0.0516 * backSize,\n      0.8525 * backSize,\n      0.0516 * backSize,\n      0.825 * backSize\n    )\n    ctx.bezierCurveTo(\n      0.0516 * backSize,\n      0.8075 * backSize,\n      0.044 * backSize,\n      0.7925 * backSize,\n      0.0314 * backSize,\n      0.7825 * backSize\n    )\n    ctx.bezierCurveTo(\n      0.0314 * backSize,\n      0.7825 * backSize,\n      0.0314 * backSize,\n      0.12 * backSize,\n      0.0314 * backSize,\n      0.12 * backSize\n    )\n    ctx.bezierCurveTo(\n      0.0314 * backSize,\n      0.1025 * backSize,\n      0.0189 * backSize,\n      0.0875 * backSize,\n      0.0013 * backSize,\n      0.0875 * backSize\n    )\n    ctx.bezierCurveTo(\n      -0.0163 * backSize,\n      0.0875 * backSize,\n      -0.0289 * backSize,\n      0.1025 * backSize,\n      -0.0289 * backSize,\n      0.12 * backSize\n    )\n    ctx.bezierCurveTo(\n      -0.0289 * backSize,\n      0.12 * backSize,\n      -0.0289 * backSize,\n      0.7825 * backSize,\n      -0.0289 * backSize,\n      0.7825 * backSize\n    )\n    ctx.bezierCurveTo(\n      -0.0415 * backSize,\n      0.79 * backSize,\n      -0.0516 * backSize,\n      0.805 * backSize,\n      -0.0516 * backSize,\n      0.825 * backSize\n    )\n    ctx.closePath()\n    const grad = ctx.createLinearGradient(\n      -0.0163 * backSize,\n      0,\n      0.0289 * backSize,\n      0\n    )\n    grad.addColorStop(0, 'rgba(226, 226, 226, 0.5)')\n    grad.addColorStop(0.5, 'rgba(226, 226, 226, 0.2)')\n    grad.addColorStop(1, 'rgba(226, 226, 226, 0.5)')\n    ctx.fillStyle = grad\n    ctx.fill()\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(153, 153, 153, 0.5)'\n    ctx.stroke()\n    ctx.restore()\n  }\n\n  //* *********************************** Public methods **************************************\n  this.setValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    if (value !== targetValue) {\n      value = targetValue\n\n      if (value > maxMeasuredValue) {\n        maxMeasuredValue = value\n      }\n      if (value < minMeasuredValue) {\n        minMeasuredValue = value\n      }\n\n      if (\n        (value >= threshold && !ledBlinking && thresholdRising) ||\n        (value <= threshold && !ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = true\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.play()\n        }\n      } else if (\n        (value < threshold && ledBlinking && thresholdRising) ||\n        (value > threshold && ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = false\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.pause()\n        }\n      }\n\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.setValueAnimated = function (newValue, callback) {\n    const gauge = this\n    let time\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    if (value !== targetValue) {\n      if (undefined !== tween && tween.isPlaying) {\n        tween.stop()\n      }\n\n      time =\n        (fullScaleDeflectionTime * Math.abs(targetValue - value)) /\n        (maxValue - minValue)\n      time = Math.max(time, fullScaleDeflectionTime / 5)\n      tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n        {},\n        '',\n        _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n        value,\n        targetValue,\n        time\n      )\n      // tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n\n      tween.onMotionChanged = function (event) {\n        value = event.target._pos\n        if (value > maxMeasuredValue) {\n          maxMeasuredValue = value\n        }\n        if (value < minMeasuredValue) {\n          minMeasuredValue = value\n        }\n\n        if (\n          (value >= threshold && !ledBlinking && thresholdRising) ||\n          (value <= threshold && !ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = true\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.play()\n          }\n        } else if (\n          (value < threshold && ledBlinking && thresholdRising) ||\n          (value > threshold && ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = false\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.pause()\n          }\n        }\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tween.onMotionFinished = callback\n      }\n\n      tween.start()\n    }\n    return this\n  }\n\n  this.resetMinMeasuredValue = function () {\n    minMeasuredValue = value\n    this.repaint()\n    return this\n  }\n\n  this.resetMaxMeasuredValue = function () {\n    maxMeasuredValue = value\n    this.repaint()\n    return this\n  }\n\n  this.setMinMeasuredValueVisible = function (visible) {\n    minMeasuredValueVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setMaxMeasuredValueVisible = function (visible) {\n    maxMeasuredValueVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setThreshold = function (threshVal) {\n    threshVal = parseFloat(threshVal)\n    const targetValue =\n      threshVal < minValue\n        ? minValue\n        : threshVal > maxValue\n          ? maxValue\n          : threshVal\n    threshold = targetValue\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setThresholdVisible = function (visible) {\n    thresholdVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setThresholdRising = function (rising) {\n    thresholdRising = !!rising\n    // reset existing threshold alerts\n    ledBlinking = !ledBlinking\n    blink(ledBlinking)\n    this.repaint()\n    return this\n  }\n\n  this.setLcdDecimals = function (decimals) {\n    lcdDecimals = parseInt(decimals, 10)\n    this.repaint()\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers({\n      frame: true\n    })\n    frameDesign = newFrameDesign\n    init({\n      frame: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers({\n      background: true\n    })\n    backgroundColor = newBackgroundColor\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setValueColor = function (newValueColor) {\n    resetBuffers({\n      foreground: true\n    })\n    valueColor = newValueColor\n    init({\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLedColor = function (newLedColor) {\n    resetBuffers({\n      led: true\n    })\n    ledColor = newLedColor\n    init({\n      led: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLedVisible = function (visible) {\n    ledVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setLcdColor = function (newLcdColor) {\n    resetBuffers({\n      background: true\n    })\n    lcdColor = newLcdColor\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setMaxMeasuredValue = function (newVal) {\n    newVal = parseFloat(newVal)\n    const targetValue =\n      newVal < minValue ? minValue : newVal > maxValue ? maxValue : newVal\n    maxMeasuredValue = targetValue\n    this.repaint()\n    return this\n  }\n\n  this.setMinMeasuredValue = function (newVal) {\n    newVal = parseFloat(newVal)\n    const targetValue =\n      newVal < minValue ? minValue : newVal > maxValue ? maxValue : newVal\n    minMeasuredValue = targetValue\n    this.repaint()\n    return this\n  }\n\n  this.setTitleString = function (title) {\n    titleString = title\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setUnitString = function (unit) {\n    unitString = unit\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setMinValue = function (newVal) {\n    resetBuffers({\n      background: true\n    })\n    minValue = parseFloat(newVal)\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMinValue = function () {\n    return minValue\n  }\n\n  this.setMaxValue = function (newVal) {\n    resetBuffers({\n      background: true\n    })\n    maxValue = parseFloat(newVal)\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMaxValue = function () {\n    return maxValue\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init({\n        frame: true,\n        background: true,\n        led: true,\n        foreground: true\n      })\n    }\n\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    // Draw frame\n    if (frameVisible) {\n      mainCtx.drawImage(frameBuffer, 0, 0)\n    }\n\n    // Draw buffered image to visible canvas\n    mainCtx.drawImage(backgroundBuffer, 0, 0)\n\n    // Draw lcd display\n    if (lcdVisible) {\n      drawLcdText(mainCtx, value, vertical)\n    }\n\n    // Draw led\n    if (ledVisible) {\n      mainCtx.drawImage(ledBuffer, ledPosX, ledPosY)\n    }\n\n    let valuePos\n    let yOffset\n    let yRange\n    let minMaxX\n    let minMaxY\n    // Draw min measured value indicator\n    if (minMeasuredValueVisible) {\n      if (vertical) {\n        yOffset = gaugeType.type === 'type1' ? 0.856796 : 0.7475\n        yRange = yOffset - 0.12864\n        valuePos =\n          imageHeight * yOffset -\n          (imageHeight * yRange * (minMeasuredValue - minValue)) /\n            (maxValue - minValue)\n        minMaxX = imageWidth * 0.34 - minMeasuredValueBuffer.width\n        minMaxY = valuePos - minMeasuredValueBuffer.height / 2\n      } else {\n        yOffset = gaugeType.type === 'type1' ? 0.871012 : 0.82\n        yRange = yOffset - (gaugeType.type === 'type1' ? 0.142857 : 0.19857)\n        valuePos =\n          (imageWidth * yRange * (minMeasuredValue - minValue)) /\n          (maxValue - minValue)\n        minMaxX =\n          imageWidth * (gaugeType.type === 'type1' ? 0.142857 : 0.19857) -\n          minMeasuredValueBuffer.height / 2 +\n          valuePos\n        minMaxY = imageHeight * 0.65\n      }\n      mainCtx.drawImage(minMeasuredValueBuffer, minMaxX, minMaxY)\n    }\n\n    // Draw max measured value indicator\n    if (maxMeasuredValueVisible) {\n      if (vertical) {\n        valuePos =\n          imageHeight * yOffset -\n          (imageHeight * yRange * (maxMeasuredValue - minValue)) /\n            (maxValue - minValue)\n        minMaxX = imageWidth * 0.34 - maxMeasuredValueBuffer.width\n        minMaxY = valuePos - maxMeasuredValueBuffer.height / 2\n      } else {\n        yOffset = gaugeType.type === 'type1' ? 0.871012 : 0.8\n        yRange = yOffset - (gaugeType.type === 'type1' ? 0.14857 : 0.19857)\n        valuePos =\n          (imageWidth * yRange * (maxMeasuredValue - minValue)) /\n          (maxValue - minValue)\n        minMaxX =\n          imageWidth * (gaugeType.type === 'type1' ? 0.142857 : 0.19857) -\n          maxMeasuredValueBuffer.height / 2 +\n          valuePos\n        minMaxY = imageHeight * 0.65\n      }\n      mainCtx.drawImage(maxMeasuredValueBuffer, minMaxX, minMaxY)\n    }\n\n    mainCtx.save()\n    drawValue(mainCtx, imageWidth, imageHeight)\n    mainCtx.restore()\n\n    // Draw foreground\n    if (foregroundVisible || gaugeType.type === 'type2') {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Linear);\n\n\n//# sourceURL=webpack://steelseries/./src/Linear.js?");

/***/ }),

/***/ "./src/LinearBargraph.js":
/*!*******************************!*\
  !*** ./src/LinearBargraph.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawLinearBackgroundImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawLinearBackgroundImage */ \"./src/drawLinearBackgroundImage.js\");\n/* harmony import */ var _drawLinearForegroundImage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawLinearForegroundImage */ \"./src/drawLinearForegroundImage.js\");\n/* harmony import */ var _drawLinearFrameImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawLinearFrameImage */ \"./src/drawLinearFrameImage.js\");\n/* harmony import */ var _createLedImage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createLedImage */ \"./src/createLedImage.js\");\n/* harmony import */ var _createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createLcdBackgroundImage */ \"./src/createLcdBackgroundImage.js\");\n/* harmony import */ var _createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createMeasuredValueImage */ \"./src/createMeasuredValueImage.js\");\n/* harmony import */ var _drawTitleImage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./drawTitleImage */ \"./src/drawTitleImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst LinearBargraph = function (canvas, parameters) {\n  parameters = parameters || {}\n  let width = undefined === parameters.width ? 0 : parameters.width\n  let height = undefined === parameters.height ? 0 : parameters.height\n  let minValue = undefined === parameters.minValue ? 0 : parameters.minValue\n  let maxValue =\n    undefined === parameters.maxValue ? minValue + 100 : parameters.maxValue\n  let section = undefined === parameters.section ? null : parameters.section\n  const niceScale =\n    undefined === parameters.niceScale ? true : parameters.niceScale\n  let threshold =\n    undefined === parameters.threshold\n      ? (maxValue - minValue) / 2 + minValue\n      : parameters.threshold\n  let titleString =\n    undefined === parameters.titleString ? '' : parameters.titleString\n  let unitString =\n    undefined === parameters.unitString ? '' : parameters.unitString\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].DARK_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let valueColor =\n    undefined === parameters.valueColor ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].RED : parameters.valueColor\n  let lcdColor =\n    undefined === parameters.lcdColor ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LcdColor\"].STANDARD : parameters.lcdColor\n  const lcdVisible =\n    undefined === parameters.lcdVisible ? true : parameters.lcdVisible\n  let lcdDecimals =\n    undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals\n  const digitalFont =\n    undefined === parameters.digitalFont ? false : parameters.digitalFont\n  let ledColor =\n    undefined === parameters.ledColor ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LedColor\"].RED_LED : parameters.ledColor\n  let ledVisible =\n    undefined === parameters.ledVisible ? true : parameters.ledVisible\n  let thresholdVisible =\n    undefined === parameters.thresholdVisible\n      ? true\n      : parameters.thresholdVisible\n  let thresholdRising =\n    undefined === parameters.thresholdRising\n      ? true\n      : parameters.thresholdRising\n  let minMeasuredValueVisible =\n    undefined === parameters.minMeasuredValueVisible\n      ? false\n      : parameters.minMeasuredValueVisible\n  let maxMeasuredValueVisible =\n    undefined === parameters.maxMeasuredValueVisible\n      ? false\n      : parameters.maxMeasuredValueVisible\n  const labelNumberFormat =\n    undefined === parameters.labelNumberFormat\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LabelNumberFormat\"].STANDARD\n      : parameters.labelNumberFormat\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  const playAlarm =\n    undefined === parameters.playAlarm ? false : parameters.playAlarm\n  const alarmSound =\n    undefined === parameters.alarmSound ? false : parameters.alarmSound\n  let valueGradient =\n    undefined === parameters.valueGradient ? null : parameters.valueGradient\n  let useValueGradient =\n    undefined === parameters.useValueGradient\n      ? false\n      : parameters.useValueGradient\n  const fullScaleDeflectionTime =\n    undefined === parameters.fullScaleDeflectionTime\n      ? 2.5\n      : parameters.fullScaleDeflectionTime\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (width === 0) {\n    width = mainCtx.canvas.width\n  }\n  if (height === 0) {\n    height = mainCtx.canvas.height\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = width\n  mainCtx.canvas.height = height\n\n  const imageWidth = width\n  const imageHeight = height\n\n  let audioElement\n\n  // Create audio tag for alarm sound\n  if (playAlarm && alarmSound !== false) {\n    audioElement = _tools__WEBPACK_IMPORTED_MODULE_8__[\"doc\"].createElement('audio')\n    audioElement.setAttribute('src', alarmSound)\n    audioElement.setAttribute('preload', 'auto')\n  }\n\n  const self = this\n  let value = minValue\n\n  // Properties\n  let minMeasuredValue = maxValue\n  let maxMeasuredValue = minValue\n\n  let tween\n  let ledBlinking = false\n  let repainting = false\n  let isSectionsVisible = false\n  let isGradientVisible = false\n  let sectionPixels = []\n  let ledTimerId = 0\n\n  const vertical = width <= height\n\n  // Constants\n  let ledPosX\n  let ledPosY\n  const ledSize = Math.round((vertical ? height : width) * 0.05)\n  const minMaxIndSize = Math.round((vertical ? width : height) * 0.05)\n  let stdFont\n  let lcdFont\n\n  if (vertical) {\n    ledPosX = imageWidth / 2 - ledSize / 2\n    ledPosY = 0.053 * imageHeight\n    stdFont = Math.floor(imageHeight / 22) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n    lcdFont = Math.floor(imageHeight / 22) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"lcdFontName\"]\n  } else {\n    ledPosX = 0.89 * imageWidth\n    ledPosY = imageHeight / 1.95 - ledSize / 2\n    stdFont = Math.floor(imageHeight / 10) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n    lcdFont = Math.floor(imageHeight / 10) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"lcdFontName\"]\n  }\n\n  let initialized = false\n\n  // Tickmark specific private variables\n  let niceMinValue = minValue\n  let niceMaxValue = maxValue\n  let niceRange = maxValue - minValue\n  let minorTickSpacing = 0\n  let majorTickSpacing = 0\n  const maxNoOfMinorTicks = 10\n  const maxNoOfMajorTicks = 10\n\n  // Method to calculate nice values for min, max and range for the tickmarks\n  const calculate = function calculate () {\n    if (niceScale) {\n      niceRange = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"calcNiceNumber\"])(maxValue - minValue, false)\n      majorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"calcNiceNumber\"])(\n        niceRange / (maxNoOfMajorTicks - 1),\n        true\n      )\n      niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing\n      niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing\n      minorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"calcNiceNumber\"])(\n        majorTickSpacing / (maxNoOfMinorTicks - 1),\n        true\n      )\n      minValue = niceMinValue\n      maxValue = niceMaxValue\n    } else {\n      niceRange = maxValue - minValue\n      niceMinValue = minValue\n      niceMaxValue = maxValue\n      minorTickSpacing = 1\n      majorTickSpacing = 10\n    }\n    // Make sure values are still in range\n    value = value < minValue ? minValue : value > maxValue ? maxValue : value\n    minMeasuredValue =\n      minMeasuredValue < minValue\n        ? minValue\n        : minMeasuredValue > maxValue\n          ? maxValue\n          : minMeasuredValue\n    maxMeasuredValue =\n      maxMeasuredValue < minValue\n        ? minValue\n        : maxMeasuredValue > maxValue\n          ? maxValue\n          : maxMeasuredValue\n    threshold =\n      threshold < minValue\n        ? minValue\n        : threshold > maxValue\n          ? maxValue\n          : threshold\n  }\n\n  // **************   Buffer creation  ********************\n  // Buffer for the frame\n  const frameBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(width, height)\n  let frameContext = frameBuffer.getContext('2d')\n\n  // Buffer for the background\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(width, height)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  let lcdBuffer\n\n  // Buffer for active bargraph led\n  const activeLedBuffer = _tools__WEBPACK_IMPORTED_MODULE_8__[\"doc\"].createElement('canvas')\n  if (vertical) {\n    activeLedBuffer.width = imageWidth * 0.121428\n    activeLedBuffer.height = imageHeight * 0.012135\n  } else {\n    activeLedBuffer.width = imageWidth * 0.012135\n    activeLedBuffer.height = imageHeight * 0.121428\n  }\n  let activeLedContext = activeLedBuffer.getContext('2d')\n\n  // Buffer for active bargraph led\n  const inActiveLedBuffer = _tools__WEBPACK_IMPORTED_MODULE_8__[\"doc\"].createElement('canvas')\n  if (vertical) {\n    inActiveLedBuffer.width = imageWidth * 0.121428\n    inActiveLedBuffer.height = imageHeight * 0.012135\n  } else {\n    inActiveLedBuffer.width = imageWidth * 0.012135\n    inActiveLedBuffer.height = imageHeight * 0.121428\n  }\n  let inActiveLedContext = inActiveLedBuffer.getContext('2d')\n\n  // Buffer for led on painting code\n  const ledBufferOn = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(ledSize, ledSize)\n  let ledContextOn = ledBufferOn.getContext('2d')\n\n  // Buffer for led off painting code\n  const ledBufferOff = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(ledSize, ledSize)\n  let ledContextOff = ledBufferOff.getContext('2d')\n\n  // Buffer for current led painting code\n  let ledBuffer = ledBufferOff\n\n  // Buffer for the minMeasuredValue indicator\n  const minMeasuredValueBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(minMaxIndSize, minMaxIndSize)\n  const minMeasuredValueCtx = minMeasuredValueBuffer.getContext('2d')\n\n  // Buffer for the maxMeasuredValue indicator\n  const maxMeasuredValueBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(minMaxIndSize, minMaxIndSize)\n  const maxMeasuredValueCtx = maxMeasuredValueBuffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(width, height)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  // **************   Image creation  ********************\n  const drawLcdText = function (ctx, value, vertical) {\n    ctx.save()\n    ctx.textAlign = 'right'\n    ctx.textBaseline = 'middle'\n    ctx.strokeStyle = lcdColor.textColor\n    ctx.fillStyle = lcdColor.textColor\n\n    if (\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LcdColor\"].STANDARD ||\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LcdColor\"].STANDARD_GREEN\n    ) {\n      ctx.shadowColor = 'gray'\n      if (vertical) {\n        ctx.shadowOffsetX = imageWidth * 0.007\n        ctx.shadowOffsetY = imageWidth * 0.007\n        ctx.shadowBlur = imageWidth * 0.009\n      } else {\n        ctx.shadowOffsetX = imageHeight * 0.007\n        ctx.shadowOffsetY = imageHeight * 0.007\n        ctx.shadowBlur = imageHeight * 0.009\n      }\n    }\n\n    let lcdTextX\n    let lcdTextY\n    let lcdTextWidth\n\n    if (digitalFont) {\n      ctx.font = lcdFont\n    } else {\n      ctx.font = stdFont\n    }\n\n    if (vertical) {\n      lcdTextX =\n        (imageWidth - imageWidth * 0.571428) / 2 +\n        1 +\n        imageWidth * 0.571428 -\n        2\n      lcdTextY = imageHeight * 0.88 + 1 + (imageHeight * 0.055 - 2) / 2\n      lcdTextWidth = imageWidth * 0.7 - 2\n    } else {\n      lcdTextX = imageWidth * 0.695 + imageWidth * 0.18 - 2\n      lcdTextY = imageHeight * 0.22 + 1 + (imageHeight * 0.15 - 2) / 2\n      lcdTextWidth = imageHeight * 0.22 - 2\n    }\n\n    ctx.fillText(value.toFixed(lcdDecimals), lcdTextX, lcdTextY, lcdTextWidth)\n\n    ctx.restore()\n  }\n\n  const createThresholdImage = function (vertical) {\n    const thresholdBuffer = _tools__WEBPACK_IMPORTED_MODULE_8__[\"doc\"].createElement('canvas')\n    thresholdBuffer.height = thresholdBuffer.width = minMaxIndSize\n    const thresholdCtx = thresholdBuffer.getContext('2d')\n\n    thresholdCtx.save()\n    const gradThreshold = thresholdCtx.createLinearGradient(\n      0,\n      0.1,\n      0,\n      thresholdBuffer.height * 0.9\n    )\n    gradThreshold.addColorStop(0, '#520000')\n    gradThreshold.addColorStop(0.3, '#fc1d00')\n    gradThreshold.addColorStop(0.59, '#fc1d00')\n    gradThreshold.addColorStop(1, '#520000')\n    thresholdCtx.fillStyle = gradThreshold\n\n    if (vertical) {\n      thresholdCtx.beginPath()\n      thresholdCtx.moveTo(0.1, thresholdBuffer.height * 0.5)\n      thresholdCtx.lineTo(thresholdBuffer.width * 0.9, 0.1)\n      thresholdCtx.lineTo(\n        thresholdBuffer.width * 0.9,\n        thresholdBuffer.height * 0.9\n      )\n      thresholdCtx.closePath()\n    } else {\n      thresholdCtx.beginPath()\n      thresholdCtx.moveTo(0.1, 0.1)\n      thresholdCtx.lineTo(thresholdBuffer.width * 0.9, 0.1)\n      thresholdCtx.lineTo(\n        thresholdBuffer.width * 0.5,\n        thresholdBuffer.height * 0.9\n      )\n      thresholdCtx.closePath()\n    }\n\n    thresholdCtx.fill()\n    thresholdCtx.strokeStyle = '#FFFFFF'\n    thresholdCtx.stroke()\n\n    thresholdCtx.restore()\n\n    return thresholdBuffer\n  }\n\n  const drawTickmarksImage = function (ctx, labelNumberFormat, vertical) {\n    backgroundColor.labelColor.setAlpha(1)\n    ctx.save()\n    ctx.textBaseline = 'middle'\n    const TEXT_WIDTH = imageWidth * 0.1\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n\n    let valueCounter = minValue\n    let majorTickCounter = maxNoOfMinorTicks - 1\n    let tickCounter\n    let currentPos\n    let scaleBoundsX\n    let scaleBoundsY\n    let scaleBoundsW\n    let scaleBoundsH\n    let tickSpaceScaling = 1\n\n    let minorTickStart\n    let minorTickStop\n    let mediumTickStart\n    let mediumTickStop\n    let majorTickStart\n    let majorTickStop\n    if (vertical) {\n      minorTickStart = 0.34 * imageWidth\n      minorTickStop = 0.36 * imageWidth\n      mediumTickStart = 0.33 * imageWidth\n      mediumTickStop = 0.36 * imageWidth\n      majorTickStart = 0.32 * imageWidth\n      majorTickStop = 0.36 * imageWidth\n      ctx.textAlign = 'right'\n      scaleBoundsX = 0\n      scaleBoundsY = imageHeight * 0.12864\n      scaleBoundsW = 0\n      scaleBoundsH = imageHeight * 0.856796 - imageHeight * 0.12864\n      tickSpaceScaling = scaleBoundsH / (maxValue - minValue)\n    } else {\n      minorTickStart = 0.65 * imageHeight\n      minorTickStop = 0.63 * imageHeight\n      mediumTickStart = 0.66 * imageHeight\n      mediumTickStop = 0.63 * imageHeight\n      majorTickStart = 0.67 * imageHeight\n      majorTickStop = 0.63 * imageHeight\n      ctx.textAlign = 'center'\n      scaleBoundsX = imageWidth * 0.142857\n      scaleBoundsY = 0\n      scaleBoundsW = imageWidth * 0.871012 - imageWidth * 0.142857\n      scaleBoundsH = 0\n      tickSpaceScaling = scaleBoundsW / (maxValue - minValue)\n    }\n\n    let labelCounter\n    for (\n      labelCounter = minValue, tickCounter = 0;\n      labelCounter <= maxValue;\n      labelCounter += minorTickSpacing, tickCounter += minorTickSpacing\n    ) {\n      // Calculate the bounds of the scaling\n      if (vertical) {\n        currentPos =\n          scaleBoundsY + scaleBoundsH - tickCounter * tickSpaceScaling\n      } else {\n        currentPos = scaleBoundsX + tickCounter * tickSpaceScaling\n      }\n\n      majorTickCounter++\n\n      // Draw tickmark every major tickmark spacing\n      if (majorTickCounter === maxNoOfMinorTicks) {\n        // Draw the major tickmarks\n        ctx.lineWidth = 1.5\n        drawLinearTicks(\n          ctx,\n          majorTickStart,\n          majorTickStop,\n          currentPos,\n          vertical\n        )\n\n        // Draw the standard tickmark labels\n        if (vertical) {\n          // Vertical orientation\n          switch (labelNumberFormat.format) {\n            case 'fractional':\n              ctx.fillText(\n                valueCounter.toFixed(2),\n                imageWidth * 0.28,\n                currentPos,\n                TEXT_WIDTH\n              )\n              break\n\n            case 'scientific':\n              ctx.fillText(\n                valueCounter.toPrecision(2),\n                imageWidth * 0.28,\n                currentPos,\n                TEXT_WIDTH\n              )\n              break\n\n            case 'standard':\n            /* falls through */\n            default:\n              ctx.fillText(\n                valueCounter.toFixed(0),\n                imageWidth * 0.28,\n                currentPos,\n                TEXT_WIDTH\n              )\n              break\n          }\n        } else {\n          // Horizontal orientation\n          switch (labelNumberFormat.format) {\n            case 'fractional':\n              ctx.fillText(\n                valueCounter.toFixed(2),\n                currentPos,\n                imageHeight * 0.73,\n                TEXT_WIDTH\n              )\n              break\n\n            case 'scientific':\n              ctx.fillText(\n                valueCounter.toPrecision(2),\n                currentPos,\n                imageHeight * 0.73,\n                TEXT_WIDTH\n              )\n              break\n\n            case 'standard':\n            /* falls through */\n            default:\n              ctx.fillText(\n                valueCounter.toFixed(0),\n                currentPos,\n                imageHeight * 0.73,\n                TEXT_WIDTH\n              )\n              break\n          }\n        }\n\n        valueCounter += majorTickSpacing\n        majorTickCounter = 0\n        continue\n      }\n\n      // Draw tickmark every minor tickmark spacing\n      if (\n        maxNoOfMinorTicks % 2 === 0 &&\n        majorTickCounter === maxNoOfMinorTicks / 2\n      ) {\n        ctx.lineWidth = 1\n        drawLinearTicks(\n          ctx,\n          mediumTickStart,\n          mediumTickStop,\n          currentPos,\n          vertical\n        )\n      } else {\n        ctx.lineWidth = 0.5\n        drawLinearTicks(\n          ctx,\n          minorTickStart,\n          minorTickStop,\n          currentPos,\n          vertical\n        )\n      }\n    }\n\n    ctx.restore()\n  }\n\n  const drawLinearTicks = function (\n    ctx,\n    tickStart,\n    tickStop,\n    currentPos,\n    vertical\n  ) {\n    if (vertical) {\n      // Vertical orientation\n      ctx.beginPath()\n      ctx.moveTo(tickStart, currentPos)\n      ctx.lineTo(tickStop, currentPos)\n      ctx.closePath()\n      ctx.stroke()\n    } else {\n      // Horizontal orientation\n      ctx.beginPath()\n      ctx.moveTo(currentPos, tickStart)\n      ctx.lineTo(currentPos, tickStop)\n      ctx.closePath()\n      ctx.stroke()\n    }\n  }\n\n  // **************   Initialization  ********************\n  const init = function (parameters) {\n    parameters = parameters || {}\n    const drawFrame2 =\n      undefined === parameters.frame ? false : parameters.frame\n    const drawBackground2 =\n      undefined === parameters.background ? false : parameters.background\n    const drawLed = undefined === parameters.led ? false : parameters.led\n    const drawForeground2 =\n      undefined === parameters.foreground ? false : parameters.foreground\n    const drawBargraphLed =\n      undefined === parameters.bargraphled ? false : parameters.bargraphled\n\n    initialized = true\n\n    // Calculate the current min and max values and the range\n    calculate()\n\n    // Create frame in frame buffer (backgroundBuffer)\n    if (drawFrame2 && frameVisible) {\n      Object(_drawLinearFrameImage__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        frameContext,\n        frameDesign,\n        imageWidth,\n        imageHeight,\n        vertical\n      )\n    }\n\n    // Create background in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      Object(_drawLinearBackgroundImage__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        imageWidth,\n        imageHeight,\n        vertical\n      )\n    }\n\n    if (drawLed) {\n      if (vertical) {\n        // Draw LED ON in ledBuffer_ON\n        ledContextOn.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ledSize, 1, ledColor), 0, 0)\n\n        // Draw LED ON in ledBuffer_OFF\n        ledContextOff.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ledSize, 0, ledColor), 0, 0)\n      } else {\n        // Draw LED ON in ledBuffer_ON\n        ledContextOn.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ledSize, 1, ledColor), 0, 0)\n\n        // Draw LED ON in ledBuffer_OFF\n        ledContextOff.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(ledSize, 0, ledColor), 0, 0)\n      }\n    }\n\n    // Draw min measured value indicator in minMeasuredValueBuffer\n    if (minMeasuredValueVisible) {\n      if (vertical) {\n        minMeasuredValueCtx.drawImage(\n          Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n            minMaxIndSize,\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].BLUE.dark.getRgbaColor(),\n            false,\n            vertical\n          ),\n          0,\n          0\n        )\n      } else {\n        minMeasuredValueCtx.drawImage(\n          Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n            minMaxIndSize,\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].BLUE.dark.getRgbaColor(),\n            false,\n            vertical\n          ),\n          0,\n          0\n        )\n      }\n    }\n\n    // Draw max measured value indicator in maxMeasuredValueBuffer\n    if (maxMeasuredValueVisible) {\n      if (vertical) {\n        maxMeasuredValueCtx.drawImage(\n          Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n            minMaxIndSize,\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].RED.medium.getRgbaColor(),\n            false,\n            vertical\n          ),\n          0,\n          0\n        )\n      } else {\n        maxMeasuredValueCtx.drawImage(\n          Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n            minMaxIndSize,\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].RED.medium.getRgbaColor(),\n            false,\n            vertical\n          ),\n          0,\n          0\n        )\n      }\n    }\n\n    // Create alignment posts in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      let valuePos\n      // Create tickmarks in background buffer (backgroundBuffer)\n      drawTickmarksImage(backgroundContext, labelNumberFormat, vertical)\n\n      // Draw threshold image to background context\n      if (thresholdVisible) {\n        backgroundContext.save()\n        if (vertical) {\n          // Vertical orientation\n          valuePos =\n            imageHeight * 0.856796 -\n            (imageHeight * 0.728155 * (threshold - minValue)) /\n              (maxValue - minValue)\n          backgroundContext.translate(\n            imageWidth * 0.365,\n            valuePos - minMaxIndSize / 2\n          )\n        } else {\n          // Horizontal orientation\n          valuePos =\n            ((imageWidth * 0.856796 - imageWidth * 0.12864) *\n              (threshold - minValue)) /\n            (maxValue - minValue)\n          backgroundContext.translate(\n            imageWidth * 0.142857 - minMaxIndSize / 2 + valuePos,\n            imageHeight * 0.58\n          )\n        }\n        backgroundContext.drawImage(createThresholdImage(vertical), 0, 0)\n        backgroundContext.restore()\n      }\n\n      // Create title in background buffer (backgroundBuffer)\n      if (vertical) {\n        Object(_drawTitleImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n          backgroundContext,\n          imageWidth,\n          imageHeight,\n          titleString,\n          unitString,\n          backgroundColor,\n          vertical,\n          null,\n          lcdVisible\n        )\n      } else {\n        Object(_drawTitleImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n          backgroundContext,\n          imageWidth,\n          imageHeight,\n          titleString,\n          unitString,\n          backgroundColor,\n          vertical,\n          null,\n          lcdVisible\n        )\n      }\n    }\n\n    // Create lcd background if selected in background buffer (backgroundBuffer)\n    if (drawBackground2 && lcdVisible) {\n      if (vertical) {\n        lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n          imageWidth * 0.571428,\n          imageHeight * 0.055,\n          lcdColor\n        )\n        backgroundContext.drawImage(\n          lcdBuffer,\n          (imageWidth - imageWidth * 0.571428) / 2,\n          imageHeight * 0.88\n        )\n      } else {\n        lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n          imageWidth * 0.18,\n          imageHeight * 0.15,\n          lcdColor\n        )\n        backgroundContext.drawImage(\n          lcdBuffer,\n          imageWidth * 0.695,\n          imageHeight * 0.22\n        )\n      }\n    }\n\n    // Draw leds of bargraph\n    if (drawBargraphLed) {\n      drawInActiveLed(inActiveLedContext)\n      drawActiveLed(activeLedContext, valueColor)\n    }\n\n    // Convert Section values into pixels\n    isSectionsVisible = false\n    if (section !== null && section.length > 0) {\n      isSectionsVisible = true\n      let sectionIndex = section.length\n      let top\n      let bottom\n      let fullSize\n      let ledWidth2\n\n      if (vertical) {\n        // Vertical orientation\n        top = imageHeight * 0.12864 // position of max value\n        bottom = imageHeight * 0.856796 // position of min value\n        fullSize = bottom - top\n        ledWidth2 = 0\n      } else {\n        // Horizontal orientation\n        top = imageWidth * 0.856796 // position of max value\n        bottom = imageWidth * 0.12864\n        fullSize = top - bottom\n        ledWidth2 = (imageWidth * 0.012135) / 2\n      }\n      sectionPixels = []\n      do {\n        sectionIndex--\n        sectionPixels.push({\n          start:\n            ((section[sectionIndex].start + Math.abs(minValue)) /\n              (maxValue - minValue)) *\n              fullSize -\n            ledWidth2,\n          stop:\n            ((section[sectionIndex].stop + Math.abs(minValue)) /\n              (maxValue - minValue)) *\n              fullSize -\n            ledWidth2,\n          color: Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"customColorDef\"])(section[sectionIndex].color)\n        })\n      } while (sectionIndex > 0)\n    }\n\n    // Use a gradient for the valueColor?\n    isGradientVisible = false\n    if (useValueGradient && valueGradient !== null) {\n      // force section colors off!\n      isSectionsVisible = false\n      isGradientVisible = true\n    }\n\n    // Create foreground in foreground buffer (foregroundBuffer)\n    if (drawForeground2 && foregroundVisible) {\n      Object(_drawLinearForegroundImage__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        foregroundContext,\n        imageWidth,\n        imageHeight,\n        vertical,\n        false\n      )\n    }\n  }\n\n  const resetBuffers = function (buffers) {\n    buffers = buffers || {}\n    const resetFrame = undefined === buffers.frame ? false : buffers.frame\n    const resetBackground =\n      undefined === buffers.background ? false : buffers.background\n    const resetLed = undefined === buffers.led ? false : buffers.led\n    const resetBargraphLed =\n      undefined === buffers.bargraphled ? false : buffers.bargraphled\n    const resetForeground =\n      undefined === buffers.foreground ? false : buffers.foreground\n\n    if (resetFrame) {\n      frameBuffer.width = width\n      frameBuffer.height = height\n      frameContext = frameBuffer.getContext('2d')\n    }\n\n    if (resetBackground) {\n      backgroundBuffer.width = width\n      backgroundBuffer.height = height\n      backgroundContext = backgroundBuffer.getContext('2d')\n    }\n\n    if (resetBargraphLed) {\n      if (vertical) {\n        activeLedBuffer.width = width * 0.121428\n        activeLedBuffer.height = height * 0.012135\n      } else {\n        activeLedBuffer.width = width * 0.012135\n        activeLedBuffer.height = height * 0.121428\n      }\n      activeLedContext = activeLedBuffer.getContext('2d')\n\n      // Buffer for active bargraph led\n      if (vertical) {\n        inActiveLedBuffer.width = width * 0.121428\n        inActiveLedBuffer.height = height * 0.012135\n      } else {\n        inActiveLedBuffer.width = width * 0.012135\n        inActiveLedBuffer.height = height * 0.121428\n      }\n      inActiveLedContext = inActiveLedBuffer.getContext('2d')\n    }\n\n    if (resetLed) {\n      ledBufferOn.width = Math.ceil(width * 0.093457)\n      ledBufferOn.height = Math.ceil(height * 0.093457)\n      ledContextOn = ledBufferOn.getContext('2d')\n\n      ledBufferOff.width = Math.ceil(width * 0.093457)\n      ledBufferOff.height = Math.ceil(height * 0.093457)\n      ledContextOff = ledBufferOff.getContext('2d')\n\n      // Buffer for current led painting code\n      ledBuffer = ledBufferOff\n    }\n\n    if (resetForeground) {\n      foregroundBuffer.width = width\n      foregroundBuffer.height = height\n      foregroundContext = foregroundBuffer.getContext('2d')\n    }\n  }\n\n  const blink = function (blinking) {\n    if (blinking) {\n      ledTimerId = setInterval(toggleAndRepaintLed, 1000)\n    } else {\n      clearInterval(ledTimerId)\n      ledBuffer = ledBufferOff\n    }\n  }\n\n  const toggleAndRepaintLed = function () {\n    if (ledVisible) {\n      if (ledBuffer === ledBufferOn) {\n        ledBuffer = ledBufferOff\n      } else {\n        ledBuffer = ledBufferOn\n      }\n      if (!repainting) {\n        repainting = true\n        Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(self.repaint)\n      }\n    }\n  }\n\n  const drawValue = function (ctx, imageWidth, imageHeight) {\n    let top // position of max value\n    let bottom // position of min value\n    const labelColor = backgroundColor.labelColor\n    let fullSize\n    let valueBackgroundStartX\n    let valueBackgroundStartY\n    let valueBackgroundStopX\n    let valueBackgroundStopY\n    let valueBorderStartX\n    let valueBorderStartY\n    let valueBorderStopX\n    let valueBorderStopY\n    let currentValue\n    let gradRange\n    let fraction\n\n    // Orientation dependend definitions\n    if (vertical) {\n      // Vertical orientation\n      top = imageHeight * 0.12864 // position of max value\n      bottom = imageHeight * 0.856796 // position of min value\n      fullSize = bottom - top\n      valueBackgroundStartX = 0\n      valueBackgroundStartY = top\n      valueBackgroundStopX = 0\n      valueBackgroundStopY = top + fullSize * 1.014\n    } else {\n      // Horizontal orientation\n      top = imageWidth * 0.856796 // position of max value\n      bottom = imageWidth * 0.12864\n      fullSize = top - bottom\n      valueBackgroundStartX = imageWidth * 0.13\n      valueBackgroundStartY = imageHeight * 0.435714\n      valueBackgroundStopX = valueBackgroundStartX + fullSize * 1.035\n      valueBackgroundStopY = valueBackgroundStartY\n    }\n\n    const darker =\n      backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].CARBON ||\n      backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].PUNCHED_SHEET ||\n      backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].STAINLESS ||\n      backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].BRUSHED_STAINLESS ||\n      backgroundColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].TURNED\n        ? 0.3\n        : 0\n\n    const valueBackgroundTrackGradient = ctx.createLinearGradient(\n      valueBackgroundStartX,\n      valueBackgroundStartY,\n      valueBackgroundStopX,\n      valueBackgroundStopY\n    )\n    labelColor.setAlpha(0.047058 + darker)\n    valueBackgroundTrackGradient.addColorStop(0, labelColor.getRgbaColor())\n    labelColor.setAlpha(0.145098 + darker)\n    valueBackgroundTrackGradient.addColorStop(0.48, labelColor.getRgbaColor())\n    labelColor.setAlpha(0.149019 + darker)\n    valueBackgroundTrackGradient.addColorStop(0.49, labelColor.getRgbaColor())\n    labelColor.setAlpha(0.047058 + darker)\n    valueBackgroundTrackGradient.addColorStop(1, labelColor.getRgbaColor())\n    ctx.fillStyle = valueBackgroundTrackGradient\n\n    if (vertical) {\n      ctx.fillRect(\n        imageWidth * 0.435714,\n        top,\n        imageWidth * 0.15,\n        fullSize * 1.014\n      )\n    } else {\n      ctx.fillRect(\n        valueBackgroundStartX,\n        valueBackgroundStartY,\n        fullSize * 1.035,\n        imageHeight * 0.152857\n      )\n    }\n\n    if (vertical) {\n      // Vertical orientation\n      valueBorderStartX = 0\n      valueBorderStartY = top\n      valueBorderStopX = 0\n      valueBorderStopY = top + fullSize * 1.014\n    } else {\n      // Horizontal orientation                ;\n      valueBorderStartX = valueBackgroundStartX\n      valueBorderStartY = 0\n      valueBorderStopX = valueBackgroundStopX\n      valueBorderStopY = 0\n    }\n\n    const valueBorderGradient = ctx.createLinearGradient(\n      valueBorderStartX,\n      valueBorderStartY,\n      valueBorderStopX,\n      valueBorderStopY\n    )\n    labelColor.setAlpha(0.298039 + darker)\n    valueBorderGradient.addColorStop(0, labelColor.getRgbaColor())\n    labelColor.setAlpha(0.686274 + darker)\n    valueBorderGradient.addColorStop(0.48, labelColor.getRgbaColor())\n    labelColor.setAlpha(0.698039 + darker)\n    valueBorderGradient.addColorStop(0.49, labelColor.getRgbaColor())\n    labelColor.setAlpha(0.4 + darker)\n    valueBorderGradient.addColorStop(1, labelColor.getRgbaColor())\n    ctx.fillStyle = valueBorderGradient\n    if (vertical) {\n      ctx.fillRect(\n        imageWidth * 0.435714,\n        top,\n        imageWidth * 0.007142,\n        fullSize * 1.014\n      )\n      ctx.fillRect(\n        imageWidth * 0.571428,\n        top,\n        imageWidth * 0.007142,\n        fullSize * 1.014\n      )\n    } else {\n      ctx.fillRect(\n        imageWidth * 0.13,\n        imageHeight * 0.435714,\n        fullSize * 1.035,\n        imageHeight * 0.007142\n      )\n      ctx.fillRect(\n        imageWidth * 0.13,\n        imageHeight * 0.571428,\n        fullSize * 1.035,\n        imageHeight * 0.007142\n      )\n    }\n\n    // Prepare led specific variables\n    let ledX\n    let ledY\n    let ledW\n    let ledH\n    let activeLeds\n    let inactiveLeds\n    if (vertical) {\n      // VERTICAL\n      ledX = imageWidth * 0.45\n      ledY = imageHeight * 0.851941\n      ledW = imageWidth * 0.121428\n      ledH = imageHeight * 0.012135\n    } else {\n      // HORIZONTAL\n      ledX = imageWidth * 0.142857\n      ledY = imageHeight * 0.45\n      ledW = imageWidth * 0.012135\n      ledH = imageHeight * 0.121428\n    }\n\n    let translateX\n    let translateY\n    let activeLedColor\n    let lastActiveLedColor = valueColor\n    let i\n    // Draw the value\n    if (vertical) {\n      // Draw the inactive leds\n      inactiveLeds = fullSize\n      for (translateY = 0; translateY <= inactiveLeds; translateY += ledH + 1) {\n        ctx.translate(0, -translateY)\n        ctx.drawImage(inActiveLedBuffer, ledX, ledY)\n        ctx.translate(0, translateY)\n      }\n      // Draw the active leds in dependence on the current value\n      activeLeds = ((value - minValue) / (maxValue - minValue)) * fullSize\n      for (translateY = 0; translateY <= activeLeds; translateY += ledH + 1) {\n        // check for LED color\n        activeLedColor = valueColor\n        // Use a gradient for value colors?\n        if (isGradientVisible) {\n          // Convert pixel back to value\n          currentValue =\n            minValue + (translateY / fullSize) * (maxValue - minValue)\n          gradRange = valueGradient.getEnd() - valueGradient.getStart()\n          fraction = (currentValue - minValue) / gradRange\n          fraction = Math.max(Math.min(fraction, 1), 0)\n          activeLedColor = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"customColorDef\"])(\n            valueGradient.getColorAt(fraction).getRgbaColor()\n          )\n        } else if (isSectionsVisible) {\n          for (i = 0; i < sectionPixels.length; i++) {\n            if (\n              translateY >= sectionPixels[i].start &&\n              translateY < sectionPixels[i].stop\n            ) {\n              activeLedColor = sectionPixels[i].color\n              break\n            }\n          }\n        }\n        // Has LED color changed? If so redraw the buffer\n        if (\n          lastActiveLedColor.medium.getHexColor() !==\n          activeLedColor.medium.getHexColor()\n        ) {\n          drawActiveLed(activeLedContext, activeLedColor)\n          lastActiveLedColor = activeLedColor\n        }\n        // Draw LED\n        ctx.translate(0, -translateY)\n        ctx.drawImage(activeLedBuffer, ledX, ledY)\n        ctx.translate(0, translateY)\n      }\n    } else {\n      // Draw the inactive leds\n      inactiveLeds = fullSize\n      for (\n        translateX = -(ledW / 2);\n        translateX <= inactiveLeds;\n        translateX += ledW + 1\n      ) {\n        ctx.translate(translateX, 0)\n        ctx.drawImage(inActiveLedBuffer, ledX, ledY)\n        ctx.translate(-translateX, 0)\n      }\n      // Draw the active leds in dependence on the current value\n      activeLeds = ((value - minValue) / (maxValue - minValue)) * fullSize\n      for (\n        translateX = -(ledW / 2);\n        translateX <= activeLeds;\n        translateX += ledW + 1\n      ) {\n        // check for LED color\n        activeLedColor = valueColor\n        if (isGradientVisible) {\n          // Convert pixel back to value\n          currentValue =\n            minValue + (translateX / fullSize) * (maxValue - minValue)\n          gradRange = valueGradient.getEnd() - valueGradient.getStart()\n          fraction = (currentValue - minValue) / gradRange\n          fraction = Math.max(Math.min(fraction, 1), 0)\n          activeLedColor = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"customColorDef\"])(\n            valueGradient.getColorAt(fraction).getRgbaColor()\n          )\n        } else if (isSectionsVisible) {\n          for (i = 0; i < sectionPixels.length; i++) {\n            if (\n              translateX >= sectionPixels[i].start &&\n              translateX < sectionPixels[i].stop\n            ) {\n              activeLedColor = sectionPixels[i].color\n              break\n            }\n          }\n        }\n        // Has LED color changed? If so redraw the buffer\n        if (\n          lastActiveLedColor.medium.getHexColor() !==\n          activeLedColor.medium.getHexColor()\n        ) {\n          drawActiveLed(activeLedContext, activeLedColor)\n          lastActiveLedColor = activeLedColor\n        }\n        ctx.translate(translateX, 0)\n        ctx.drawImage(activeLedBuffer, ledX, ledY)\n        ctx.translate(-translateX, 0)\n      }\n    }\n  }\n\n  const drawInActiveLed = function (ctx) {\n    ctx.save()\n    ctx.beginPath()\n    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    ctx.closePath()\n    const ledCenterX = ctx.canvas.width / 2\n    const ledCenterY = ctx.canvas.height / 2\n    const ledGradient = mainCtx.createRadialGradient(\n      ledCenterX,\n      ledCenterY,\n      0,\n      ledCenterX,\n      ledCenterY,\n      ctx.canvas.width / 2\n    )\n    ledGradient.addColorStop(0, '#3c3c3c')\n    ledGradient.addColorStop(1, '#323232')\n    ctx.fillStyle = ledGradient\n    ctx.fill()\n    ctx.restore()\n  }\n\n  const drawActiveLed = function (ctx, color) {\n    ctx.save()\n    ctx.beginPath()\n    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    ctx.closePath()\n    const ledCenterX = ctx.canvas.width / 2\n    const ledCenterY = ctx.canvas.height / 2\n    let outerRadius\n    if (vertical) {\n      outerRadius = ctx.canvas.width / 2\n    } else {\n      outerRadius = ctx.canvas.height / 2\n    }\n    const ledGradient = mainCtx.createRadialGradient(\n      ledCenterX,\n      ledCenterY,\n      0,\n      ledCenterX,\n      ledCenterY,\n      outerRadius\n    )\n    ledGradient.addColorStop(0, color.light.getRgbaColor())\n    ledGradient.addColorStop(1, color.dark.getRgbaColor())\n    ctx.fillStyle = ledGradient\n    ctx.fill()\n    ctx.restore()\n  }\n\n  //* *********************************** Public methods **************************************\n  this.setValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    if (value !== targetValue) {\n      value = targetValue\n\n      if (value > maxMeasuredValue) {\n        maxMeasuredValue = value\n      }\n      if (value < minMeasuredValue) {\n        minMeasuredValue = value\n      }\n\n      if (\n        (value >= threshold && !ledBlinking && thresholdRising) ||\n        (value <= threshold && !ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = true\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.play()\n        }\n      } else if (\n        (value < threshold && ledBlinking && thresholdRising) ||\n        (value > threshold && ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = false\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.pause()\n        }\n      }\n\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.setValueAnimated = function (newValue, callback) {\n    const gauge = this\n    let time\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n\n    if (value !== targetValue) {\n      if (undefined !== tween && tween.isPlaying) {\n        tween.stop()\n      }\n\n      time =\n        (fullScaleDeflectionTime * Math.abs(targetValue - value)) /\n        (maxValue - minValue)\n      time = Math.max(time, fullScaleDeflectionTime / 5)\n      tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n        {},\n        '',\n        _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n        value,\n        targetValue,\n        time\n      )\n      // tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n      // tween = new Tween(new Object(), '', Tween.strongEaseInOut, value, targetValue, 1);\n      tween.onMotionChanged = function (event) {\n        value = event.target._pos\n\n        if (\n          (value >= threshold && !ledBlinking && thresholdRising) ||\n          (value <= threshold && !ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = true\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.play()\n          }\n        } else if (\n          (value < threshold && ledBlinking && thresholdRising) ||\n          (value > threshold && ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = false\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.pause()\n          }\n        }\n\n        if (value > maxMeasuredValue) {\n          maxMeasuredValue = value\n        }\n        if (value < minMeasuredValue) {\n          minMeasuredValue = value\n        }\n\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tween.onMotionFinished = callback\n      }\n\n      tween.start()\n    }\n    return this\n  }\n\n  this.resetMinMeasuredValue = function () {\n    minMeasuredValue = value\n    this.repaint()\n    return this\n  }\n\n  this.resetMaxMeasuredValue = function () {\n    maxMeasuredValue = value\n    this.repaint()\n    return this\n  }\n\n  this.setMinMeasuredValueVisible = function (visible) {\n    minMeasuredValueVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setMaxMeasuredValueVisible = function (visible) {\n    maxMeasuredValueVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setThresholdVisible = function (visible) {\n    thresholdVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setThresholdRising = function (rising) {\n    thresholdRising = !!rising\n    // reset existing threshold alerts\n    ledBlinking = !ledBlinking\n    blink(ledBlinking)\n    this.repaint()\n    return this\n  }\n\n  this.setLcdDecimals = function (decimals) {\n    lcdDecimals = parseInt(decimals, 10)\n    this.repaint()\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers({\n      frame: true\n    })\n    frameDesign = newFrameDesign\n    init({\n      frame: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers({\n      background: true\n    })\n    backgroundColor = newBackgroundColor\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setValueColor = function (newValueColor) {\n    resetBuffers({\n      bargraphled: true\n    })\n    valueColor = newValueColor\n    init({\n      bargraphled: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLedColor = function (newLedColor) {\n    resetBuffers({\n      led: true\n    })\n    ledColor = newLedColor\n    init({\n      led: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLedVisible = function (visible) {\n    ledVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setLcdColor = function (newLcdColor) {\n    lcdColor = newLcdColor\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setSection = function (areaSec) {\n    section = areaSec\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setSectionActive = function (value) {\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setGradient = function (grad) {\n    valueGradient = grad\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setGradientActive = function (value) {\n    useValueGradient = value\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setMaxMeasuredValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    if (maxMeasuredValue !== targetValue) {\n      maxMeasuredValue = targetValue\n      this.repaint()\n    }\n    return this\n  }\n\n  this.setMinMeasuredValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    if (minMeasuredValue !== targetValue) {\n      minMeasuredValue = targetValue\n      this.repaint()\n    }\n    return this\n  }\n\n  this.setTitleString = function (title) {\n    titleString = title\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setUnitString = function (unit) {\n    unitString = unit\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setMinValue = function (newValue) {\n    minValue = parseFloat(newValue)\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMinValue = function () {\n    return minValue\n  }\n\n  this.setMaxValue = function (newValue) {\n    maxValue = parseFloat(newValue)\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMaxValue = function () {\n    return maxValue\n  }\n\n  this.setThreshold = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    if (threshold !== targetValue) {\n      threshold = targetValue\n      resetBuffers({\n        background: true\n      })\n      init({\n        background: true\n      })\n      this.repaint()\n    }\n    return this\n  }\n\n  this.setThresholdVisible = function (visible) {\n    thresholdVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init({\n        frame: true,\n        background: true,\n        led: true,\n        pointer: true,\n        foreground: true,\n        bargraphled: true\n      })\n    }\n\n    // mainCtx.save();\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    // Draw frame\n    if (frameVisible) {\n      mainCtx.drawImage(frameBuffer, 0, 0)\n    }\n\n    // Draw buffered image to visible canvas\n    if (backgroundVisible) {\n      mainCtx.drawImage(backgroundBuffer, 0, 0)\n    }\n\n    // Draw lcd display\n    if (lcdVisible) {\n      drawLcdText(mainCtx, value, vertical)\n    }\n\n    // Draw led\n    if (ledVisible) {\n      mainCtx.drawImage(ledBuffer, ledPosX, ledPosY)\n    }\n    let valuePos\n    let minMaxX\n    let minMaxY\n    // Draw min measured value indicator\n    if (minMeasuredValueVisible) {\n      if (vertical) {\n        valuePos =\n          imageHeight * 0.856796 -\n          (imageHeight * 0.728155 * (minMeasuredValue - minValue)) /\n            (maxValue - minValue)\n        minMaxX = imageWidth * 0.34 - minMeasuredValueBuffer.width\n        minMaxY = valuePos - minMeasuredValueBuffer.height / 2\n      } else {\n        valuePos =\n          ((imageWidth * 0.856796 - imageWidth * 0.12864) *\n            (minMeasuredValue - minValue)) /\n          (maxValue - minValue)\n        minMaxX =\n          imageWidth * 0.142857 - minMeasuredValueBuffer.height / 2 + valuePos\n        minMaxY = imageHeight * 0.65\n      }\n      mainCtx.drawImage(minMeasuredValueBuffer, minMaxX, minMaxY)\n    }\n\n    // Draw max measured value indicator\n    if (maxMeasuredValueVisible) {\n      if (vertical) {\n        valuePos =\n          imageHeight * 0.856796 -\n          (imageHeight * 0.728155 * (maxMeasuredValue - minValue)) /\n            (maxValue - minValue)\n        minMaxX = imageWidth * 0.34 - maxMeasuredValueBuffer.width\n        minMaxY = valuePos - maxMeasuredValueBuffer.height / 2\n      } else {\n        valuePos =\n          ((imageWidth * 0.856796 - imageWidth * 0.12864) *\n            (maxMeasuredValue - minValue)) /\n          (maxValue - minValue)\n        minMaxX =\n          imageWidth * 0.142857 - maxMeasuredValueBuffer.height / 2 + valuePos\n        minMaxY = imageHeight * 0.65\n      }\n      mainCtx.drawImage(maxMeasuredValueBuffer, minMaxX, minMaxY)\n    }\n\n    mainCtx.save()\n    drawValue(mainCtx, imageWidth, imageHeight)\n    mainCtx.restore()\n\n    // Draw foreground\n    if (foregroundVisible) {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LinearBargraph);\n\n\n//# sourceURL=webpack://steelseries/./src/LinearBargraph.js?");

/***/ }),

/***/ "./src/Odometer.js":
/*!*************************!*\
  !*** ./src/Odometer.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\n\nconst Odometer = function (canvas, parameters) {\n  parameters = parameters || {}\n\n  // parameters\n  const _context =\n    undefined === parameters._context ? null : parameters._context\n  let height = undefined === parameters.height ? 0 : parameters.height\n  const digits = undefined === parameters.digits ? 6 : parameters.digits\n  const decimals = undefined === parameters.decimals ? 1 : parameters.decimals\n  const decimalBackColor =\n    undefined === parameters.decimalBackColor\n      ? '#F0F0F0'\n      : parameters.decimalBackColor\n  const decimalForeColor =\n    undefined === parameters.decimalForeColor\n      ? '#F01010'\n      : parameters.decimalForeColor\n  const font = undefined === parameters.font ? 'sans-serif' : parameters.font\n  let value = undefined === parameters.value ? 0 : parameters.value\n  const valueBackColor =\n    undefined === parameters.valueBackColor\n      ? '#050505'\n      : parameters.valueBackColor\n  const valueForeColor =\n    undefined === parameters.valueForeColor\n      ? '#F8F8F8'\n      : parameters.valueForeColor\n  const wobbleFactor =\n    undefined === parameters.wobbleFactor ? 0.07 : parameters.wobbleFactor\n  //\n  let initialized = false\n  let tween\n  let ctx\n  let repainting = false\n  const wobble = []\n  // End of variables\n\n  // Get the canvas context and clear it\n  if (_context) {\n    ctx = _context\n  } else {\n    ctx = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"getCanvasContext\"])(canvas)\n  }\n\n  // Has a height been specified?\n  if (height === 0) {\n    height = ctx.canvas.height\n  }\n\n  // Cannot display negative values yet\n  if (value < 0) {\n    value = 0\n  }\n\n  const digitHeight = Math.floor(height * 0.85)\n  const stdFont = '600 ' + digitHeight + 'px ' + font\n\n  const digitWidth = Math.floor(height * 0.68)\n  const width = digitWidth * (digits + decimals)\n  const columnHeight = digitHeight * 11\n  const verticalSpace = columnHeight / 12\n  const zeroOffset = verticalSpace * 0.81\n\n  // Resize and clear the main context\n  ctx.canvas.width = width\n  ctx.canvas.height = height\n\n  // Create buffers\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"createBuffer\"])(width, height)\n  const backgroundContext = backgroundBuffer.getContext('2d')\n\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"createBuffer\"])(width, height)\n  const foregroundContext = foregroundBuffer.getContext('2d')\n\n  const digitBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"createBuffer\"])(digitWidth, columnHeight * 1.1)\n  const digitContext = digitBuffer.getContext('2d')\n\n  const decimalBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"createBuffer\"])(digitWidth, columnHeight * 1.1)\n  const decimalContext = decimalBuffer.getContext('2d')\n\n  function init () {\n    let i\n\n    initialized = true\n\n    // Create the foreground\n    foregroundContext.rect(0, 0, width, height)\n    const grad = foregroundContext.createLinearGradient(0, 0, 0, height)\n    grad.addColorStop(0, 'rgba(0, 0, 0, 1)')\n    grad.addColorStop(0.1, 'rgba(0, 0, 0, 0.4)')\n    grad.addColorStop(0.33, 'rgba(255, 255, 255, 0.45)')\n    grad.addColorStop(0.46, 'rgba(255, 255, 255, 0)')\n    grad.addColorStop(0.9, 'rgba(0, 0, 0, 0.4)')\n    grad.addColorStop(1, 'rgba(0, 0, 0, 1)')\n    foregroundContext.fillStyle = grad\n    foregroundContext.fill()\n\n    // Create a digit column\n    // background\n    digitContext.rect(0, 0, digitWidth, columnHeight * 1.1)\n    digitContext.fillStyle = valueBackColor\n    digitContext.fill()\n    // edges\n    digitContext.strokeStyle = '#f0f0f0'\n    digitContext.lineWidth = '1px' // height * 0.1 + 'px';\n    digitContext.moveTo(0, 0)\n    digitContext.lineTo(0, columnHeight * 1.1)\n    digitContext.stroke()\n    digitContext.strokeStyle = '#202020'\n    digitContext.moveTo(digitWidth, 0)\n    digitContext.lineTo(digitWidth, columnHeight * 1.1)\n    digitContext.stroke()\n    // numerals\n    digitContext.textAlign = 'center'\n    digitContext.textBaseline = 'middle'\n    digitContext.font = stdFont\n    digitContext.fillStyle = valueForeColor\n    // put the digits 901234567890 vertically into the buffer\n    for (i = 9; i < 21; i++) {\n      digitContext.fillText(\n        i % 10,\n        digitWidth * 0.5,\n        verticalSpace * (i - 9) + verticalSpace / 2\n      )\n    }\n\n    // Create a decimal column\n    if (decimals > 0) {\n      // background\n      decimalContext.rect(0, 0, digitWidth, columnHeight * 1.1)\n      decimalContext.fillStyle = decimalBackColor\n      decimalContext.fill()\n      // edges\n      decimalContext.strokeStyle = '#f0f0f0'\n      decimalContext.lineWidth = '1px' // height * 0.1 + 'px';\n      decimalContext.moveTo(0, 0)\n      decimalContext.lineTo(0, columnHeight * 1.1)\n      decimalContext.stroke()\n      decimalContext.strokeStyle = '#202020'\n      decimalContext.moveTo(digitWidth, 0)\n      decimalContext.lineTo(digitWidth, columnHeight * 1.1)\n      decimalContext.stroke()\n      // numerals\n      decimalContext.textAlign = 'center'\n      decimalContext.textBaseline = 'middle'\n      decimalContext.font = stdFont\n      decimalContext.fillStyle = decimalForeColor\n      // put the digits 901234567890 vertically into the buffer\n      for (i = 9; i < 21; i++) {\n        decimalContext.fillText(\n          i % 10,\n          digitWidth * 0.5,\n          verticalSpace * (i - 9) + verticalSpace / 2\n        )\n      }\n    }\n    // wobble factors\n    for (i = 0; i < digits + decimals; i++) {\n      wobble[i] =\n        Math.random() * wobbleFactor * height - (wobbleFactor * height) / 2\n    }\n  }\n\n  function drawDigits () {\n    let pos = 1\n    let val = value\n    let i\n    let num\n    let numb\n    let frac\n    let prevNum\n\n    // do not use Math.pow() - rounding errors!\n    for (i = 0; i < decimals; i++) {\n      val *= 10\n    }\n\n    numb = Math.floor(val)\n    frac = val - numb\n    numb = String(numb)\n    prevNum = 9\n\n    for (i = 0; i < decimals + digits; i++) {\n      num = +numb.substring(numb.length - i - 1, numb.length - i) || 0\n      if (prevNum !== 9) {\n        frac = 0\n      }\n      if (i < decimals) {\n        backgroundContext.drawImage(\n          decimalBuffer,\n          width - digitWidth * pos,\n          -(verticalSpace * (num + frac) + zeroOffset + wobble[i])\n        )\n      } else {\n        backgroundContext.drawImage(\n          digitBuffer,\n          width - digitWidth * pos,\n          -(verticalSpace * (num + frac) + zeroOffset + wobble[i])\n        )\n      }\n      pos++\n      prevNum = num\n    }\n  }\n\n  this.setValueAnimated = function (newVal, callback) {\n    const gauge = this\n    newVal = parseFloat(newVal)\n\n    if (newVal < 0) {\n      newVal = 0\n    }\n    if (value !== newVal) {\n      if (undefined !== tween && tween.isPlaying) {\n        tween.stop()\n      }\n\n      tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({}, '', _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].strongEaseOut, value, newVal, 2)\n      tween.onMotionChanged = function (event) {\n        value = event.target._pos\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tween.onMotionFinished = callback\n      }\n\n      tween.start()\n    }\n    this.repaint()\n    return this\n  }\n\n  this.setValue = function (newVal) {\n    value = parseFloat(newVal)\n    if (value < 0) {\n      value = 0\n    }\n    this.repaint()\n    return this\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init()\n    }\n\n    // draw digits\n    drawDigits()\n\n    // draw the foreground\n    backgroundContext.drawImage(foregroundBuffer, 0, 0)\n\n    // paint back to the main context\n    ctx.drawImage(backgroundBuffer, 0, 0)\n\n    repainting = false\n  }\n\n  this.repaint()\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Odometer);\n\n\n//# sourceURL=webpack://steelseries/./src/Odometer.js?");

/***/ }),

/***/ "./src/Radial.js":
/*!***********************!*\
  !*** ./src/Radial.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawPointerImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawPointerImage */ \"./src/drawPointerImage.js\");\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony import */ var _drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawRadialCustomImage */ \"./src/drawRadialCustomImage.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _createKnobImage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createKnobImage */ \"./src/createKnobImage.js\");\n/* harmony import */ var _createLedImage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./createLedImage */ \"./src/createLedImage.js\");\n/* harmony import */ var _createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./createLcdBackgroundImage */ \"./src/createLcdBackgroundImage.js\");\n/* harmony import */ var _createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createMeasuredValueImage */ \"./src/createMeasuredValueImage.js\");\n/* harmony import */ var _createTrendIndicator__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./createTrendIndicator */ \"./src/createTrendIndicator.js\");\n/* harmony import */ var _drawTitleImage__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./drawTitleImage */ \"./src/drawTitleImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n/* harmony import */ var _Odometer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Odometer */ \"./src/Odometer.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Radial = function (canvas, parameters) {\n  parameters = parameters || {}\n  const gaugeType =\n    undefined === parameters.gaugeType ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"GaugeType\"].TYPE4 : parameters.gaugeType\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let minValue = undefined === parameters.minValue ? 0 : parameters.minValue\n  let maxValue =\n    undefined === parameters.maxValue ? minValue + 100 : parameters.maxValue\n  const niceScale =\n    undefined === parameters.niceScale ? true : parameters.niceScale\n  let threshold =\n    undefined === parameters.threshold\n      ? (maxValue - minValue) / 2 + minValue\n      : parameters.threshold\n  let thresholdRising =\n    undefined === parameters.thresholdRising\n      ? true\n      : parameters.thresholdRising\n  let section = undefined === parameters.section ? null : parameters.section\n  let area = undefined === parameters.area ? null : parameters.area\n  let titleString =\n    undefined === parameters.titleString ? '' : parameters.titleString\n  let unitString =\n    undefined === parameters.unitString ? '' : parameters.unitString\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"BackgroundColor\"].DARK_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let pointerType =\n    undefined === parameters.pointerType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"PointerType\"].TYPE1\n      : parameters.pointerType\n  let pointerColor =\n    undefined === parameters.pointerColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"ColorDef\"].RED\n      : parameters.pointerColor\n  const knobType =\n    undefined === parameters.knobType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"KnobType\"].STANDARD_KNOB\n      : parameters.knobType\n  const knobStyle =\n    undefined === parameters.knobStyle\n      ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"KnobStyle\"].SILVER\n      : parameters.knobStyle\n  let lcdColor =\n    undefined === parameters.lcdColor ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"LcdColor\"].STANDARD : parameters.lcdColor\n  const lcdVisible =\n    undefined === parameters.lcdVisible ? true : parameters.lcdVisible\n  let lcdDecimals =\n    undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals\n  const digitalFont =\n    undefined === parameters.digitalFont ? false : parameters.digitalFont\n  let fractionalScaleDecimals =\n    undefined === parameters.fractionalScaleDecimals\n      ? 1\n      : parameters.fractionalScaleDecimals\n  let ledColor =\n    undefined === parameters.ledColor ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"LedColor\"].RED_LED : parameters.ledColor\n  let ledVisible =\n    undefined === parameters.ledVisible ? true : parameters.ledVisible\n  let userLedColor =\n    undefined === parameters.userLedColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"LedColor\"].GREEN_LED\n      : parameters.userLedColor\n  let userLedVisible =\n    undefined === parameters.userLedVisible ? false : parameters.userLedVisible\n  let thresholdVisible =\n    undefined === parameters.thresholdVisible\n      ? true\n      : parameters.thresholdVisible\n  let minMeasuredValueVisible =\n    undefined === parameters.minMeasuredValueVisible\n      ? false\n      : parameters.minMeasuredValueVisible\n  let maxMeasuredValueVisible =\n    undefined === parameters.maxMeasuredValueVisible\n      ? false\n      : parameters.maxMeasuredValueVisible\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  let labelNumberFormat =\n    undefined === parameters.labelNumberFormat\n      ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"LabelNumberFormat\"].STANDARD\n      : parameters.labelNumberFormat\n  const playAlarm =\n    undefined === parameters.playAlarm ? false : parameters.playAlarm\n  const alarmSound =\n    undefined === parameters.alarmSound ? false : parameters.alarmSound\n  const customLayer =\n    undefined === parameters.customLayer ? null : parameters.customLayer\n  const tickLabelOrientation =\n    undefined === parameters.tickLabelOrientation\n      ? gaugeType === _definitions__WEBPACK_IMPORTED_MODULE_13__[\"GaugeType\"].TYPE1\n        ? _definitions__WEBPACK_IMPORTED_MODULE_13__[\"TickLabelOrientation\"].TANGENT\n        : _definitions__WEBPACK_IMPORTED_MODULE_13__[\"TickLabelOrientation\"].NORMAL\n      : parameters.tickLabelOrientation\n  let trendVisible =\n    undefined === parameters.trendVisible ? false : parameters.trendVisible\n  const trendColors =\n    undefined === parameters.trendColors\n      ? [_definitions__WEBPACK_IMPORTED_MODULE_13__[\"LedColor\"].RED_LED, _definitions__WEBPACK_IMPORTED_MODULE_13__[\"LedColor\"].GREEN_LED, _definitions__WEBPACK_IMPORTED_MODULE_13__[\"LedColor\"].CYAN_LED]\n      : parameters.trendColors\n  const useOdometer =\n    undefined === parameters.useOdometer ? false : parameters.useOdometer\n  const odometerParams =\n    undefined === parameters.odometerParams ? {} : parameters.odometerParams\n  const odometerUseValue =\n    undefined === parameters.odometerUseValue\n      ? false\n      : parameters.odometerUseValue\n  const fullScaleDeflectionTime =\n    undefined === parameters.fullScaleDeflectionTime\n      ? 2.5\n      : parameters.fullScaleDeflectionTime\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (size === 0) {\n    size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height)\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  // Create audio tag for alarm sound\n  let audioElement\n  if (playAlarm && alarmSound !== false) {\n    audioElement = _tools__WEBPACK_IMPORTED_MODULE_12__[\"doc\"].createElement('audio')\n    audioElement.setAttribute('src', alarmSound)\n    audioElement.setAttribute('preload', 'auto')\n  }\n\n  let value = minValue\n  let odoValue = minValue\n  const self = this\n\n  // Properties\n  let minMeasuredValue = maxValue\n  let maxMeasuredValue = minValue\n\n  let ledBlinking = false\n  let userLedBlinking = false\n\n  let ledTimerId = 0\n  let userLedTimerId = 0\n  let tween\n  let repainting = false\n\n  let trendIndicator = _definitions__WEBPACK_IMPORTED_MODULE_13__[\"TrendState\"].OFF\n  const trendSize = size * 0.06\n  const trendPosX = size * 0.29\n  const trendPosY = size * 0.36\n\n  // GaugeType specific private variables\n  let freeAreaAngle\n  let rotationOffset\n  let angleRange\n  let angleStep\n\n  let angle = rotationOffset + (value - minValue) * angleStep\n\n  const imageWidth = size\n  const imageHeight = size\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight / 2\n\n  // Misc\n  const ledSize = size * 0.093457\n  const ledPosX = 0.6 * imageWidth\n  const ledPosY = 0.4 * imageHeight\n  const userLedPosX =\n    gaugeType === _definitions__WEBPACK_IMPORTED_MODULE_13__[\"GaugeType\"].TYPE3 ? 0.6 * imageWidth : centerX - ledSize / 2\n  const userLedPosY =\n    gaugeType === _definitions__WEBPACK_IMPORTED_MODULE_13__[\"GaugeType\"].TYPE3 ? 0.72 * imageHeight : 0.75 * imageHeight\n  const lcdFontHeight = Math.floor(imageWidth / 10)\n  const stdFont = lcdFontHeight + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_12__[\"stdFontName\"]\n  const lcdFont = lcdFontHeight + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_12__[\"lcdFontName\"]\n  const lcdHeight = imageHeight * 0.13\n  const lcdWidth = imageWidth * 0.4\n  const lcdPosX = (imageWidth - lcdWidth) / 2\n  const lcdPosY = imageHeight * 0.57\n  let odoPosX\n  const odoPosY = imageHeight * 0.61\n  const shadowOffset = imageWidth * 0.006\n\n  // Constants\n  let initialized = false\n\n  // Tickmark specific private variables\n  let niceMinValue = minValue\n  let niceMaxValue = maxValue\n  let niceRange = maxValue - minValue\n  let range = niceMaxValue - niceMinValue\n  let minorTickSpacing = 0\n  let majorTickSpacing = 0\n  const maxNoOfMinorTicks = 10\n  const maxNoOfMajorTicks = 10\n\n  // Method to calculate nice values for min, max and range for the tickmarks\n  const calculate = function calculate () {\n    if (niceScale) {\n      niceRange = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"calcNiceNumber\"])(maxValue - minValue, false)\n      majorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"calcNiceNumber\"])(\n        niceRange / (maxNoOfMajorTicks - 1),\n        true\n      )\n      niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing\n      niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing\n      minorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"calcNiceNumber\"])(\n        majorTickSpacing / (maxNoOfMinorTicks - 1),\n        true\n      )\n      minValue = niceMinValue\n      maxValue = niceMaxValue\n      range = maxValue - minValue\n    } else {\n      niceRange = maxValue - minValue\n      niceMinValue = minValue\n      niceMaxValue = maxValue\n      range = niceRange\n      majorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"calcNiceNumber\"])(\n        niceRange / (maxNoOfMajorTicks - 1),\n        true\n      )\n      minorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"calcNiceNumber\"])(\n        majorTickSpacing / (maxNoOfMinorTicks - 1),\n        true\n      )\n    }\n    // Make sure values are still in range\n    value = value < minValue ? minValue : value > maxValue ? maxValue : value\n    minMeasuredValue =\n      minMeasuredValue < minValue\n        ? minValue\n        : minMeasuredValue > maxValue\n          ? maxValue\n          : minMeasuredValue\n    maxMeasuredValue =\n      maxMeasuredValue < minValue\n        ? minValue\n        : maxMeasuredValue > maxValue\n          ? maxValue\n          : maxMeasuredValue\n    threshold =\n      threshold < minValue\n        ? minValue\n        : threshold > maxValue\n          ? maxValue\n          : threshold\n\n    switch (gaugeType.type) {\n      case 'type1':\n        freeAreaAngle = 0\n        rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_12__[\"PI\"]\n        angleRange = _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"]\n        angleStep = angleRange / range\n        break\n\n      case 'type2':\n        freeAreaAngle = 0\n        rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_12__[\"PI\"]\n        angleRange = _tools__WEBPACK_IMPORTED_MODULE_12__[\"PI\"]\n        angleStep = angleRange / range\n        break\n\n      case 'type3':\n        freeAreaAngle = 0\n        rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"]\n        angleRange = 1.5 * _tools__WEBPACK_IMPORTED_MODULE_12__[\"PI\"]\n        angleStep = angleRange / range\n        break\n\n      case 'type4':\n      /* falls through */\n      default:\n        freeAreaAngle = 60 * _tools__WEBPACK_IMPORTED_MODULE_12__[\"RAD_FACTOR\"]\n        rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"] + freeAreaAngle / 2\n        angleRange = _tools__WEBPACK_IMPORTED_MODULE_12__[\"TWO_PI\"] - freeAreaAngle\n        angleStep = angleRange / range\n        break\n    }\n    angle = rotationOffset + (value - minValue) * angleStep\n  }\n\n  // **************   Buffer creation  ********************\n  // Buffer for the frame\n  const frameBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(size, size)\n  let frameContext = frameBuffer.getContext('2d')\n\n  // Buffer for the background\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(size, size)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  let lcdBuffer\n\n  // Buffer for led on painting code\n  const ledBufferOn = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(ledSize, ledSize)\n  let ledContextOn = ledBufferOn.getContext('2d')\n\n  // Buffer for led off painting code\n  const ledBufferOff = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(ledSize, ledSize)\n  let ledContextOff = ledBufferOff.getContext('2d')\n\n  // Buffer for current led painting code\n  let ledBuffer = ledBufferOff\n\n  // Buffer for user led on painting code\n  const userLedBufferOn = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(ledSize, ledSize)\n  let userLedContextOn = userLedBufferOn.getContext('2d')\n\n  // Buffer for user led off painting code\n  const userLedBufferOff = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(ledSize, ledSize)\n  let userLedContextOff = userLedBufferOff.getContext('2d')\n\n  // Buffer for current user led painting code\n  let userLedBuffer = userLedBufferOff\n\n  // Buffer for the minMeasuredValue indicator\n  const minMeasuredValueBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(\n    Math.ceil(size * 0.028037),\n    Math.ceil(size * 0.028037)\n  )\n  const minMeasuredValueCtx = minMeasuredValueBuffer.getContext('2d')\n\n  // Buffer for the maxMeasuredValue indicator\n  const maxMeasuredValueBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(\n    Math.ceil(size * 0.028037),\n    Math.ceil(size * 0.028037)\n  )\n  const maxMeasuredValueCtx = maxMeasuredValueBuffer.getContext('2d')\n\n  // Buffer for pointer image painting code\n  const pointerBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(size, size)\n  let pointerContext = pointerBuffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(size, size)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  // Buffers for trend indicators\n  let trendUpBuffer\n  let trendSteadyBuffer\n  let trendDownBuffer\n  let trendOffBuffer\n\n  // Buffer for odometer\n  let odoGauge\n  let odoBuffer\n  let odoContext\n  if (useOdometer && lcdVisible) {\n    odoBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"createBuffer\"])(10, 10) // size doesn't matter, it will get reset by odometer code\n    odoContext = odoBuffer.getContext('2d')\n  }\n\n  // **************   Image creation  ********************\n  const drawLcdText = function (ctx, value) {\n    ctx.restore()\n    ctx.save()\n    ctx.textAlign = 'right'\n    ctx.strokeStyle = lcdColor.textColor\n    ctx.fillStyle = lcdColor.textColor\n\n    if (\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_13__[\"LcdColor\"].STANDARD ||\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_13__[\"LcdColor\"].STANDARD_GREEN\n    ) {\n      ctx.shadowColor = 'gray'\n      ctx.shadowOffsetX = imageWidth * 0.007\n      ctx.shadowOffsetY = imageWidth * 0.007\n      ctx.shadowBlur = imageWidth * 0.007\n    }\n    if (digitalFont) {\n      ctx.font = lcdFont\n    } else {\n      ctx.font = stdFont\n    }\n    ctx.fillText(\n      value.toFixed(lcdDecimals),\n      lcdPosX + lcdWidth - lcdWidth * 0.05,\n      lcdPosY + lcdHeight * 0.5 + lcdFontHeight * 0.38,\n      lcdWidth * 0.9\n    )\n\n    ctx.restore()\n  }\n\n  const drawPostsImage = function (ctx) {\n    ctx.save()\n\n    if (gaugeType.type === 'type1') {\n      // Draw max center top post\n      ctx.drawImage(\n        Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n          Math.ceil(imageHeight * 0.037383),\n          _definitions__WEBPACK_IMPORTED_MODULE_13__[\"KnobType\"].STANDARD_KNOB,\n          knobStyle\n        ),\n        imageWidth * 0.523364,\n        imageHeight * 0.130841\n      )\n    }\n\n    if (gaugeType.type === 'type1' || gaugeType.type === 'type2') {\n      // Draw min left post\n      ctx.drawImage(\n        Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n          Math.ceil(imageHeight * 0.037383),\n          _definitions__WEBPACK_IMPORTED_MODULE_13__[\"KnobType\"].STANDARD_KNOB,\n          knobStyle\n        ),\n        imageWidth * 0.130841,\n        imageHeight * 0.514018\n      )\n    }\n\n    if (gaugeType.type === 'type2' || gaugeType.type === 'type3') {\n      // Draw max right post\n      ctx.drawImage(\n        Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n          Math.ceil(imageHeight * 0.037383),\n          _definitions__WEBPACK_IMPORTED_MODULE_13__[\"KnobType\"].STANDARD_KNOB,\n          knobStyle\n        ),\n        imageWidth * 0.831775,\n        imageHeight * 0.514018\n      )\n    }\n\n    if (gaugeType.type === 'type3') {\n      // Draw min center bottom post\n      ctx.drawImage(\n        Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n          Math.ceil(imageHeight * 0.037383),\n          _definitions__WEBPACK_IMPORTED_MODULE_13__[\"KnobType\"].STANDARD_KNOB,\n          knobStyle\n        ),\n        imageWidth * 0.523364,\n        imageHeight * 0.831775\n      )\n    }\n\n    if (gaugeType.type === 'type4') {\n      // Min post\n      ctx.drawImage(\n        Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n          Math.ceil(imageHeight * 0.037383),\n          _definitions__WEBPACK_IMPORTED_MODULE_13__[\"KnobType\"].STANDARD_KNOB,\n          knobStyle\n        ),\n        imageWidth * 0.336448,\n        imageHeight * 0.803738\n      )\n\n      // Max post\n      ctx.drawImage(\n        Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\n          Math.ceil(imageHeight * 0.037383),\n          _definitions__WEBPACK_IMPORTED_MODULE_13__[\"KnobType\"].STANDARD_KNOB,\n          knobStyle\n        ),\n        imageWidth * 0.626168,\n        imageHeight * 0.803738\n      )\n    }\n\n    ctx.restore()\n  }\n\n  const createThresholdImage = function () {\n    const thresholdBuffer = _tools__WEBPACK_IMPORTED_MODULE_12__[\"doc\"].createElement('canvas')\n    thresholdBuffer.width = Math.ceil(size * 0.046728)\n    thresholdBuffer.height = Math.ceil(thresholdBuffer.width * 0.9)\n    const thresholdCtx = thresholdBuffer.getContext('2d')\n\n    thresholdCtx.save()\n    const gradThreshold = thresholdCtx.createLinearGradient(\n      0,\n      0.1,\n      0,\n      thresholdBuffer.height * 0.9\n    )\n    gradThreshold.addColorStop(0, '#520000')\n    gradThreshold.addColorStop(0.3, '#fc1d00')\n    gradThreshold.addColorStop(0.59, '#fc1d00')\n    gradThreshold.addColorStop(1, '#520000')\n    thresholdCtx.fillStyle = gradThreshold\n\n    thresholdCtx.beginPath()\n    thresholdCtx.moveTo(thresholdBuffer.width * 0.5, 0.1)\n    thresholdCtx.lineTo(\n      thresholdBuffer.width * 0.9,\n      thresholdBuffer.height * 0.9\n    )\n    thresholdCtx.lineTo(\n      thresholdBuffer.width * 0.1,\n      thresholdBuffer.height * 0.9\n    )\n    thresholdCtx.lineTo(thresholdBuffer.width * 0.5, 0.1)\n    thresholdCtx.closePath()\n\n    thresholdCtx.fill()\n    thresholdCtx.strokeStyle = '#FFFFFF'\n    thresholdCtx.stroke()\n\n    thresholdCtx.restore()\n\n    return thresholdBuffer\n  }\n\n  const drawAreaSectionImage = function (ctx, start, stop, color, filled) {\n    if (start < minValue) {\n      start = minValue\n    } else if (start > maxValue) {\n      start = maxValue\n    }\n    if (stop < minValue) {\n      stop = minValue\n    } else if (stop > maxValue) {\n      stop = maxValue\n    }\n    if (start >= stop) {\n      return\n    }\n    ctx.save()\n    ctx.strokeStyle = color\n    ctx.fillStyle = color\n    ctx.lineWidth = imageWidth * 0.035\n    const startAngle =\n      (angleRange / range) * start - (angleRange / range) * minValue\n    const stopAngle = startAngle + (stop - start) / (range / angleRange)\n    ctx.translate(centerX, centerY)\n    ctx.rotate(rotationOffset)\n    ctx.beginPath()\n    if (filled) {\n      ctx.moveTo(0, 0)\n      ctx.arc(\n        0,\n        0,\n        imageWidth * 0.365 - ctx.lineWidth / 2,\n        startAngle,\n        stopAngle,\n        false\n      )\n    } else {\n      ctx.arc(0, 0, imageWidth * 0.365, startAngle, stopAngle, false)\n    }\n    if (filled) {\n      ctx.moveTo(0, 0)\n      ctx.fill()\n    } else {\n      ctx.stroke()\n    }\n\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  const drawTickmarksImage = function (ctx, labelNumberFormat) {\n    const fontSize = Math.ceil(imageWidth * 0.04)\n    let alpha = rotationOffset // Tracks total rotation\n    const rotationStep = angleStep * minorTickSpacing\n    let textRotationAngle\n    let valueCounter = minValue\n    let majorTickCounter = maxNoOfMinorTicks - 1\n    const OUTER_POINT = imageWidth * 0.38\n    const MAJOR_INNER_POINT = imageWidth * 0.35\n    const MED_INNER_POINT = imageWidth * 0.355\n    const MINOR_INNER_POINT = imageWidth * 0.36\n    const TEXT_TRANSLATE_X = imageWidth * 0.3\n    let TEXT_WIDTH = imageWidth * 0.1\n    const HALF_MAX_NO_OF_MINOR_TICKS = maxNoOfMinorTicks / 2\n    const MAX_VALUE_ROUNDED = parseFloat(maxValue.toFixed(2))\n    let i\n\n    backgroundColor.labelColor.setAlpha(1)\n    ctx.save()\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.font = fontSize + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_12__[\"stdFontName\"]\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.translate(centerX, centerY)\n    ctx.rotate(rotationOffset)\n\n    if (gaugeType.type === 'type1' || gaugeType.type === 'type2') {\n      TEXT_WIDTH = imageWidth * 0.04\n    }\n\n    for (\n      i = minValue;\n      parseFloat(i.toFixed(2)) <= MAX_VALUE_ROUNDED;\n      i += minorTickSpacing\n    ) {\n      textRotationAngle = rotationStep + _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"]\n      majorTickCounter++\n      // Draw major tickmarks\n      if (majorTickCounter === maxNoOfMinorTicks) {\n        ctx.lineWidth = 1.5\n        ctx.beginPath()\n        ctx.moveTo(OUTER_POINT, 0)\n        ctx.lineTo(MAJOR_INNER_POINT, 0)\n        ctx.closePath()\n        ctx.stroke()\n        ctx.save()\n        ctx.translate(TEXT_TRANSLATE_X, 0)\n\n        switch (tickLabelOrientation.type) {\n          case 'horizontal':\n            textRotationAngle = -alpha\n            break\n\n          case 'tangent':\n            textRotationAngle = alpha <= _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"] + _tools__WEBPACK_IMPORTED_MODULE_12__[\"PI\"] ? _tools__WEBPACK_IMPORTED_MODULE_12__[\"PI\"] : 0\n            break\n\n          case 'normal':\n          /* falls through */\n          default:\n            textRotationAngle = _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"]\n            break\n        }\n        ctx.rotate(textRotationAngle)\n\n        switch (labelNumberFormat.format) {\n          case 'fractional':\n            ctx.fillText(\n              valueCounter.toFixed(fractionalScaleDecimals),\n              0,\n              0,\n              TEXT_WIDTH\n            )\n            break\n\n          case 'scientific':\n            ctx.fillText(valueCounter.toPrecision(2), 0, 0, TEXT_WIDTH)\n            break\n\n          case 'standard':\n          /* falls through */\n          default:\n            ctx.fillText(valueCounter.toFixed(0), 0, 0, TEXT_WIDTH)\n            break\n        }\n        ctx.translate(-TEXT_TRANSLATE_X, 0)\n        ctx.restore()\n\n        valueCounter += majorTickSpacing\n        majorTickCounter = 0\n        ctx.rotate(rotationStep)\n        alpha += rotationStep\n        continue\n      }\n\n      // Draw tickmark every minor tickmark spacing\n      if (\n        maxNoOfMinorTicks % 2 === 0 &&\n        majorTickCounter === HALF_MAX_NO_OF_MINOR_TICKS\n      ) {\n        ctx.lineWidth = 1\n        ctx.beginPath()\n        ctx.moveTo(OUTER_POINT, 0)\n        ctx.lineTo(MED_INNER_POINT, 0)\n        ctx.closePath()\n        ctx.stroke()\n      } else {\n        ctx.lineWidth = 0.5\n        ctx.beginPath()\n        ctx.moveTo(OUTER_POINT, 0)\n        ctx.lineTo(MINOR_INNER_POINT, 0)\n        ctx.closePath()\n        ctx.stroke()\n      }\n      ctx.rotate(rotationStep)\n      alpha += rotationStep\n    }\n\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  // **************   Initialization  ********************\n  // Draw all static painting code to background\n  const init = function (parameters) {\n    parameters = parameters || {}\n    const drawFrame2 =\n      undefined === parameters.frame ? false : parameters.frame\n    const drawBackground2 =\n      undefined === parameters.background ? false : parameters.background\n    const drawLed = undefined === parameters.led ? false : parameters.led\n    const drawUserLed =\n      undefined === parameters.userLed ? false : parameters.userLed\n    const drawPointer =\n      undefined === parameters.pointer ? false : parameters.pointer\n    const drawForeground2 =\n      undefined === parameters.foreground ? false : parameters.foreground\n    const drawTrend = undefined === parameters.trend ? false : parameters.trend\n    const drawOdo = undefined === parameters.odo ? false : parameters.odo\n\n    initialized = true\n\n    // Calculate the current min and max values and the range\n    calculate()\n\n    // Create frame in frame buffer (backgroundBuffer)\n    if (drawFrame2 && frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        frameContext,\n        frameDesign,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    // Create background in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      Object(_drawBackground__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      // Create custom layer in background buffer (backgroundBuffer)\n      Object(_drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(\n        backgroundContext,\n        customLayer,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    if (drawLed) {\n      // Draw LED ON in ledBuffer_ON\n      ledContextOn.drawImage(\n        Object(_createLedImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(Math.ceil(size * 0.093457), 1, ledColor),\n        0,\n        0\n      )\n\n      // Draw LED OFF in ledBuffer_OFF\n      ledContextOff.drawImage(\n        Object(_createLedImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(Math.ceil(size * 0.093457), 0, ledColor),\n        0,\n        0\n      )\n    }\n\n    if (drawUserLed) {\n      // Draw user LED ON in userLedBuffer_ON\n      userLedContextOn.drawImage(\n        Object(_createLedImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(Math.ceil(size * 0.093457), 1, userLedColor),\n        0,\n        0\n      )\n\n      // Draw user LED OFF in userLedBuffer_OFF\n      userLedContextOff.drawImage(\n        Object(_createLedImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(Math.ceil(size * 0.093457), 0, userLedColor),\n        0,\n        0\n      )\n    }\n\n    // Draw min measured value indicator in minMeasuredValueBuffer\n    if (minMeasuredValueVisible) {\n      minMeasuredValueCtx.drawImage(\n        Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(\n          Math.ceil(size * 0.028037),\n          _definitions__WEBPACK_IMPORTED_MODULE_13__[\"ColorDef\"].BLUE.dark.getRgbaColor(),\n          true,\n          true\n        ),\n        0,\n        0\n      )\n    }\n\n    // Draw max measured value indicator in maxMeasuredValueBuffer\n    if (maxMeasuredValueVisible) {\n      maxMeasuredValueCtx.drawImage(\n        Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(\n          Math.ceil(size * 0.028037),\n          _definitions__WEBPACK_IMPORTED_MODULE_13__[\"ColorDef\"].RED.medium.getRgbaColor(),\n          true\n        ),\n        0,\n        0\n      )\n    }\n\n    // Create alignment posts in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      drawPostsImage(backgroundContext)\n\n      // Create section in background buffer (backgroundBuffer)\n      if (section !== null && section.length > 0) {\n        let sectionIndex = section.length\n        do {\n          sectionIndex--\n          drawAreaSectionImage(\n            backgroundContext,\n            section[sectionIndex].start,\n            section[sectionIndex].stop,\n            section[sectionIndex].color,\n            false\n          )\n        } while (sectionIndex > 0)\n      }\n\n      // Create area in background buffer (backgroundBuffer)\n      if (area !== null && area.length > 0) {\n        let areaIndex = area.length\n        do {\n          areaIndex--\n          drawAreaSectionImage(\n            backgroundContext,\n            area[areaIndex].start,\n            area[areaIndex].stop,\n            area[areaIndex].color,\n            true\n          )\n        } while (areaIndex > 0)\n      }\n\n      // Create tickmarks in background buffer (backgroundBuffer)\n      drawTickmarksImage(backgroundContext, labelNumberFormat)\n\n      // Create title in background buffer (backgroundBuffer)\n      Object(_drawTitleImage__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(\n        backgroundContext,\n        imageWidth,\n        imageHeight,\n        titleString,\n        unitString,\n        backgroundColor,\n        true,\n        true\n      )\n    }\n\n    // Draw threshold image to background context\n    if (drawBackground2 && thresholdVisible) {\n      backgroundContext.save()\n      backgroundContext.translate(centerX, centerY)\n      backgroundContext.rotate(\n        rotationOffset + (threshold - minValue) * angleStep + _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"]\n      )\n      backgroundContext.translate(-centerX, -centerY)\n      backgroundContext.drawImage(\n        createThresholdImage(),\n        imageWidth * 0.475,\n        imageHeight * 0.13\n      )\n      backgroundContext.translate(centerX, centerY)\n      backgroundContext.restore()\n    }\n\n    // Create lcd background if selected in background buffer (backgroundBuffer)\n    if (drawBackground2 && lcdVisible) {\n      if (useOdometer && drawOdo) {\n        odoGauge = new _Odometer__WEBPACK_IMPORTED_MODULE_14__[\"default\"]('', {\n          _context: odoContext,\n          height: size * 0.075,\n          decimals: odometerParams.decimals,\n          digits:\n            odometerParams.digits === undefined ? 5 : odometerParams.digits,\n          valueForeColor: odometerParams.valueForeColor,\n          valueBackColor: odometerParams.valueBackColor,\n          decimalForeColor: odometerParams.decimalForeColor,\n          decimalBackColor: odometerParams.decimalBackColor,\n          font: odometerParams.font,\n          value: value\n        })\n        odoPosX = (imageWidth - odoBuffer.width) / 2\n      } else if (!useOdometer) {\n        lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(lcdWidth, lcdHeight, lcdColor)\n        backgroundContext.drawImage(lcdBuffer, lcdPosX, lcdPosY)\n      }\n    }\n\n    // Create pointer image in pointer buffer (contentBuffer)\n    if (drawPointer) {\n      Object(_drawPointerImage__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        pointerContext,\n        imageWidth,\n        pointerType,\n        pointerColor,\n        backgroundColor.labelColor\n      )\n    }\n\n    // Create foreground in foreground buffer (foregroundBuffer)\n    if (drawForeground2 && foregroundVisible) {\n      const knobVisible =\n        !(pointerType.type === 'type15' || pointerType.type === 'type16')\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        knobVisible,\n        knobType,\n        knobStyle,\n        gaugeType\n      )\n    }\n\n    // Create the trend indicator buffers\n    if (drawTrend && trendVisible) {\n      trendUpBuffer = Object(_createTrendIndicator__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(\n        trendSize,\n        _definitions__WEBPACK_IMPORTED_MODULE_13__[\"TrendState\"].UP,\n        trendColors\n      )\n      trendSteadyBuffer = Object(_createTrendIndicator__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(\n        trendSize,\n        _definitions__WEBPACK_IMPORTED_MODULE_13__[\"TrendState\"].STEADY,\n        trendColors\n      )\n      trendDownBuffer = Object(_createTrendIndicator__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(\n        trendSize,\n        _definitions__WEBPACK_IMPORTED_MODULE_13__[\"TrendState\"].DOWN,\n        trendColors\n      )\n      trendOffBuffer = Object(_createTrendIndicator__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(\n        trendSize,\n        _definitions__WEBPACK_IMPORTED_MODULE_13__[\"TrendState\"].OFF,\n        trendColors\n      )\n    }\n  }\n\n  const resetBuffers = function (buffers) {\n    buffers = buffers || {}\n    const resetFrame = undefined === buffers.frame ? false : buffers.frame\n    const resetBackground =\n      undefined === buffers.background ? false : buffers.background\n    const resetLed = undefined === buffers.led ? false : buffers.led\n    const resetUserLed =\n      undefined === buffers.userLed ? false : buffers.userLed\n    const resetPointer =\n      undefined === buffers.pointer ? false : buffers.pointer\n    const resetForeground =\n      undefined === buffers.foreground ? false : buffers.foreground\n\n    if (resetFrame) {\n      frameBuffer.width = size\n      frameBuffer.height = size\n      frameContext = frameBuffer.getContext('2d')\n    }\n\n    if (resetBackground) {\n      backgroundBuffer.width = size\n      backgroundBuffer.height = size\n      backgroundContext = backgroundBuffer.getContext('2d')\n    }\n\n    if (resetLed) {\n      ledBufferOn.width = Math.ceil(size * 0.093457)\n      ledBufferOn.height = Math.ceil(size * 0.093457)\n      ledContextOn = ledBufferOn.getContext('2d')\n\n      ledBufferOff.width = Math.ceil(size * 0.093457)\n      ledBufferOff.height = Math.ceil(size * 0.093457)\n      ledContextOff = ledBufferOff.getContext('2d')\n\n      // Buffer for current led painting code\n      ledBuffer = ledBufferOff\n    }\n\n    if (resetUserLed) {\n      userLedBufferOn.width = Math.ceil(size * 0.093457)\n      userLedBufferOn.height = Math.ceil(size * 0.093457)\n      userLedContextOn = userLedBufferOn.getContext('2d')\n\n      userLedBufferOff.width = Math.ceil(size * 0.093457)\n      userLedBufferOff.height = Math.ceil(size * 0.093457)\n      userLedContextOff = userLedBufferOff.getContext('2d')\n\n      // Buffer for current user led painting code\n      userLedBuffer = userLedBufferOff\n    }\n\n    if (resetPointer) {\n      pointerBuffer.width = size\n      pointerBuffer.height = size\n      pointerContext = pointerBuffer.getContext('2d')\n    }\n\n    if (resetForeground) {\n      foregroundBuffer.width = size\n      foregroundBuffer.height = size\n      foregroundContext = foregroundBuffer.getContext('2d')\n    }\n  }\n\n  const toggleAndRepaintLed = function () {\n    if (ledVisible) {\n      if (ledBuffer === ledBufferOn) {\n        ledBuffer = ledBufferOff\n      } else {\n        ledBuffer = ledBufferOn\n      }\n      if (!repainting) {\n        repainting = true\n        Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"requestAnimFrame\"])(self.repaint)\n      }\n    }\n  }\n\n  const toggleAndRepaintUserLed = function () {\n    if (userLedVisible) {\n      if (userLedBuffer === userLedBufferOn) {\n        userLedBuffer = userLedBufferOff\n      } else {\n        userLedBuffer = userLedBufferOn\n      }\n      if (!repainting) {\n        repainting = true\n        Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"requestAnimFrame\"])(self.repaint)\n      }\n    }\n  }\n\n  const blink = function (blinking) {\n    if (blinking) {\n      ledTimerId = setInterval(toggleAndRepaintLed, 1000)\n    } else {\n      clearInterval(ledTimerId)\n      ledBuffer = ledBufferOff\n    }\n  }\n\n  const blinkUser = function (blinking) {\n    if (blinking) {\n      userLedTimerId = setInterval(toggleAndRepaintUserLed, 1000)\n    } else {\n      clearInterval(userLedTimerId)\n      userLedBuffer = userLedBufferOff\n    }\n  }\n\n  //* *********************************** Public methods **************************************\n  this.setValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    if (value !== targetValue) {\n      value = targetValue\n\n      if (value > maxMeasuredValue) {\n        maxMeasuredValue = value\n      }\n      if (value < minMeasuredValue) {\n        minMeasuredValue = value\n      }\n\n      if (\n        (value >= threshold && !ledBlinking && thresholdRising) ||\n        (value <= threshold && !ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = true\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.play()\n        }\n      } else if (\n        (value < threshold && ledBlinking && thresholdRising) ||\n        (value > threshold && ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = false\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.pause()\n        }\n      }\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.setOdoValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue = newValue < 0 ? 0 : newValue\n    if (odoValue !== targetValue) {\n      odoValue = targetValue\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getOdoValue = function () {\n    return odoValue\n  }\n\n  this.setValueAnimated = function (newValue, callback) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    const gauge = this\n    let time\n\n    if (value !== targetValue) {\n      if (undefined !== tween && tween.isPlaying) {\n        tween.stop()\n      }\n      time =\n        (fullScaleDeflectionTime * Math.abs(targetValue - value)) /\n        (maxValue - minValue)\n      time = Math.max(time, fullScaleDeflectionTime / 5)\n      tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n        {},\n        '',\n        _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n        value,\n        targetValue,\n        time\n      )\n      // tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n      // tween = new Tween(new Object(), '', Tween.strongEaseInOut, value, targetValue, 1);\n\n      tween.onMotionChanged = function (event) {\n        value = event.target._pos\n\n        if (\n          (value >= threshold && !ledBlinking && thresholdRising) ||\n          (value <= threshold && !ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = true\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.play()\n          }\n        } else if (\n          (value < threshold && ledBlinking && thresholdRising) ||\n          (value > threshold && ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = false\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.pause()\n          }\n        }\n\n        if (value > maxMeasuredValue) {\n          maxMeasuredValue = value\n        }\n        if (value < minMeasuredValue) {\n          minMeasuredValue = value\n        }\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_12__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tween.onMotionFinished = callback\n      }\n\n      tween.start()\n    }\n    return this\n  }\n\n  this.resetMinMeasuredValue = function () {\n    minMeasuredValue = value\n    this.repaint()\n  }\n\n  this.resetMaxMeasuredValue = function () {\n    maxMeasuredValue = value\n    this.repaint()\n    return this\n  }\n\n  this.setMinMeasuredValueVisible = function (visible) {\n    minMeasuredValueVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setMaxMeasuredValueVisible = function (visible) {\n    maxMeasuredValueVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setMaxMeasuredValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    maxMeasuredValue = targetValue\n    this.repaint()\n    return this\n  }\n\n  this.setMinMeasuredValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    minMeasuredValue = targetValue\n    this.repaint()\n    return this\n  }\n\n  this.setTitleString = function (title) {\n    titleString = title\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setUnitString = function (unit) {\n    unitString = unit\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setMinValue = function (newValue) {\n    minValue = parseFloat(newValue)\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMinValue = function () {\n    return minValue\n  }\n\n  this.setMaxValue = function (newValue) {\n    maxValue = parseFloat(newValue)\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMaxValue = function () {\n    return maxValue\n  }\n\n  this.setThreshold = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    threshold = targetValue\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setArea = function (areaVal) {\n    area = areaVal\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setSection = function (areaSec) {\n    section = areaSec\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setThresholdVisible = function (visible) {\n    thresholdVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setThresholdRising = function (rising) {\n    thresholdRising = !!rising\n    // reset existing threshold alerts\n    ledBlinking = !ledBlinking\n    blink(ledBlinking)\n    this.repaint()\n    return this\n  }\n\n  this.setLcdDecimals = function (decimals) {\n    lcdDecimals = parseInt(decimals, 10)\n    this.repaint()\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers({\n      frame: true\n    })\n    frameDesign = newFrameDesign\n    init({\n      frame: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers({\n      background: true,\n      pointer:\n        !!(pointerType.type === 'type2' || pointerType.type === 'type13') // type2 & 13 depend on background\n    })\n    backgroundColor = newBackgroundColor\n    init({\n      background: true, // type2 & 13 depend on background\n      pointer:\n        !!(pointerType.type === 'type2' || pointerType.type === 'type13')\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers({\n      foreground: true\n    })\n    foregroundType = newForegroundType\n    init({\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerType = function (newPointerType) {\n    resetBuffers({\n      pointer: true,\n      foreground: true\n    })\n    pointerType = newPointerType\n    init({\n      pointer: true,\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerColor = function (newPointerColor) {\n    resetBuffers({\n      pointer: true\n    })\n    pointerColor = newPointerColor\n    init({\n      pointer: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLedColor = function (newLedColor) {\n    resetBuffers({\n      led: true\n    })\n    ledColor = newLedColor\n    init({\n      led: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setUserLedColor = function (newLedColor) {\n    resetBuffers({\n      userLed: true\n    })\n    userLedColor = newLedColor\n    init({\n      userLed: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.toggleUserLed = function () {\n    if (userLedBuffer === userLedBufferOn) {\n      userLedBuffer = userLedBufferOff\n    } else {\n      userLedBuffer = userLedBufferOn\n    }\n    this.repaint()\n    return this\n  }\n\n  this.setUserLedOnOff = function (on) {\n    if (on === true) {\n      userLedBuffer = userLedBufferOn\n    } else {\n      userLedBuffer = userLedBufferOff\n    }\n    this.repaint()\n    return this\n  }\n\n  this.blinkUserLed = function (blink) {\n    if (blink) {\n      if (!userLedBlinking) {\n        blinkUser(true)\n        userLedBlinking = true\n      }\n    } else {\n      if (userLedBlinking) {\n        clearInterval(userLedTimerId)\n        userLedBlinking = false\n      }\n    }\n    return this\n  }\n\n  this.setLedVisible = function (visible) {\n    ledVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setUserLedVisible = function (visible) {\n    userLedVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setLcdColor = function (newLcdColor) {\n    lcdColor = newLcdColor\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setTrend = function (newValue) {\n    trendIndicator = newValue\n    this.repaint()\n    return this\n  }\n\n  this.setTrendVisible = function (visible) {\n    trendVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setFractionalScaleDecimals = function (decimals) {\n    fractionalScaleDecimals = parseInt(decimals, 10)\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLabelNumberFormat = function (format) {\n    labelNumberFormat = format\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init({\n        frame: true,\n        background: true,\n        led: true,\n        userLed: true,\n        pointer: true,\n        trend: true,\n        foreground: true,\n        odo: true\n      })\n    }\n    mainCtx.clearRect(0, 0, size, size)\n\n    // Draw frame\n    if (frameVisible) {\n      mainCtx.drawImage(frameBuffer, 0, 0)\n    }\n\n    // Draw buffered image to visible canvas\n    mainCtx.drawImage(backgroundBuffer, 0, 0)\n\n    // Draw lcd display\n    if (lcdVisible) {\n      if (useOdometer) {\n        odoGauge.setValue(odometerUseValue ? value : odoValue)\n        mainCtx.drawImage(odoBuffer, odoPosX, odoPosY)\n      } else {\n        drawLcdText(mainCtx, value)\n      }\n    }\n\n    // Draw led\n    if (ledVisible) {\n      mainCtx.drawImage(ledBuffer, ledPosX, ledPosY)\n    }\n\n    // Draw user led\n    if (userLedVisible) {\n      mainCtx.drawImage(userLedBuffer, userLedPosX, userLedPosY)\n    }\n\n    // Draw the trend indicator\n    if (trendVisible) {\n      switch (trendIndicator.state) {\n        case 'up':\n          mainCtx.drawImage(trendUpBuffer, trendPosX, trendPosY)\n          break\n        case 'steady':\n          mainCtx.drawImage(trendSteadyBuffer, trendPosX, trendPosY)\n          break\n        case 'down':\n          mainCtx.drawImage(trendDownBuffer, trendPosX, trendPosY)\n          break\n        case 'off':\n          mainCtx.drawImage(trendOffBuffer, trendPosX, trendPosY)\n          break\n      }\n    }\n\n    // Draw min measured value indicator\n    if (minMeasuredValueVisible) {\n      mainCtx.save()\n      mainCtx.translate(centerX, centerY)\n      mainCtx.rotate(\n        rotationOffset + _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"] + (minMeasuredValue - minValue) * angleStep\n      )\n      mainCtx.translate(-centerX, -centerY)\n      mainCtx.drawImage(\n        minMeasuredValueBuffer,\n        mainCtx.canvas.width * 0.4865,\n        mainCtx.canvas.height * 0.105\n      )\n      mainCtx.restore()\n    }\n\n    // Draw max measured value indicator\n    if (maxMeasuredValueVisible) {\n      mainCtx.save()\n      mainCtx.translate(centerX, centerY)\n      mainCtx.rotate(\n        rotationOffset + _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"] + (maxMeasuredValue - minValue) * angleStep\n      )\n      mainCtx.translate(-centerX, -centerY)\n      mainCtx.drawImage(\n        maxMeasuredValueBuffer,\n        mainCtx.canvas.width * 0.4865,\n        mainCtx.canvas.height * 0.105\n      )\n      mainCtx.restore()\n    }\n\n    angle = rotationOffset + _tools__WEBPACK_IMPORTED_MODULE_12__[\"HALF_PI\"] + (value - minValue) * angleStep\n\n    // Define rotation center\n    mainCtx.save()\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(angle)\n    mainCtx.translate(-centerX, -centerY)\n    // Set the pointer shadow params\n    mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset\n    mainCtx.shadowBlur = shadowOffset * 2\n    // Draw the pointer\n    mainCtx.drawImage(pointerBuffer, 0, 0)\n    // Undo the translations & shadow settings\n    mainCtx.restore()\n\n    // Draw foreground\n    if (foregroundVisible) {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Radial);\n\n\n//# sourceURL=webpack://steelseries/./src/Radial.js?");

/***/ }),

/***/ "./src/RadialBargraph.js":
/*!*******************************!*\
  !*** ./src/RadialBargraph.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony import */ var _drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawRadialCustomImage */ \"./src/drawRadialCustomImage.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _createLedImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createLedImage */ \"./src/createLedImage.js\");\n/* harmony import */ var _createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createLcdBackgroundImage */ \"./src/createLcdBackgroundImage.js\");\n/* harmony import */ var _createTrendIndicator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./createTrendIndicator */ \"./src/createTrendIndicator.js\");\n/* harmony import */ var _drawTitleImage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./drawTitleImage */ \"./src/drawTitleImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst RadialBargraph = function (canvas, parameters) {\n  parameters = parameters || {}\n  const gaugeType =\n    undefined === parameters.gaugeType ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"GaugeType\"].TYPE4 : parameters.gaugeType\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let minValue = undefined === parameters.minValue ? 0 : parameters.minValue\n  let maxValue =\n    undefined === parameters.maxValue ? minValue + 100 : parameters.maxValue\n  const niceScale =\n    undefined === parameters.niceScale ? true : parameters.niceScale\n  let threshold =\n    undefined === parameters.threshold\n      ? (maxValue - minValue) / 2 + minValue\n      : parameters.threshold\n  let thresholdRising =\n    undefined === parameters.thresholdRising\n      ? true\n      : parameters.thresholdRising\n  let section = undefined === parameters.section ? null : parameters.section\n  let useSectionColors =\n    undefined === parameters.useSectionColors\n      ? false\n      : parameters.useSectionColors\n  let titleString =\n    undefined === parameters.titleString ? '' : parameters.titleString\n  let unitString =\n    undefined === parameters.unitString ? '' : parameters.unitString\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"BackgroundColor\"].DARK_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let valueColor =\n    undefined === parameters.valueColor ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"ColorDef\"].RED : parameters.valueColor\n  let lcdColor =\n    undefined === parameters.lcdColor ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"LcdColor\"].STANDARD : parameters.lcdColor\n  const lcdVisible =\n    undefined === parameters.lcdVisible ? true : parameters.lcdVisible\n  let lcdDecimals =\n    undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals\n  const digitalFont =\n    undefined === parameters.digitalFont ? false : parameters.digitalFont\n  let fractionalScaleDecimals =\n    undefined === parameters.fractionalScaleDecimals\n      ? 1\n      : parameters.fractionalScaleDecimals\n  const customLayer =\n    undefined === parameters.customLayer ? null : parameters.customLayer\n  let ledColor =\n    undefined === parameters.ledColor ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"LedColor\"].RED_LED : parameters.ledColor\n  let ledVisible =\n    undefined === parameters.ledVisible ? true : parameters.ledVisible\n  let userLedColor =\n    undefined === parameters.userLedColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"LedColor\"].GREEN_LED\n      : parameters.userLedColor\n  let userLedVisible =\n    undefined === parameters.userLedVisible ? false : parameters.userLedVisible\n  let labelNumberFormat =\n    undefined === parameters.labelNumberFormat\n      ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"LabelNumberFormat\"].STANDARD\n      : parameters.labelNumberFormat\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  const playAlarm =\n    undefined === parameters.playAlarm ? false : parameters.playAlarm\n  const alarmSound =\n    undefined === parameters.alarmSound ? false : parameters.alarmSound\n  let valueGradient =\n    undefined === parameters.valueGradient ? null : parameters.valueGradient\n  let useValueGradient =\n    undefined === parameters.useValueGradient\n      ? false\n      : parameters.useValueGradient\n  const tickLabelOrientation =\n    undefined === parameters.tickLabelOrientation\n      ? gaugeType === _definitions__WEBPACK_IMPORTED_MODULE_10__[\"GaugeType\"].TYPE1\n        ? _definitions__WEBPACK_IMPORTED_MODULE_10__[\"TickLabelOrientation\"].TANGENT\n        : _definitions__WEBPACK_IMPORTED_MODULE_10__[\"TickLabelOrientation\"].NORMAL\n      : parameters.tickLabelOrientation\n  let trendVisible =\n    undefined === parameters.trendVisible ? false : parameters.trendVisible\n  const trendColors =\n    undefined === parameters.trendColors\n      ? [_definitions__WEBPACK_IMPORTED_MODULE_10__[\"LedColor\"].RED_LED, _definitions__WEBPACK_IMPORTED_MODULE_10__[\"LedColor\"].GREEN_LED, _definitions__WEBPACK_IMPORTED_MODULE_10__[\"LedColor\"].CYAN_LED]\n      : parameters.trendColors\n  const fullScaleDeflectionTime =\n    undefined === parameters.fullScaleDeflectionTime\n      ? 2.5\n      : parameters.fullScaleDeflectionTime\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (size === 0) {\n    size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height)\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  let audioElement\n\n  // Create audio tag for alarm sound\n  if (playAlarm && alarmSound !== false) {\n    audioElement = _tools__WEBPACK_IMPORTED_MODULE_9__[\"doc\"].createElement('audio')\n    audioElement.setAttribute('src', alarmSound)\n    audioElement.setAttribute('preload', 'auto')\n  }\n\n  let value = minValue\n  let minMeasuredValue = minValue\n  let maxMeasuredValue = maxValue\n  let range = maxValue - minValue\n  let ledBlinking = false\n  let ledTimerId = 0\n  let userLedBlinking = false\n  let userLedTimerId = 0\n  let tween\n  const self = this\n  let repainting = false\n\n  // GaugeType specific private variables\n  let freeAreaAngle\n  let rotationOffset\n  let bargraphOffset\n  let angleRange\n  let degAngleRange\n  let angleStep\n\n  let sectionAngles = []\n  let isSectionsVisible = false\n  let isGradientVisible = false\n\n  const imageWidth = size\n  const imageHeight = size\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight / 2\n\n  // Misc\n  const lcdFontHeight = Math.floor(imageWidth / 10)\n  const stdFont = lcdFontHeight + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_9__[\"stdFontName\"]\n  const lcdFont = lcdFontHeight + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_9__[\"lcdFontName\"]\n  const lcdHeight = imageHeight * 0.13\n  const lcdWidth = imageWidth * 0.4\n  const lcdPosX = (imageWidth - lcdWidth) / 2\n  const lcdPosY = imageHeight / 2 - lcdHeight / 2\n\n  // Constants\n  const ACTIVE_LED_POS_X = imageWidth * 0.116822\n  const ACTIVE_LED_POS_Y = imageWidth * 0.485981\n  const LED_SIZE = Math.ceil(size * 0.093457)\n  // let LED_POS_X = imageWidth * 0.453271;\n  const LED_POS_X = imageWidth * 0.53\n  const LED_POS_Y = imageHeight * 0.61\n  const USER_LED_POS_X =\n    gaugeType === _definitions__WEBPACK_IMPORTED_MODULE_10__[\"GaugeType\"].TYPE3 ? 0.7 * imageWidth : centerX - LED_SIZE / 2\n  const USER_LED_POS_Y =\n    gaugeType === _definitions__WEBPACK_IMPORTED_MODULE_10__[\"GaugeType\"].TYPE3 ? 0.61 * imageHeight : 0.75 * imageHeight\n\n  let trendIndicator = _definitions__WEBPACK_IMPORTED_MODULE_10__[\"TrendState\"].OFF\n  const trendSize = size * 0.06\n  const trendPosX = size * 0.38\n  const trendPosY = size * 0.57\n\n  switch (gaugeType.type) {\n    case 'type1':\n      freeAreaAngle = 0\n      rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"]\n      bargraphOffset = 0\n      angleRange = _tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"]\n      degAngleRange = angleRange * _tools__WEBPACK_IMPORTED_MODULE_9__[\"DEG_FACTOR\"]\n      angleStep = angleRange / range\n      break\n\n    case 'type2':\n      freeAreaAngle = 0\n      rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"]\n      bargraphOffset = 0\n      angleRange = _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"]\n      degAngleRange = angleRange * _tools__WEBPACK_IMPORTED_MODULE_9__[\"DEG_FACTOR\"]\n      angleStep = angleRange / range\n      break\n\n    case 'type3':\n      freeAreaAngle = 0\n      rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"]\n      bargraphOffset = -_tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"]\n      angleRange = 1.5 * _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"]\n      degAngleRange = angleRange * _tools__WEBPACK_IMPORTED_MODULE_9__[\"DEG_FACTOR\"]\n      angleStep = angleRange / range\n      break\n\n    case 'type4':\n    /* falls through */\n    default:\n      freeAreaAngle = 60 * _tools__WEBPACK_IMPORTED_MODULE_9__[\"RAD_FACTOR\"]\n      rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"] + freeAreaAngle / 2\n      bargraphOffset = -_tools__WEBPACK_IMPORTED_MODULE_9__[\"TWO_PI\"] / 6\n      angleRange = _tools__WEBPACK_IMPORTED_MODULE_9__[\"TWO_PI\"] - freeAreaAngle\n      degAngleRange = angleRange * _tools__WEBPACK_IMPORTED_MODULE_9__[\"DEG_FACTOR\"]\n      angleStep = angleRange / range\n      break\n  }\n\n  // Buffer for the frame\n  const frameBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"createBuffer\"])(size, size)\n  let frameContext = frameBuffer.getContext('2d')\n\n  // Buffer for static background painting code\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"createBuffer\"])(size, size)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  let lcdBuffer\n\n  // Buffer for active bargraph led\n  const activeLedBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"createBuffer\"])(\n    Math.ceil(size * 0.060747),\n    Math.ceil(size * 0.023364)\n  )\n  let activeLedContext = activeLedBuffer.getContext('2d')\n\n  // Buffer for led on painting code\n  const ledBufferOn = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"createBuffer\"])(LED_SIZE, LED_SIZE)\n  let ledContextOn = ledBufferOn.getContext('2d')\n\n  // Buffer for led off painting code\n  const ledBufferOff = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"createBuffer\"])(LED_SIZE, LED_SIZE)\n  let ledContextOff = ledBufferOff.getContext('2d')\n\n  // Buffer for current led painting code\n  let ledBuffer = ledBufferOff\n\n  // Buffer for user led on painting code\n  const userLedBufferOn = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"createBuffer\"])(LED_SIZE, LED_SIZE)\n  let userLedContextOn = userLedBufferOn.getContext('2d')\n\n  // Buffer for user led off painting code\n  const userLedBufferOff = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"createBuffer\"])(LED_SIZE, LED_SIZE)\n  let userLedContextOff = userLedBufferOff.getContext('2d')\n\n  // Buffer for current user led painting code\n  let userLedBuffer = userLedBufferOff\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"createBuffer\"])(size, size)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  // Buffers for trend indicators\n  let trendUpBuffer\n  let trendSteadyBuffer\n  let trendDownBuffer\n  let trendOffBuffer\n\n  let initialized = false\n\n  // Tickmark specific private variables\n  let niceMinValue = minValue\n  let niceMaxValue = maxValue\n  let niceRange = maxValue - minValue\n  range = niceMaxValue - niceMinValue\n  let minorTickSpacing = 0\n  let majorTickSpacing = 0\n  const maxNoOfMinorTicks = 10\n  const maxNoOfMajorTicks = 10\n\n  // Method to calculate nice values for min, max and range for the tickmarks\n  const calculate = function calculate () {\n    if (niceScale) {\n      niceRange = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"calcNiceNumber\"])(maxValue - minValue, false)\n      majorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"calcNiceNumber\"])(\n        niceRange / (maxNoOfMajorTicks - 1),\n        true\n      )\n      niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing\n      niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing\n      minorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"calcNiceNumber\"])(\n        majorTickSpacing / (maxNoOfMinorTicks - 1),\n        true\n      )\n      minValue = niceMinValue\n      maxValue = niceMaxValue\n      range = maxValue - minValue\n    } else {\n      niceRange = maxValue - minValue\n      niceMinValue = minValue\n      niceMaxValue = maxValue\n      range = niceRange\n      // minorTickSpacing = 1;\n      // majorTickSpacing = 10;\n      majorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"calcNiceNumber\"])(\n        niceRange / (maxNoOfMajorTicks - 1),\n        true\n      )\n      minorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"calcNiceNumber\"])(\n        majorTickSpacing / (maxNoOfMinorTicks - 1),\n        true\n      )\n    }\n    // Make sure values are still in range\n    value = value < minValue ? minValue : value > maxValue ? maxValue : value\n    minMeasuredValue =\n      minMeasuredValue < minValue\n        ? minValue\n        : minMeasuredValue > maxValue\n          ? maxValue\n          : minMeasuredValue\n    maxMeasuredValue =\n      maxMeasuredValue < minValue\n        ? minValue\n        : maxMeasuredValue > maxValue\n          ? maxValue\n          : maxMeasuredValue\n    threshold =\n      threshold < minValue\n        ? minValue\n        : threshold > maxValue\n          ? maxValue\n          : threshold\n\n    switch (gaugeType.type) {\n      case 'type1':\n        freeAreaAngle = 0\n        rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"]\n        angleRange = _tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"]\n        angleStep = angleRange / range\n        break\n\n      case 'type2':\n        freeAreaAngle = 0\n        rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"]\n        angleRange = _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"]\n        angleStep = angleRange / range\n        break\n\n      case 'type3':\n        freeAreaAngle = 0\n        rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"]\n        angleRange = 1.5 * _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"]\n        angleStep = angleRange / range\n        break\n\n      case 'type4': // fall through\n      /* falls through */\n      default:\n        freeAreaAngle = 60 * _tools__WEBPACK_IMPORTED_MODULE_9__[\"RAD_FACTOR\"]\n        rotationOffset = _tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"] + freeAreaAngle / 2\n        angleRange = _tools__WEBPACK_IMPORTED_MODULE_9__[\"TWO_PI\"] - freeAreaAngle\n        angleStep = angleRange / range\n        break\n    }\n  }\n\n  //* ******************************** Private methods *********************************\n  // Draw all static painting code to background\n  const init = function (parameters) {\n    parameters = parameters || {}\n    const drawFrame2 =\n      undefined === parameters.frame ? false : parameters.frame\n    const drawBackground2 =\n      undefined === parameters.background ? false : parameters.background\n    const drawLed = undefined === parameters.led ? false : parameters.led\n    const drawUserLed =\n      undefined === parameters.userLed ? false : parameters.userLed\n    const drawValue = undefined === parameters.value ? false : parameters.value\n    const drawForeground2 =\n      undefined === parameters.foreground ? false : parameters.foreground\n    const drawTrend = undefined === parameters.trend ? false : parameters.trend\n\n    initialized = true\n\n    calculate()\n\n    // Create frame in frame buffer (frameBuffer)\n    if (drawFrame2 && frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        frameContext,\n        frameDesign,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    // Create background in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      Object(_drawBackground__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      // Create custom layer in background buffer (backgroundBuffer)\n      Object(_drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        backgroundContext,\n        customLayer,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    if (drawLed) {\n      // Draw LED ON in ledBuffer_ON\n      ledContextOn.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(LED_SIZE, 1, ledColor), 0, 0)\n\n      // Draw LED OFF in ledBuffer_OFF\n      ledContextOff.drawImage(Object(_createLedImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(LED_SIZE, 0, ledColor), 0, 0)\n    }\n\n    if (drawUserLed) {\n      // Draw user LED ON in userLedBuffer_ON\n      userLedContextOn.drawImage(\n        Object(_createLedImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(Math.ceil(LED_SIZE), 1, userLedColor),\n        0,\n        0\n      )\n\n      // Draw user LED OFF in userLedBuffer_OFF\n      userLedContextOff.drawImage(\n        Object(_createLedImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(Math.ceil(LED_SIZE), 0, userLedColor),\n        0,\n        0\n      )\n    }\n\n    if (drawBackground2) {\n      // Create bargraphtrack in background buffer (backgroundBuffer)\n      drawBargraphTrackImage(backgroundContext)\n    }\n\n    // Create tickmarks in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      drawTickmarksImage(backgroundContext, labelNumberFormat)\n\n      // Create title in background buffer (backgroundBuffer)\n      Object(_drawTitleImage__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(\n        backgroundContext,\n        imageWidth,\n        imageHeight,\n        titleString,\n        unitString,\n        backgroundColor,\n        true,\n        true\n      )\n    }\n\n    // Create lcd background if selected in background buffer (backgroundBuffer)\n    if (drawBackground2 && lcdVisible) {\n      lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(lcdWidth, lcdHeight, lcdColor)\n      backgroundContext.drawImage(lcdBuffer, lcdPosX, lcdPosY)\n    }\n\n    // Convert Section values into angles\n    isSectionsVisible = false\n    if (useSectionColors && section !== null && section.length > 0) {\n      isSectionsVisible = true\n      let sectionIndex = section.length\n      sectionAngles = []\n      do {\n        sectionIndex--\n        sectionAngles.push({\n          start:\n            ((section[sectionIndex].start + Math.abs(minValue)) /\n              (maxValue - minValue)) *\n            degAngleRange,\n          stop:\n            ((section[sectionIndex].stop + Math.abs(minValue)) /\n              (maxValue - minValue)) *\n            degAngleRange,\n          color: Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"customColorDef\"])(section[sectionIndex].color)\n        })\n      } while (sectionIndex > 0)\n    }\n\n    // Use a gradient for the valueColor?\n    isGradientVisible = false\n    if (useValueGradient && valueGradient !== null) {\n      // force section colors off!\n      isSectionsVisible = false\n      isGradientVisible = true\n    }\n\n    // Create an image of an active led in active led buffer (activeLedBuffer)\n    if (drawValue) {\n      drawActiveLed(activeLedContext, valueColor)\n    }\n\n    // Create foreground in foreground buffer (foregroundBuffer)\n    if (drawForeground2 && foregroundVisible) {\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        false\n      )\n    }\n\n    // Create the trend indicator buffers\n    if (drawTrend && trendVisible) {\n      trendUpBuffer = Object(_createTrendIndicator__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n        trendSize,\n        _definitions__WEBPACK_IMPORTED_MODULE_10__[\"TrendState\"].UP,\n        trendColors\n      )\n      trendSteadyBuffer = Object(_createTrendIndicator__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n        trendSize,\n        _definitions__WEBPACK_IMPORTED_MODULE_10__[\"TrendState\"].STEADY,\n        trendColors\n      )\n      trendDownBuffer = Object(_createTrendIndicator__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n        trendSize,\n        _definitions__WEBPACK_IMPORTED_MODULE_10__[\"TrendState\"].DOWN,\n        trendColors\n      )\n      trendOffBuffer = Object(_createTrendIndicator__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n        trendSize,\n        _definitions__WEBPACK_IMPORTED_MODULE_10__[\"TrendState\"].OFF,\n        trendColors\n      )\n    }\n  }\n\n  const resetBuffers = function (buffers) {\n    buffers = buffers || {}\n    const resetFrame = undefined === buffers.frame ? false : buffers.frame\n    const resetBackground =\n      undefined === buffers.background ? false : buffers.background\n    const resetLed = undefined === buffers.led ? false : buffers.led\n    const resetUserLed =\n      undefined === buffers.userLed ? false : buffers.userLed\n    const resetValue = undefined === buffers.value ? false : buffers.value\n    const resetForeground =\n      undefined === buffers.foreground ? false : buffers.foreground\n\n    // Buffer for the frame\n    if (resetFrame) {\n      frameBuffer.width = size\n      frameBuffer.height = size\n      frameContext = frameBuffer.getContext('2d')\n    }\n\n    // Buffer for static background painting code\n    if (resetBackground) {\n      backgroundBuffer.width = size\n      backgroundBuffer.height = size\n      backgroundContext = backgroundBuffer.getContext('2d')\n    }\n\n    // Buffer for active bargraph led\n    if (resetValue) {\n      activeLedBuffer.width = Math.ceil(size * 0.060747)\n      activeLedBuffer.height = Math.ceil(size * 0.023364)\n      activeLedContext = activeLedBuffer.getContext('2d')\n    }\n\n    if (resetLed) {\n      // Buffer for led on painting code\n      ledBufferOn.width = Math.ceil(LED_SIZE)\n      ledBufferOn.height = Math.ceil(LED_SIZE)\n      ledContextOn = ledBufferOn.getContext('2d')\n\n      // Buffer for led off painting code\n      ledBufferOff.width = Math.ceil(LED_SIZE)\n      ledBufferOff.height = Math.ceil(LED_SIZE)\n      ledContextOff = ledBufferOff.getContext('2d')\n\n      // Buffer for current led painting code\n      ledBuffer = ledBufferOff\n    }\n\n    if (resetUserLed) {\n      userLedBufferOn.width = Math.ceil(LED_SIZE)\n      userLedBufferOn.height = Math.ceil(LED_SIZE)\n      userLedContextOn = userLedBufferOn.getContext('2d')\n\n      userLedBufferOff.width = Math.ceil(LED_SIZE)\n      userLedBufferOff.height = Math.ceil(LED_SIZE)\n      userLedContextOff = userLedBufferOff.getContext('2d')\n\n      // Buffer for current user led painting code\n      userLedBuffer = userLedBufferOff\n    }\n\n    // Buffer for static foreground painting code\n    if (resetForeground) {\n      foregroundBuffer.width = size\n      foregroundBuffer.height = size\n      foregroundContext = foregroundBuffer.getContext('2d')\n    }\n  }\n\n  const drawBargraphTrackImage = function (ctx) {\n    ctx.save()\n\n    // Bargraphtrack\n\n    // Frame\n    ctx.save()\n    ctx.lineWidth = size * 0.085\n    ctx.beginPath()\n    ctx.translate(centerX, centerY)\n    ctx.rotate(rotationOffset - 4 * _tools__WEBPACK_IMPORTED_MODULE_9__[\"RAD_FACTOR\"])\n    ctx.translate(-centerX, -centerY)\n    ctx.arc(\n      centerX,\n      centerY,\n      imageWidth * 0.35514,\n      0,\n      angleRange + 8 * _tools__WEBPACK_IMPORTED_MODULE_9__[\"RAD_FACTOR\"],\n      false\n    )\n    ctx.rotate(-rotationOffset)\n    const ledTrackFrameGradient = ctx.createLinearGradient(\n      0,\n      0.107476 * imageHeight,\n      0,\n      0.897195 * imageHeight\n    )\n    ledTrackFrameGradient.addColorStop(0, '#000000')\n    ledTrackFrameGradient.addColorStop(0.22, '#333333')\n    ledTrackFrameGradient.addColorStop(0.76, '#333333')\n    ledTrackFrameGradient.addColorStop(1, '#cccccc')\n    ctx.strokeStyle = ledTrackFrameGradient\n    ctx.stroke()\n    ctx.restore()\n\n    // Main\n    ctx.save()\n    ctx.lineWidth = size * 0.075\n    ctx.beginPath()\n    ctx.translate(centerX, centerY)\n    ctx.rotate(rotationOffset - 4 * _tools__WEBPACK_IMPORTED_MODULE_9__[\"RAD_FACTOR\"])\n    ctx.translate(-centerX, -centerY)\n    ctx.arc(\n      centerX,\n      centerY,\n      imageWidth * 0.35514,\n      0,\n      angleRange + 8 * _tools__WEBPACK_IMPORTED_MODULE_9__[\"RAD_FACTOR\"],\n      false\n    )\n    ctx.rotate(-rotationOffset)\n    const ledTrackMainGradient = ctx.createLinearGradient(\n      0,\n      0.112149 * imageHeight,\n      0,\n      0.892523 * imageHeight\n    )\n    ledTrackMainGradient.addColorStop(0, '#111111')\n    ledTrackMainGradient.addColorStop(1, '#333333')\n    ctx.strokeStyle = ledTrackMainGradient\n    ctx.stroke()\n    ctx.restore()\n\n    // Draw inactive leds\n    const ledCenterX = (imageWidth * 0.116822 + imageWidth * 0.060747) / 2\n    const ledCenterY = (imageWidth * 0.485981 + imageWidth * 0.023364) / 2\n    const ledOffGradient = ctx.createRadialGradient(\n      ledCenterX,\n      ledCenterY,\n      0,\n      ledCenterX,\n      ledCenterY,\n      0.030373 * imageWidth\n    )\n    ledOffGradient.addColorStop(0, '#3c3c3c')\n    ledOffGradient.addColorStop(1, '#323232')\n    let angle = 0\n    for (angle = 0; angle <= degAngleRange; angle += 5) {\n      ctx.save()\n      ctx.translate(centerX, centerY)\n      ctx.rotate(angle * _tools__WEBPACK_IMPORTED_MODULE_9__[\"RAD_FACTOR\"] + bargraphOffset)\n      ctx.translate(-centerX, -centerY)\n      ctx.beginPath()\n      ctx.rect(\n        imageWidth * 0.116822,\n        imageWidth * 0.485981,\n        imageWidth * 0.060747,\n        imageWidth * 0.023364\n      )\n      ctx.closePath()\n      ctx.fillStyle = ledOffGradient\n      ctx.fill()\n      ctx.restore()\n    }\n\n    ctx.restore()\n  }\n\n  const drawActiveLed = function (ctx, color) {\n    ctx.save()\n    ctx.beginPath()\n    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    ctx.closePath()\n    const ledCenterX = ctx.canvas.width / 2\n    const ledCenterY = ctx.canvas.height / 2\n    const ledGradient = mainCtx.createRadialGradient(\n      ledCenterX,\n      ledCenterY,\n      0,\n      ledCenterX,\n      ledCenterY,\n      ctx.canvas.width / 2\n    )\n    ledGradient.addColorStop(0, color.light.getRgbaColor())\n    ledGradient.addColorStop(1, color.dark.getRgbaColor())\n    ctx.fillStyle = ledGradient\n    ctx.fill()\n    ctx.restore()\n  }\n\n  const drawLcdText = function (ctx, value) {\n    ctx.save()\n    ctx.textAlign = 'right'\n    ctx.strokeStyle = lcdColor.textColor\n    ctx.fillStyle = lcdColor.textColor\n\n    if (\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_10__[\"LcdColor\"].STANDARD ||\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_10__[\"LcdColor\"].STANDARD_GREEN\n    ) {\n      ctx.shadowColor = 'gray'\n      ctx.shadowOffsetX = imageWidth * 0.007\n      ctx.shadowOffsetY = imageWidth * 0.007\n      ctx.shadowBlur = imageWidth * 0.007\n    }\n\n    if (digitalFont) {\n      ctx.font = lcdFont\n    } else {\n      ctx.font = stdFont\n    }\n    ctx.fillText(\n      value.toFixed(lcdDecimals),\n      lcdPosX + lcdWidth - lcdWidth * 0.05,\n      lcdPosY + lcdHeight * 0.5 + lcdFontHeight * 0.38,\n      lcdWidth * 0.9\n    )\n\n    ctx.restore()\n  }\n\n  const drawTickmarksImage = function (ctx, labelNumberFormat) {\n    let alpha = rotationOffset // Tracks total rotation\n    const rotationStep = angleStep * minorTickSpacing\n    let textRotationAngle\n    const fontSize = Math.ceil(imageWidth * 0.04)\n    let valueCounter = minValue\n    let majorTickCounter = maxNoOfMinorTicks - 1\n    const TEXT_TRANSLATE_X = imageWidth * 0.28\n    let TEXT_WIDTH = imageWidth * 0.1\n    const MAX_VALUE_ROUNDED = parseFloat(maxValue.toFixed(2))\n    let i\n\n    backgroundColor.labelColor.setAlpha(1)\n    ctx.save()\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.font = fontSize + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_9__[\"stdFontName\"]\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.translate(centerX, centerY)\n    ctx.rotate(rotationOffset)\n\n    if (gaugeType.type === 'type1' || gaugeType.type === 'type2') {\n      TEXT_WIDTH = imageWidth * 0.0375\n    }\n\n    for (\n      i = minValue;\n      parseFloat(i.toFixed(2)) <= MAX_VALUE_ROUNDED;\n      i += minorTickSpacing\n    ) {\n      textRotationAngle = +rotationStep + _tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"]\n      majorTickCounter++\n      // Draw major tickmarks\n      if (majorTickCounter === maxNoOfMinorTicks) {\n        ctx.save()\n        ctx.translate(TEXT_TRANSLATE_X, 0)\n\n        switch (tickLabelOrientation.type) {\n          case 'horizontal':\n            textRotationAngle = -alpha\n            break\n\n          case 'tangent':\n            textRotationAngle = alpha <= _tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"] + _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"] ? _tools__WEBPACK_IMPORTED_MODULE_9__[\"PI\"] : 0\n            break\n\n          case 'normal':\n          /* falls through */\n          default:\n            textRotationAngle = _tools__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"]\n            break\n        }\n        ctx.rotate(textRotationAngle)\n\n        switch (labelNumberFormat.format) {\n          case 'fractional':\n            ctx.fillText(\n              valueCounter.toFixed(fractionalScaleDecimals),\n              0,\n              0,\n              TEXT_WIDTH\n            )\n            break\n\n          case 'scientific':\n            ctx.fillText(valueCounter.toPrecision(2), 0, 0, TEXT_WIDTH)\n            break\n\n          case 'standard':\n          /* falls through */\n          default:\n            ctx.fillText(valueCounter.toFixed(0), 0, 0, TEXT_WIDTH)\n            break\n        }\n        ctx.translate(-TEXT_TRANSLATE_X, 0)\n        ctx.restore()\n\n        valueCounter += majorTickSpacing\n        majorTickCounter = 0\n        ctx.rotate(rotationStep)\n        alpha += rotationStep\n        continue\n      }\n      ctx.rotate(rotationStep)\n      alpha += rotationStep\n    }\n\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  const blink = function (blinking) {\n    if (blinking) {\n      ledTimerId = setInterval(toggleAndRepaintLed, 1000)\n    } else {\n      clearInterval(ledTimerId)\n      ledBuffer = ledBufferOff\n    }\n  }\n\n  const blinkUser = function (blinking) {\n    if (blinking) {\n      userLedTimerId = setInterval(toggleAndRepaintUserLed, 1000)\n    } else {\n      clearInterval(userLedTimerId)\n      userLedBuffer = userLedBufferOff\n    }\n  }\n\n  const toggleAndRepaintLed = function () {\n    if (ledVisible) {\n      if (ledBuffer === ledBufferOn) {\n        ledBuffer = ledBufferOff\n      } else {\n        ledBuffer = ledBufferOn\n      }\n      if (!repainting) {\n        repainting = true\n        Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"requestAnimFrame\"])(self.repaint)\n      }\n    }\n  }\n\n  const toggleAndRepaintUserLed = function () {\n    if (userLedVisible) {\n      if (userLedBuffer === userLedBufferOn) {\n        userLedBuffer = userLedBufferOff\n      } else {\n        userLedBuffer = userLedBufferOn\n      }\n      if (!repainting) {\n        repainting = true\n        Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"requestAnimFrame\"])(self.repaint)\n      }\n    }\n  }\n\n  //* ******************************** Public methods *********************************\n  this.setValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    if (value !== targetValue) {\n      value = targetValue\n      if (\n        (value >= threshold && !ledBlinking && thresholdRising) ||\n        (value <= threshold && !ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = true\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.play()\n        }\n      } else if (\n        (value < threshold && ledBlinking && thresholdRising) ||\n        (value > threshold && ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = false\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.pause()\n        }\n      }\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.setValueAnimated = function (newValue, callback) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    const gauge = this\n    let time\n\n    if (value !== targetValue) {\n      if (undefined !== tween && tween.isPlaying) {\n        tween.stop()\n      }\n\n      time =\n        (fullScaleDeflectionTime * Math.abs(targetValue - value)) /\n        (maxValue - minValue)\n      time = Math.max(time, fullScaleDeflectionTime / 5)\n      tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n        {},\n        '',\n        _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n        value,\n        targetValue,\n        time\n      )\n      // tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n      // tween = new Tween(new Object(), '', Tween.strongEaseInOut, this.value, targetValue, 1);\n      tween.onMotionChanged = function (event) {\n        value = event.target._pos\n\n        if (\n          (value >= threshold && !ledBlinking && thresholdRising) ||\n          (value <= threshold && !ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = true\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.play()\n          }\n        } else if (\n          (value < threshold && ledBlinking && thresholdRising) ||\n          (value > threshold && ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = false\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.pause()\n          }\n        }\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tween.onMotionFinished = callback\n      }\n\n      tween.start()\n    }\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers({\n      frame: true\n    })\n    frameDesign = newFrameDesign\n    init({\n      frame: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers({\n      background: true,\n      led: true\n    })\n    backgroundColor = newBackgroundColor\n    init({\n      background: true,\n      led: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers({\n      foreground: true\n    })\n    foregroundType = newForegroundType\n    init({\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setValueColor = function (newValueColor) {\n    resetBuffers({\n      value: true\n    })\n    valueColor = newValueColor\n    init({\n      value: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLedColor = function (newLedColor) {\n    resetBuffers({\n      led: true\n    })\n    ledColor = newLedColor\n    init({\n      led: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setUserLedColor = function (newLedColor) {\n    resetBuffers({\n      userLed: true\n    })\n    userLedColor = newLedColor\n    init({\n      userLed: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.toggleUserLed = function () {\n    if (userLedBuffer === userLedBufferOn) {\n      userLedBuffer = userLedBufferOff\n    } else {\n      userLedBuffer = userLedBufferOn\n    }\n    this.repaint()\n    return this\n  }\n\n  this.setUserLedOnOff = function (on) {\n    if (on === true) {\n      userLedBuffer = userLedBufferOn\n    } else {\n      userLedBuffer = userLedBufferOff\n    }\n    this.repaint()\n    return this\n  }\n\n  this.blinkUserLed = function (blink) {\n    if (blink) {\n      if (!userLedBlinking) {\n        blinkUser(true)\n        userLedBlinking = true\n      }\n    } else {\n      if (userLedBlinking) {\n        clearInterval(userLedTimerId)\n        userLedBlinking = false\n      }\n    }\n    return this\n  }\n\n  this.setLedVisible = function (visible) {\n    ledVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setUserLedVisible = function (visible) {\n    userLedVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setLcdColor = function (newLcdColor) {\n    lcdColor = newLcdColor\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLcdDecimals = function (decimals) {\n    lcdDecimals = parseInt(decimals, 10)\n    this.repaint()\n    return this\n  }\n\n  this.setSection = function (areaSec) {\n    section = areaSec\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setSectionActive = function (value) {\n    useSectionColors = value\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setGradient = function (grad) {\n    valueGradient = grad\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setGradientActive = function (value) {\n    useValueGradient = value\n    init()\n    this.repaint()\n    return this\n  }\n\n  this.setMinValue = function (newValue) {\n    minValue = newValue\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMinValue = function () {\n    return minValue\n  }\n\n  this.setMaxValue = function (newValue) {\n    maxValue = newValue\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMaxValue = function () {\n    return maxValue\n  }\n\n  this.setThreshold = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    threshold = targetValue\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setThresholdRising = function (rising) {\n    thresholdRising = !!rising\n    // reset existing threshold alerts\n    ledBlinking = !ledBlinking\n    blink(ledBlinking)\n    this.repaint()\n    return this\n  }\n\n  this.setTitleString = function (title) {\n    titleString = title\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setUnitString = function (unit) {\n    unitString = unit\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setTrend = function (newValue) {\n    trendIndicator = newValue\n    this.repaint()\n    return this\n  }\n\n  this.setTrendVisible = function (visible) {\n    trendVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setFractionalScaleDecimals = function (decimals) {\n    fractionalScaleDecimals = parseInt(decimals, 10)\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n  }\n\n  this.setLabelNumberFormat = function (format) {\n    labelNumberFormat = format\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    const activeLedAngle =\n      ((value - minValue) / (maxValue - minValue)) * degAngleRange\n    let activeLedColor\n    let lastActiveLedColor = valueColor\n    let angle\n    let i\n    let currentValue\n    let gradRange\n    let fraction\n\n    if (!initialized) {\n      init({\n        frame: true,\n        background: true,\n        led: true,\n        userLed: true,\n        value: true,\n        trend: true,\n        foreground: true\n      })\n    }\n\n    mainCtx.clearRect(0, 0, size, size)\n\n    // Draw frame image\n    if (frameVisible) {\n      mainCtx.drawImage(frameBuffer, 0, 0)\n    }\n\n    // Draw buffered image to visible canvas\n    mainCtx.drawImage(backgroundBuffer, 0, 0)\n\n    // Draw active leds\n    for (angle = 0; angle <= activeLedAngle; angle += 5) {\n      // check for LED color\n      activeLedColor = valueColor\n      // Use a gradient for value colors?\n      if (isGradientVisible) {\n        // Convert angle back to value\n        currentValue =\n          minValue + (angle / degAngleRange) * (maxValue - minValue)\n        gradRange = valueGradient.getEnd() - valueGradient.getStart()\n        fraction = (currentValue - minValue) / gradRange\n        fraction = Math.max(Math.min(fraction, 1), 0)\n        activeLedColor = Object(_tools__WEBPACK_IMPORTED_MODULE_9__[\"customColorDef\"])(\n          valueGradient.getColorAt(fraction).getRgbaColor()\n        )\n      } else if (isSectionsVisible) {\n        for (i = 0; i < sectionAngles.length; i++) {\n          if (\n            angle >= sectionAngles[i].start &&\n            angle < sectionAngles[i].stop\n          ) {\n            activeLedColor = sectionAngles[i].color\n            break\n          }\n        }\n      }\n      // Has LED color changed? If so redraw the buffer\n      if (\n        lastActiveLedColor.medium.getHexColor() !==\n        activeLedColor.medium.getHexColor()\n      ) {\n        drawActiveLed(activeLedContext, activeLedColor)\n        lastActiveLedColor = activeLedColor\n      }\n      mainCtx.save()\n      mainCtx.translate(centerX, centerY)\n      mainCtx.rotate(angle * _tools__WEBPACK_IMPORTED_MODULE_9__[\"RAD_FACTOR\"] + bargraphOffset)\n      mainCtx.translate(-centerX, -centerY)\n      mainCtx.drawImage(activeLedBuffer, ACTIVE_LED_POS_X, ACTIVE_LED_POS_Y)\n      mainCtx.restore()\n    }\n\n    // Draw lcd display\n    if (lcdVisible) {\n      drawLcdText(mainCtx, value)\n    }\n\n    // Draw led\n    if (ledVisible) {\n      mainCtx.drawImage(ledBuffer, LED_POS_X, LED_POS_Y)\n    }\n\n    // Draw user led\n    if (userLedVisible) {\n      mainCtx.drawImage(userLedBuffer, USER_LED_POS_X, USER_LED_POS_Y)\n    }\n\n    // Draw the trend indicator\n    if (trendVisible) {\n      switch (trendIndicator.state) {\n        case 'up':\n          mainCtx.drawImage(trendUpBuffer, trendPosX, trendPosY)\n          break\n        case 'steady':\n          mainCtx.drawImage(trendSteadyBuffer, trendPosX, trendPosY)\n          break\n        case 'down':\n          mainCtx.drawImage(trendDownBuffer, trendPosX, trendPosY)\n          break\n        case 'off':\n          mainCtx.drawImage(trendOffBuffer, trendPosX, trendPosY)\n          break\n      }\n    }\n\n    // Draw foreground\n    if (foregroundVisible) {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (RadialBargraph);\n\n\n//# sourceURL=webpack://steelseries/./src/RadialBargraph.js?");

/***/ }),

/***/ "./src/RadialVertical.js":
/*!*******************************!*\
  !*** ./src/RadialVertical.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawPointerImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawPointerImage */ \"./src/drawPointerImage.js\");\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _createKnobImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createKnobImage */ \"./src/createKnobImage.js\");\n/* harmony import */ var _createLedImage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createLedImage */ \"./src/createLedImage.js\");\n/* harmony import */ var _createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./createMeasuredValueImage */ \"./src/createMeasuredValueImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst RadialVertical = function (canvas, parameters) {\n  parameters = parameters || {}\n  const orientation =\n    undefined === parameters.orientation\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].NORTH\n      : parameters.orientation\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let minValue = undefined === parameters.minValue ? 0 : parameters.minValue\n  let maxValue =\n    undefined === parameters.maxValue ? minValue + 100 : parameters.maxValue\n  const niceScale =\n    undefined === parameters.niceScale ? true : parameters.niceScale\n  let threshold =\n    undefined === parameters.threshold\n      ? (maxValue - minValue) / 2 + minValue\n      : parameters.threshold\n  const section = undefined === parameters.section ? null : parameters.section\n  const area = undefined === parameters.area ? null : parameters.area\n  const titleString =\n    undefined === parameters.titleString ? '' : parameters.titleString\n  const unitString =\n    undefined === parameters.unitString ? '' : parameters.unitString\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].DARK_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let pointerType =\n    undefined === parameters.pointerType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"PointerType\"].TYPE1\n      : parameters.pointerType\n  let pointerColor =\n    undefined === parameters.pointerColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].RED\n      : parameters.pointerColor\n  const knobType =\n    undefined === parameters.knobType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobType\"].STANDARD_KNOB\n      : parameters.knobType\n  const knobStyle =\n    undefined === parameters.knobStyle\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobStyle\"].SILVER\n      : parameters.knobStyle\n  let ledColor =\n    undefined === parameters.ledColor ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LedColor\"].RED_LED : parameters.ledColor\n  let ledVisible =\n    undefined === parameters.ledVisible ? true : parameters.ledVisible\n  let thresholdVisible =\n    undefined === parameters.thresholdVisible\n      ? true\n      : parameters.thresholdVisible\n  let thresholdRising =\n    undefined === parameters.thresholdRising\n      ? true\n      : parameters.thresholdRising\n  let minMeasuredValueVisible =\n    undefined === parameters.minMeasuredValueVisible\n      ? false\n      : parameters.minMeasuredValueVisible\n  let maxMeasuredValueVisible =\n    undefined === parameters.maxMeasuredValueVisible\n      ? false\n      : parameters.maxMeasuredValueVisible\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  const labelNumberFormat =\n    undefined === parameters.labelNumberFormat\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LabelNumberFormat\"].STANDARD\n      : parameters.labelNumberFormat\n  const playAlarm =\n    undefined === parameters.playAlarm ? false : parameters.playAlarm\n  const alarmSound =\n    undefined === parameters.alarmSound ? false : parameters.alarmSound\n  const fullScaleDeflectionTime =\n    undefined === parameters.fullScaleDeflectionTime\n      ? 2.5\n      : parameters.fullScaleDeflectionTime\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (size === 0) {\n    size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height)\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  let audioElement\n\n  // Create audio tag for alarm sound\n  if (playAlarm && alarmSound !== false) {\n    audioElement = _tools__WEBPACK_IMPORTED_MODULE_8__[\"doc\"].createElement('audio')\n    audioElement.setAttribute('src', alarmSound)\n    audioElement.setAttribute('preload', 'auto')\n  }\n  const gaugeType = _definitions__WEBPACK_IMPORTED_MODULE_9__[\"GaugeType\"].TYPE5\n\n  const self = this\n  let value = minValue\n\n  // Properties\n  let minMeasuredValue = maxValue\n  let maxMeasuredValue = minValue\n  const imageWidth = size\n  const imageHeight = size\n\n  let ledBlinking = false\n\n  let ledTimerId = 0\n  let tween\n  let repainting = false\n\n  // Tickmark specific private variables\n  let niceMinValue = minValue\n  let niceMaxValue = maxValue\n  let niceRange = maxValue - minValue\n  let range = niceMaxValue - niceMinValue\n  let minorTickSpacing = 0\n  let majorTickSpacing = 0\n  const maxNoOfMinorTicks = 10\n  const maxNoOfMajorTicks = 10\n\n  let rotationOffset = 1.25 * _tools__WEBPACK_IMPORTED_MODULE_8__[\"PI\"]\n  let angleRange = _tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"]\n  let angleStep = angleRange / range\n  const shadowOffset = imageWidth * 0.006\n  const pointerOffset = (imageWidth * 1.17) / 2\n\n  let initialized = false\n\n  let angle = rotationOffset + (value - minValue) * angleStep\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight * 0.733644\n\n  // Misc\n  const ledPosX = 0.455 * imageWidth\n  const ledPosY = 0.51 * imageHeight\n\n  // Method to calculate nice values for min, max and range for the tickmarks\n  const calculate = function calculate () {\n    if (niceScale) {\n      niceRange = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"calcNiceNumber\"])(maxValue - minValue, false)\n      majorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"calcNiceNumber\"])(\n        niceRange / (maxNoOfMajorTicks - 1),\n        true\n      )\n      niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing\n      niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing\n      minorTickSpacing = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"calcNiceNumber\"])(\n        majorTickSpacing / (maxNoOfMinorTicks - 1),\n        true\n      )\n      minValue = niceMinValue\n      maxValue = niceMaxValue\n      range = maxValue - minValue\n    } else {\n      niceRange = maxValue - minValue\n      niceMinValue = minValue\n      niceMaxValue = maxValue\n      range = niceRange\n      minorTickSpacing = 1\n      majorTickSpacing = 10\n    }\n    // Make sure values are still in range\n    value = value < minValue ? minValue : value > maxValue ? maxValue : value\n    minMeasuredValue =\n      minMeasuredValue < minValue\n        ? minValue\n        : minMeasuredValue > maxValue\n          ? maxValue\n          : minMeasuredValue\n    maxMeasuredValue =\n      maxMeasuredValue < minValue\n        ? minValue\n        : maxMeasuredValue > maxValue\n          ? maxValue\n          : maxMeasuredValue\n    threshold =\n      threshold < minValue\n        ? minValue\n        : threshold > maxValue\n          ? maxValue\n          : threshold\n\n    rotationOffset = 1.25 * _tools__WEBPACK_IMPORTED_MODULE_8__[\"PI\"]\n    angleRange = _tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"]\n    angleStep = angleRange / range\n\n    angle = rotationOffset + (value - minValue) * angleStep\n  }\n\n  // **************   Buffer creation  ********************\n  // Buffer for the frame\n  const frameBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size, size)\n  let frameContext = frameBuffer.getContext('2d')\n\n  // Buffer for the background\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size, size)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  // Buffer for led on painting code\n  const ledBufferOn = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size * 0.093457, size * 0.093457)\n  let ledContextOn = ledBufferOn.getContext('2d')\n\n  // Buffer for led off painting code\n  const ledBufferOff = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size * 0.093457, size * 0.093457)\n  let ledContextOff = ledBufferOff.getContext('2d')\n\n  // Buffer for current led painting code\n  let ledBuffer = ledBufferOff\n\n  // Buffer for the minMeasuredValue indicator\n  const minMeasuredValueBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(\n    Math.ceil(size * 0.028037),\n    Math.ceil(size * 0.028037)\n  )\n  const minMeasuredValueCtx = minMeasuredValueBuffer.getContext('2d')\n\n  // Buffer for the maxMeasuredValue indicator\n  const maxMeasuredValueBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(\n    Math.ceil(size * 0.028037),\n    Math.ceil(size * 0.028037)\n  )\n  const maxMeasuredValueCtx = maxMeasuredValueBuffer.getContext('2d')\n\n  // Buffer for pointer image painting code\n  const pointerBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size, size)\n  let pointerContext = pointerBuffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size, size)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  // **************   Image creation  ********************\n  const drawPostsImage = function (ctx) {\n    if (gaugeType.type === 'type5') {\n      ctx.save()\n      if (orientation.type === 'west') {\n        // Min post\n        ctx.drawImage(\n          Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n            Math.ceil(imageHeight * 0.037383),\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobType\"].STANDARD_KNOB,\n            knobStyle\n          ),\n          imageWidth * 0.44,\n          imageHeight * 0.8\n        )\n        // Max post\n        ctx.drawImage(\n          Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n            Math.ceil(imageHeight * 0.037383),\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobType\"].STANDARD_KNOB,\n            knobStyle\n          ),\n          imageWidth * 0.44,\n          imageHeight * 0.16\n        )\n      } else if (orientation.type === 'east') {\n        // Min post\n        ctx.drawImage(\n          Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n            Math.ceil(imageHeight * 0.037383),\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobType\"].STANDARD_KNOB,\n            knobStyle\n          ),\n          imageWidth * 0.52,\n          imageHeight * 0.8\n        )\n        // Max post\n        ctx.drawImage(\n          Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n            Math.ceil(imageHeight * 0.037383),\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobType\"].STANDARD_KNOB,\n            knobStyle\n          ),\n          imageWidth * 0.52,\n          imageHeight * 0.16\n        )\n      } else {\n        // Min post\n        ctx.drawImage(\n          Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n            Math.ceil(imageHeight * 0.037383),\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobType\"].STANDARD_KNOB,\n            knobStyle\n          ),\n          imageWidth * 0.2 - imageHeight * 0.037383,\n          imageHeight * 0.446666\n        )\n        // Max post\n        ctx.drawImage(\n          Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n            Math.ceil(imageHeight * 0.037383),\n            _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobType\"].STANDARD_KNOB,\n            knobStyle\n          ),\n          imageWidth * 0.8,\n          imageHeight * 0.446666\n        )\n      }\n      ctx.restore()\n    }\n  }\n\n  const createThresholdImage = function () {\n    const thresholdBuffer = _tools__WEBPACK_IMPORTED_MODULE_8__[\"doc\"].createElement('canvas')\n    thresholdBuffer.width = Math.ceil(size * 0.046728)\n    thresholdBuffer.height = Math.ceil(thresholdBuffer.width * 0.9)\n    const thresholdCtx = thresholdBuffer.getContext('2d')\n\n    thresholdCtx.save()\n    const gradThreshold = thresholdCtx.createLinearGradient(\n      0,\n      0.1,\n      0,\n      thresholdBuffer.height * 0.9\n    )\n    gradThreshold.addColorStop(0, '#520000')\n    gradThreshold.addColorStop(0.3, '#fc1d00')\n    gradThreshold.addColorStop(0.59, '#fc1d00')\n    gradThreshold.addColorStop(1, '#520000')\n    thresholdCtx.fillStyle = gradThreshold\n\n    thresholdCtx.beginPath()\n    thresholdCtx.moveTo(thresholdBuffer.width * 0.5, 0.1)\n    thresholdCtx.lineTo(\n      thresholdBuffer.width * 0.9,\n      thresholdBuffer.height * 0.9\n    )\n    thresholdCtx.lineTo(\n      thresholdBuffer.width * 0.1,\n      thresholdBuffer.height * 0.9\n    )\n    thresholdCtx.lineTo(thresholdBuffer.width * 0.5, 0.1)\n    thresholdCtx.closePath()\n\n    thresholdCtx.fill()\n    thresholdCtx.strokeStyle = '#FFFFFF'\n    thresholdCtx.stroke()\n\n    thresholdCtx.restore()\n\n    return thresholdBuffer\n  }\n\n  const drawAreaSectionImage = function (ctx, start, stop, color, filled) {\n    ctx.save()\n    ctx.strokeStyle = color\n    ctx.fillStyle = color\n    ctx.lineWidth = imageWidth * 0.035\n    const startAngle =\n      (angleRange / range) * start - (angleRange / range) * minValue\n    const stopAngle = startAngle + (stop - start) / (range / angleRange)\n    ctx.translate(centerX, centerY)\n    ctx.rotate(rotationOffset)\n    ctx.beginPath()\n    if (filled) {\n      ctx.moveTo(0, 0)\n      ctx.arc(\n        0,\n        0,\n        imageWidth * 0.365 - ctx.lineWidth / 2,\n        startAngle,\n        stopAngle,\n        false\n      )\n    } else {\n      ctx.arc(0, 0, imageWidth * 0.365, startAngle, stopAngle, false)\n    }\n    if (filled) {\n      ctx.moveTo(0, 0)\n      ctx.fill()\n    } else {\n      ctx.stroke()\n    }\n\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  const drawTitleImage = function (ctx) {\n    ctx.save()\n    ctx.textAlign = 'left'\n    ctx.textBaseline = 'middle'\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n\n    ctx.font = 0.046728 * imageWidth + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n    const titleWidth = ctx.measureText(titleString).width\n    ctx.fillText(\n      titleString,\n      (imageWidth - titleWidth) / 2,\n      imageHeight * 0.4,\n      imageWidth * 0.3\n    )\n    const unitWidth = ctx.measureText(unitString).width\n    ctx.fillText(\n      unitString,\n      (imageWidth - unitWidth) / 2,\n      imageHeight * 0.47,\n      imageWidth * 0.2\n    )\n\n    ctx.restore()\n  }\n\n  const drawTickmarksImage = function (ctx, labelNumberFormat) {\n    backgroundColor.labelColor.setAlpha(1)\n    ctx.save()\n\n    if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].WEST === orientation) {\n      ctx.translate(centerX, centerX)\n      ctx.rotate(-_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n      ctx.translate(-centerX, -centerX)\n    }\n    if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].EAST === orientation) {\n      ctx.translate(centerX, centerX)\n      ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n      ctx.translate(-centerX, -centerX)\n    }\n\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    const fontSize = Math.ceil(imageWidth * 0.04)\n    ctx.font = fontSize + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.translate(centerX, centerY)\n    ctx.rotate(rotationOffset)\n    const rotationStep = angleStep * minorTickSpacing\n    let textRotationAngle\n\n    let valueCounter = minValue\n    let majorTickCounter = maxNoOfMinorTicks - 1\n\n    const OUTER_POINT = imageWidth * 0.44\n    const MAJOR_INNER_POINT = imageWidth * 0.41\n    const MED_INNER_POINT = imageWidth * 0.415\n    const MINOR_INNER_POINT = imageWidth * 0.42\n    const TEXT_TRANSLATE_X = imageWidth * 0.48\n    const TEXT_WIDTH = imageWidth * 0.04\n    const HALF_MAX_NO_OF_MINOR_TICKS = maxNoOfMinorTicks / 2\n    const MAX_VALUE_ROUNDED = parseFloat(maxValue.toFixed(2))\n    let i\n\n    for (\n      i = minValue;\n      parseFloat(i.toFixed(2)) <= MAX_VALUE_ROUNDED;\n      i += minorTickSpacing\n    ) {\n      textRotationAngle = +rotationStep + _tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"]\n      majorTickCounter++\n      // Draw major tickmarks\n      if (majorTickCounter === maxNoOfMinorTicks) {\n        ctx.lineWidth = 1.5\n        ctx.beginPath()\n        ctx.moveTo(OUTER_POINT, 0)\n        ctx.lineTo(MAJOR_INNER_POINT, 0)\n        ctx.closePath()\n        ctx.stroke()\n        ctx.save()\n        ctx.translate(TEXT_TRANSLATE_X, 0)\n        ctx.rotate(textRotationAngle)\n        switch (labelNumberFormat.format) {\n          case 'fractional':\n            ctx.fillText(valueCounter.toFixed(2), 0, 0, TEXT_WIDTH)\n            break\n\n          case 'scientific':\n            ctx.fillText(valueCounter.toPrecision(2), 0, 0, TEXT_WIDTH)\n            break\n\n          case 'standard':\n          /* falls through */\n          default:\n            ctx.fillText(valueCounter.toFixed(0), 0, 0, TEXT_WIDTH)\n            break\n        }\n        ctx.translate(-TEXT_TRANSLATE_X, 0)\n        ctx.restore()\n\n        valueCounter += majorTickSpacing\n        majorTickCounter = 0\n        ctx.rotate(rotationStep)\n        continue\n      }\n\n      // Draw tickmark every minor tickmark spacing\n      if (\n        maxNoOfMinorTicks % 2 === 0 &&\n        majorTickCounter === HALF_MAX_NO_OF_MINOR_TICKS\n      ) {\n        ctx.lineWidth = 1\n        ctx.beginPath()\n        ctx.moveTo(OUTER_POINT, 0)\n        ctx.lineTo(MED_INNER_POINT, 0)\n        ctx.closePath()\n        ctx.stroke()\n      } else {\n        ctx.lineWidth = 0.5\n        ctx.beginPath()\n        ctx.moveTo(OUTER_POINT, 0)\n        ctx.lineTo(MINOR_INNER_POINT, 0)\n        ctx.closePath()\n        ctx.stroke()\n      }\n      ctx.rotate(rotationStep)\n    }\n\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  // **************   Initialization  ********************\n  // Draw all static painting code to background\n  const init = function (parameters) {\n    parameters = parameters || {}\n    const drawFrame2 =\n      undefined === parameters.frame ? false : parameters.frame\n    const drawBackground2 =\n      undefined === parameters.background ? false : parameters.background\n    const drawLed = undefined === parameters.led ? false : parameters.led\n    const drawPointer =\n      undefined === parameters.pointer ? false : parameters.pointer\n    const drawForeground2 =\n      undefined === parameters.foreground ? false : parameters.foreground\n\n    initialized = true\n\n    // Calculate the current min and max values and the range\n    calculate()\n\n    // Create frame in frame buffer (backgroundBuffer)\n    if (drawFrame2 && frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        frameContext,\n        frameDesign,\n        centerX,\n        size / 2,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    // Create background in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      Object(_drawBackground__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        centerX,\n        size / 2,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    // Draw LED ON in ledBuffer_ON\n    if (drawLed) {\n      ledContextOn.drawImage(\n        Object(_createLedImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(Math.ceil(size * 0.093457), 1, ledColor),\n        0,\n        0\n      )\n\n      // Draw LED ON in ledBuffer_OFF\n      ledContextOff.drawImage(\n        Object(_createLedImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(Math.ceil(size * 0.093457), 0, ledColor),\n        0,\n        0\n      )\n    }\n\n    // Draw min measured value indicator in minMeasuredValueBuffer\n    if (minMeasuredValueVisible) {\n      minMeasuredValueCtx.drawImage(\n        Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n          Math.ceil(size * 0.028037),\n          _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].BLUE.dark.getRgbaColor(),\n          true,\n          true\n        ),\n        0,\n        0\n      )\n      minMeasuredValueCtx.restore()\n    }\n\n    // Draw max measured value indicator in maxMeasuredValueBuffer\n    if (maxMeasuredValueVisible) {\n      maxMeasuredValueCtx.drawImage(\n        Object(_createMeasuredValueImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n          Math.ceil(size * 0.028037),\n          _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].RED.medium.getRgbaColor(),\n          true\n        ),\n        0,\n        0\n      )\n      maxMeasuredValueCtx.restore()\n    }\n\n    // Create alignment posts in background buffer (backgroundBuffer)\n    if (drawBackground2 && backgroundVisible) {\n      drawPostsImage(backgroundContext)\n\n      // Create section in background buffer (backgroundBuffer)\n      if (section !== null && section.length > 0) {\n        backgroundContext.save()\n        if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].WEST === orientation) {\n          backgroundContext.translate(centerX, centerX)\n          backgroundContext.rotate(-_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n          backgroundContext.translate(-centerX, -centerX)\n        } else if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].EAST === orientation) {\n          backgroundContext.translate(centerX, centerX)\n          backgroundContext.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n          backgroundContext.translate(-centerX, -centerX)\n        }\n        let sectionIndex = section.length\n        do {\n          sectionIndex--\n          drawAreaSectionImage(\n            backgroundContext,\n            section[sectionIndex].start,\n            section[sectionIndex].stop,\n            section[sectionIndex].color,\n            false\n          )\n        } while (sectionIndex > 0)\n        backgroundContext.restore()\n      }\n\n      // Create area in background buffer (backgroundBuffer)\n      if (area !== null && area.length > 0) {\n        if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].WEST === orientation) {\n          backgroundContext.translate(centerX, centerX)\n          backgroundContext.rotate(-_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n          backgroundContext.translate(-centerX, -centerX)\n        }\n        if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].EAST === orientation) {\n          backgroundContext.translate(centerX, centerX)\n          backgroundContext.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n          backgroundContext.translate(-centerX, -centerX)\n        }\n        let areaIndex = area.length\n        do {\n          areaIndex--\n          drawAreaSectionImage(\n            backgroundContext,\n            area[areaIndex].start,\n            area[areaIndex].stop,\n            area[areaIndex].color,\n            true\n          )\n        } while (areaIndex > 0)\n        backgroundContext.restore()\n      }\n\n      // Create tickmarks in background buffer (backgroundBuffer)\n      drawTickmarksImage(backgroundContext, labelNumberFormat)\n\n      // Create title in background buffer (backgroundBuffer)\n      drawTitleImage(backgroundContext)\n    }\n\n    // Draw threshold image to background context\n    if (thresholdVisible) {\n      backgroundContext.save()\n      if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].WEST === orientation) {\n        backgroundContext.translate(centerX, centerX)\n        backgroundContext.rotate(-_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n        backgroundContext.translate(-centerX, -centerX)\n      }\n      if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].EAST === orientation) {\n        backgroundContext.translate(centerX, centerX)\n        backgroundContext.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n        backgroundContext.translate(-centerX, -centerX)\n      }\n      backgroundContext.translate(centerX, centerY)\n      backgroundContext.rotate(\n        rotationOffset + (threshold - minValue) * angleStep + _tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"]\n      )\n      backgroundContext.translate(-centerX, -centerY)\n      backgroundContext.drawImage(\n        createThresholdImage(),\n        imageWidth * 0.475,\n        imageHeight * 0.32\n      )\n      backgroundContext.restore()\n    }\n\n    // Create pointer image in pointer buffer (contentBuffer)\n    if (drawPointer) {\n      Object(_drawPointerImage__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        pointerContext,\n        imageWidth * 1.17,\n        pointerType,\n        pointerColor,\n        backgroundColor.labelColor\n      )\n    }\n\n    // Create foreground in foreground buffer (foregroundBuffer)\n    if (drawForeground2 && foregroundVisible) {\n      const knobVisible =\n        !(pointerType.type === 'type15' || pointerType.type === 'type16')\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        knobVisible,\n        knobType,\n        knobStyle,\n        gaugeType,\n        orientation\n      )\n    }\n  }\n\n  const resetBuffers = function (buffers) {\n    buffers = buffers || {}\n    const resetFrame = undefined === buffers.frame ? false : buffers.frame\n    const resetBackground =\n      undefined === buffers.background ? false : buffers.background\n    const resetLed = undefined === buffers.led ? false : buffers.led\n    const resetPointer =\n      undefined === buffers.pointer ? false : buffers.pointer\n    const resetForeground =\n      undefined === buffers.foreground ? false : buffers.foreground\n\n    if (resetFrame) {\n      frameBuffer.width = size\n      frameBuffer.height = size\n      frameContext = frameBuffer.getContext('2d')\n    }\n\n    if (resetBackground) {\n      backgroundBuffer.width = size\n      backgroundBuffer.height = size\n      backgroundContext = backgroundBuffer.getContext('2d')\n    }\n\n    if (resetLed) {\n      ledBufferOn.width = Math.ceil(size * 0.093457)\n      ledBufferOn.height = Math.ceil(size * 0.093457)\n      ledContextOn = ledBufferOn.getContext('2d')\n\n      ledBufferOff.width = Math.ceil(size * 0.093457)\n      ledBufferOff.height = Math.ceil(size * 0.093457)\n      ledContextOff = ledBufferOff.getContext('2d')\n\n      // Buffer for current led painting code\n      ledBuffer = ledBufferOff\n    }\n\n    if (resetPointer) {\n      pointerBuffer.width = size\n      pointerBuffer.height = size\n      pointerContext = pointerBuffer.getContext('2d')\n    }\n\n    if (resetForeground) {\n      foregroundBuffer.width = size\n      foregroundBuffer.height = size\n      foregroundContext = foregroundBuffer.getContext('2d')\n    }\n  }\n\n  const blink = function (blinking) {\n    if (blinking) {\n      ledTimerId = setInterval(toggleAndRepaintLed, 1000)\n    } else {\n      clearInterval(ledTimerId)\n      ledBuffer = ledBufferOff\n    }\n  }\n\n  const toggleAndRepaintLed = function () {\n    if (ledVisible) {\n      if (ledBuffer === ledBufferOn) {\n        ledBuffer = ledBufferOff\n      } else {\n        ledBuffer = ledBufferOn\n      }\n      if (!repainting) {\n        repainting = true\n        Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(self.repaint)\n      }\n    }\n  }\n\n  //* *********************************** Public methods **************************************\n  this.setValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    if (value !== targetValue) {\n      value = targetValue\n\n      if (value > maxMeasuredValue) {\n        maxMeasuredValue = value\n      }\n      if (value < minMeasuredValue) {\n        minMeasuredValue = value\n      }\n\n      if (\n        (value >= threshold && !ledBlinking && thresholdRising) ||\n        (value <= threshold && !ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = true\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.play()\n        }\n      } else if (\n        (value < threshold && ledBlinking && thresholdRising) ||\n        (value > threshold && ledBlinking && !thresholdRising)\n      ) {\n        ledBlinking = false\n        blink(ledBlinking)\n        if (playAlarm) {\n          audioElement.pause()\n        }\n      }\n\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValue = function () {\n    return value\n  }\n\n  this.setValueAnimated = function (newValue, callback) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    const gauge = this\n    let time\n\n    if (value !== targetValue) {\n      if (undefined !== tween && tween.isPlaying) {\n        tween.stop()\n      }\n\n      time =\n        (fullScaleDeflectionTime * Math.abs(targetValue - value)) /\n        (maxValue - minValue)\n      time = Math.max(time, fullScaleDeflectionTime / 5)\n      tween = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n        {},\n        '',\n        _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n        value,\n        targetValue,\n        time\n      )\n      // tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n      // tween = new Tween(new Object(), '', Tween.strongEaseInOut, value, targetValue, 1);\n      tween.onMotionChanged = function (event) {\n        value = event.target._pos\n\n        if (\n          (value >= threshold && !ledBlinking && thresholdRising) ||\n          (value <= threshold && !ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = true\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.play()\n          }\n        } else if (\n          (value < threshold && ledBlinking && thresholdRising) ||\n          (value > threshold && ledBlinking && !thresholdRising)\n        ) {\n          ledBlinking = false\n          blink(ledBlinking)\n          if (playAlarm) {\n            audioElement.pause()\n          }\n        }\n\n        if (value > maxMeasuredValue) {\n          maxMeasuredValue = value\n        }\n        if (value < minMeasuredValue) {\n          minMeasuredValue = value\n        }\n\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n\n      // do we have a callback function to process?\n      if (callback && typeof callback === 'function') {\n        tween.onMotionFinished = callback\n      }\n\n      tween.start()\n    }\n    return this\n  }\n\n  this.setMinValue = function (newValue) {\n    minValue = parseFloat(newValue)\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMinValue = function () {\n    return minValue\n  }\n\n  this.setMaxValue = function (newValue) {\n    maxValue = parseFloat(newValue)\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.getMaxValue = function () {\n    return maxValue\n  }\n\n  this.setMaxMeasuredValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    maxMeasuredValue = targetValue\n    this.repaint()\n    return this\n  }\n\n  this.setMinMeasuredValue = function (newValue) {\n    newValue = parseFloat(newValue)\n    const targetValue =\n      newValue < minValue\n        ? minValue\n        : newValue > maxValue\n          ? maxValue\n          : newValue\n    minMeasuredValue = targetValue\n    this.repaint()\n    return this\n  }\n\n  this.resetMinMeasuredValue = function () {\n    minMeasuredValue = value\n    this.repaint()\n    return this\n  }\n\n  this.resetMaxMeasuredValue = function () {\n    maxMeasuredValue = value\n    this.repaint()\n    return this\n  }\n\n  this.setMinMeasuredValueVisible = function (visible) {\n    minMeasuredValueVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setMaxMeasuredValueVisible = function (visible) {\n    maxMeasuredValueVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setThresholdVisible = function (visible) {\n    thresholdVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.setThresholdRising = function (rising) {\n    thresholdRising = !!rising\n    // reset existing threshold alerts\n    ledBlinking = !ledBlinking\n    blink(ledBlinking)\n    this.repaint()\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers({\n      frame: true\n    })\n    frameDesign = newFrameDesign\n    init({\n      frame: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers({\n      background: true,\n      pointer:\n        !!(pointerType.type === 'type2' || pointerType.type === 'type13') // type2 & 13 depend on background\n    })\n    backgroundColor = newBackgroundColor\n    init({\n      background: true,\n      pointer:\n        !!(pointerType.type === 'type2' || pointerType.type === 'type13') // type2 & 13 depend on background\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers({\n      foreground: true\n    })\n    foregroundType = newForegroundType\n    init({\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerType = function (newPointerType) {\n    resetBuffers({\n      pointer: true,\n      foreground: true // Required as type15 does not need a knob\n    })\n    pointerType = newPointerType\n    init({\n      pointer: true,\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerColor = function (newPointerColor) {\n    resetBuffers({\n      pointer: true\n    })\n    pointerColor = newPointerColor\n    init({\n      pointer: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLedColor = function (newLedColor) {\n    resetBuffers({\n      led: true\n    })\n    ledColor = newLedColor\n    init({\n      led: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLedVisible = function (visible) {\n    ledVisible = !!visible\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init({\n        frame: true,\n        background: true,\n        led: true,\n        pointer: true,\n        foreground: true\n      })\n    }\n\n    mainCtx.clearRect(0, 0, size, size)\n    mainCtx.save()\n\n    // Draw frame\n    if (frameVisible) {\n      mainCtx.drawImage(frameBuffer, 0, 0)\n    }\n\n    // Draw buffered image to visible canvas\n    mainCtx.drawImage(backgroundBuffer, 0, 0)\n\n    // Draw led\n    if (ledVisible) {\n      mainCtx.drawImage(ledBuffer, ledPosX, ledPosY)\n    }\n\n    if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].WEST === orientation) {\n      mainCtx.translate(centerX, centerX)\n      mainCtx.rotate(-_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n      mainCtx.translate(-centerX, -centerX)\n    }\n    if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].EAST === orientation) {\n      mainCtx.translate(centerX, centerX)\n      mainCtx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n      mainCtx.translate(-centerX, -centerX)\n    }\n\n    // Draw min measured value indicator\n    if (minMeasuredValueVisible) {\n      mainCtx.save()\n      mainCtx.translate(centerX, centerY)\n      mainCtx.rotate(\n        rotationOffset + _tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"] + (minMeasuredValue - minValue) * angleStep\n      )\n      mainCtx.translate(-centerX, -centerY)\n      mainCtx.drawImage(\n        minMeasuredValueBuffer,\n        mainCtx.canvas.width * 0.4865,\n        mainCtx.canvas.height * 0.27\n      )\n      mainCtx.restore()\n    }\n\n    // Draw max measured value indicator\n    if (maxMeasuredValueVisible) {\n      mainCtx.save()\n      mainCtx.translate(centerX, centerY)\n      mainCtx.rotate(\n        rotationOffset + _tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"] + (maxMeasuredValue - minValue) * angleStep\n      )\n      mainCtx.translate(-centerX, -centerY)\n      mainCtx.drawImage(\n        maxMeasuredValueBuffer,\n        mainCtx.canvas.width * 0.4865,\n        mainCtx.canvas.height * 0.27\n      )\n      mainCtx.restore()\n    }\n\n    angle = rotationOffset + _tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"] + (value - minValue) * angleStep\n\n    // Define rotation center\n    mainCtx.save()\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(angle)\n    // Set the pointer shadow params\n    mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset\n    mainCtx.shadowBlur = shadowOffset * 2\n    // Draw pointer\n    mainCtx.translate(-pointerOffset, -pointerOffset)\n    mainCtx.drawImage(pointerBuffer, 0, 0)\n    // Undo the translations & shadow settings\n    mainCtx.restore()\n\n    // Draw foreground\n    if (foregroundVisible) {\n      if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].WEST === orientation) {\n        mainCtx.translate(centerX, centerX)\n        mainCtx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n        mainCtx.translate(-centerX, -centerX)\n      } else if (_definitions__WEBPACK_IMPORTED_MODULE_9__[\"Orientation\"].EAST === orientation) {\n        mainCtx.translate(centerX, centerX)\n        mainCtx.rotate(-_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n        mainCtx.translate(-centerX, -centerX)\n      }\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n    mainCtx.restore()\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (RadialVertical);\n\n\n//# sourceURL=webpack://steelseries/./src/RadialVertical.js?");

/***/ }),

/***/ "./src/StopWatch.js":
/*!**************************!*\
  !*** ./src/StopWatch.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony import */ var _drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawRadialCustomImage */ \"./src/drawRadialCustomImage.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\nconst Stopwatch = function (canvas, parameters) {\n  parameters = parameters || {}\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let pointerColor =\n    undefined === parameters.pointerColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ColorDef\"].BLACK\n      : parameters.pointerColor\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"BackgroundColor\"].LIGHT_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_5__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  const customLayer =\n    undefined === parameters.customLayer ? null : parameters.customLayer\n\n  let minutePointerAngle = 0\n  let secondPointerAngle = 0\n  let tickTimer\n  const ANGLE_STEP = 6\n  const self = this\n\n  let start = 0\n  let currentMilliSeconds = 0\n  let minutes = 0\n  let seconds = 0\n  let milliSeconds = 0\n  let running = false\n  let lap = false\n  // Get the canvas context\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"getCanvasContext\"])(canvas)\n\n  let initialized = false\n\n  // Buffer for the frame\n  let frameContext\n\n  // Buffer for static background painting code\n  let backgroundContext\n\n  // Buffer for small pointer image painting code\n  let smallPointerContext\n\n  // Buffer for large pointer image painting code\n  let largePointerContext\n\n  // Buffer for static foreground painting code\n  let foregroundContext\n\n  const drawTickmarksImage = function (\n    ctx,\n    width,\n    range,\n    text_scale,\n    text_dist_factor,\n    x_offset,\n    y_offset\n  ) {\n    const STD_FONT_SIZE = text_scale * width\n    const STD_FONT = STD_FONT_SIZE + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_4__[\"stdFontName\"]\n    const TEXT_WIDTH = width * 0.15\n    const THIN_STROKE = 0.5\n    const MEDIUM_STROKE = 1\n    const THICK_STROKE = 1.5\n    const TEXT_DISTANCE = text_dist_factor * width\n    const MIN_LENGTH = Math.round(0.025 * width)\n    const MED_LENGTH = Math.round(0.035 * width)\n    const MAX_LENGTH = Math.round(0.045 * width)\n    const TEXT_COLOR = backgroundColor.labelColor.getRgbaColor()\n    const TICK_COLOR = backgroundColor.labelColor.getRgbaColor()\n    const CENTER = width / 2\n    // Create the ticks itself\n    const RADIUS = width * 0.4\n    let innerPoint\n    let outerPoint\n    let textPoint\n    let counter = 0\n    let numberCounter = 0\n    let valueCounter // value for the tickmarks\n    let sinValue = 0\n    let cosValue = 0\n    let alpha // angle for the tickmarks\n    const ALPHA_START = -_tools__WEBPACK_IMPORTED_MODULE_4__[\"PI\"]\n    const ANGLE_STEPSIZE = _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"] / range\n\n    ctx.width = ctx.height = width\n    ctx.save()\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.font = STD_FONT\n\n    for (\n      alpha = ALPHA_START, valueCounter = 0;\n      valueCounter <= range + 1;\n      alpha -= ANGLE_STEPSIZE * 0.1, valueCounter += 0.1\n    ) {\n      ctx.lineWidth = THIN_STROKE\n      sinValue = Math.sin(alpha)\n      cosValue = Math.cos(alpha)\n\n      // tickmark every 2 units\n      if (counter % 2 === 0) {\n        // ctx.lineWidth = THIN_STROKE;\n        innerPoint = [\n          CENTER + (RADIUS - MIN_LENGTH) * sinValue + x_offset,\n          CENTER + (RADIUS - MIN_LENGTH) * cosValue + y_offset\n        ]\n        outerPoint = [\n          CENTER + RADIUS * sinValue + x_offset,\n          CENTER + RADIUS * cosValue + y_offset\n        ]\n        // Draw ticks\n        ctx.strokeStyle = TICK_COLOR\n        ctx.beginPath()\n        ctx.moveTo(innerPoint[0], innerPoint[1])\n        ctx.lineTo(outerPoint[0], outerPoint[1])\n        ctx.closePath()\n        ctx.stroke()\n      }\n\n      // Different tickmark every 10 units\n      if (counter === 10 || counter === 0) {\n        ctx.fillStyle = TEXT_COLOR\n        ctx.lineWidth = MEDIUM_STROKE\n        outerPoint = [\n          CENTER + RADIUS * sinValue + x_offset,\n          CENTER + RADIUS * cosValue + y_offset\n        ]\n        textPoint = [\n          CENTER + (RADIUS - TEXT_DISTANCE) * sinValue + x_offset,\n          CENTER + (RADIUS - TEXT_DISTANCE) * cosValue + y_offset\n        ]\n\n        // Draw text\n        if (numberCounter === 5) {\n          if (valueCounter !== range) {\n            if (Math.round(valueCounter) !== 60) {\n              ctx.fillText(\n                Math.round(valueCounter),\n                textPoint[0],\n                textPoint[1],\n                TEXT_WIDTH\n              )\n            }\n          }\n          ctx.lineWidth = THICK_STROKE\n          innerPoint = [\n            CENTER + (RADIUS - MAX_LENGTH) * sinValue + x_offset,\n            CENTER + (RADIUS - MAX_LENGTH) * cosValue + y_offset\n          ]\n          numberCounter = 0\n        } else {\n          ctx.lineWidth = MEDIUM_STROKE\n          innerPoint = [\n            CENTER + (RADIUS - MED_LENGTH) * sinValue + x_offset,\n            CENTER + (RADIUS - MED_LENGTH) * cosValue + y_offset\n          ]\n        }\n\n        // Draw ticks\n        ctx.strokeStyle = TICK_COLOR\n        ctx.beginPath()\n        ctx.moveTo(innerPoint[0], innerPoint[1])\n        ctx.lineTo(outerPoint[0], outerPoint[1])\n        ctx.closePath()\n        ctx.stroke()\n\n        counter = 0\n        numberCounter++\n      }\n      counter++\n    }\n    ctx.restore()\n  }\n\n  const drawLargePointer = function (ctx) {\n    let grad\n    let radius\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.509345, imageWidth * 0.457943)\n    ctx.lineTo(imageWidth * 0.5, imageWidth * 0.102803)\n    ctx.lineTo(imageWidth * 0.490654, imageWidth * 0.457943)\n    ctx.bezierCurveTo(\n      imageWidth * 0.490654,\n      imageWidth * 0.457943,\n      imageWidth * 0.490654,\n      imageWidth * 0.457943,\n      imageWidth * 0.490654,\n      imageWidth * 0.457943\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.471962,\n      imageWidth * 0.462616,\n      imageWidth * 0.457943,\n      imageWidth * 0.481308,\n      imageWidth * 0.457943,\n      imageWidth * 0.5\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.457943,\n      imageWidth * 0.518691,\n      imageWidth * 0.471962,\n      imageWidth * 0.537383,\n      imageWidth * 0.490654,\n      imageWidth * 0.542056\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.490654,\n      imageWidth * 0.542056,\n      imageWidth * 0.490654,\n      imageWidth * 0.542056,\n      imageWidth * 0.490654,\n      imageWidth * 0.542056\n    )\n    ctx.lineTo(imageWidth * 0.490654, imageWidth * 0.621495)\n    ctx.lineTo(imageWidth * 0.509345, imageWidth * 0.621495)\n    ctx.lineTo(imageWidth * 0.509345, imageWidth * 0.542056)\n    ctx.bezierCurveTo(\n      imageWidth * 0.509345,\n      imageWidth * 0.542056,\n      imageWidth * 0.509345,\n      imageWidth * 0.542056,\n      imageWidth * 0.509345,\n      imageWidth * 0.542056\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.528037,\n      imageWidth * 0.537383,\n      imageWidth * 0.542056,\n      imageWidth * 0.518691,\n      imageWidth * 0.542056,\n      imageWidth * 0.5\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.542056,\n      imageWidth * 0.481308,\n      imageWidth * 0.528037,\n      imageWidth * 0.462616,\n      imageWidth * 0.509345,\n      imageWidth * 0.457943\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.509345,\n      imageWidth * 0.457943,\n      imageWidth * 0.509345,\n      imageWidth * 0.457943,\n      imageWidth * 0.509345,\n      imageWidth * 0.457943\n    )\n    ctx.closePath()\n    grad = ctx.createLinearGradient(0, 0, 0, imageWidth * 0.621495)\n    grad.addColorStop(0, pointerColor.medium.getRgbaColor())\n    grad.addColorStop(0.388888, pointerColor.medium.getRgbaColor())\n    grad.addColorStop(0.5, pointerColor.light.getRgbaColor())\n    grad.addColorStop(0.611111, pointerColor.medium.getRgbaColor())\n    grad.addColorStop(1, pointerColor.medium.getRgbaColor())\n    ctx.fillStyle = grad\n    ctx.strokeStyle = pointerColor.dark.getRgbaColor()\n    ctx.fill()\n    ctx.stroke()\n    // Draw the rings\n    ctx.beginPath()\n    radius = (imageWidth * 0.06542) / 2\n    ctx.arc(centerX, centerY, radius, 0, _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"])\n    grad = ctx.createLinearGradient(\n      centerX - radius,\n      centerX + radius,\n      0,\n      centerX + radius\n    )\n    grad.addColorStop(0, '#e6b35c')\n    grad.addColorStop(0.01, '#e6b35c')\n    grad.addColorStop(0.99, '#c48200')\n    grad.addColorStop(1, '#c48200')\n    ctx.fillStyle = grad\n    ctx.closePath()\n    ctx.fill()\n    ctx.beginPath()\n    radius = (imageWidth * 0.046728) / 2\n    ctx.arc(centerX, centerY, radius, 0, _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"])\n    grad = ctx.createRadialGradient(\n      centerX,\n      centerX,\n      0,\n      centerX,\n      centerX,\n      radius\n    )\n    grad.addColorStop(0, '#c5c5c5')\n    grad.addColorStop(0.19, '#c5c5c5')\n    grad.addColorStop(0.22, '#000000')\n    grad.addColorStop(0.8, '#000000')\n    grad.addColorStop(0.99, '#707070')\n    grad.addColorStop(1, '#707070')\n    ctx.fillStyle = grad\n    ctx.closePath()\n    ctx.fill()\n    ctx.restore()\n  }\n\n  const drawSmallPointer = function (ctx) {\n    let radius\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.476635, imageWidth * 0.313084)\n    ctx.bezierCurveTo(\n      imageWidth * 0.476635,\n      imageWidth * 0.322429,\n      imageWidth * 0.485981,\n      imageWidth * 0.331775,\n      imageWidth * 0.495327,\n      imageWidth * 0.336448\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.495327,\n      imageWidth * 0.336448,\n      imageWidth * 0.495327,\n      imageWidth * 0.350467,\n      imageWidth * 0.495327,\n      imageWidth * 0.350467\n    )\n    ctx.lineTo(imageWidth * 0.504672, imageWidth * 0.350467)\n    ctx.bezierCurveTo(\n      imageWidth * 0.504672,\n      imageWidth * 0.350467,\n      imageWidth * 0.504672,\n      imageWidth * 0.336448,\n      imageWidth * 0.504672,\n      imageWidth * 0.336448\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.514018,\n      imageWidth * 0.331775,\n      imageWidth * 0.523364,\n      imageWidth * 0.322429,\n      imageWidth * 0.523364,\n      imageWidth * 0.313084\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.523364,\n      imageWidth * 0.303738,\n      imageWidth * 0.514018,\n      imageWidth * 0.294392,\n      imageWidth * 0.504672,\n      imageWidth * 0.289719\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.504672,\n      imageWidth * 0.289719,\n      imageWidth * 0.5,\n      imageWidth * 0.200934,\n      imageWidth * 0.5,\n      imageWidth * 0.200934\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.5,\n      imageWidth * 0.200934,\n      imageWidth * 0.495327,\n      imageWidth * 0.289719,\n      imageWidth * 0.495327,\n      imageWidth * 0.289719\n    )\n    ctx.bezierCurveTo(\n      imageWidth * 0.485981,\n      imageWidth * 0.294392,\n      imageWidth * 0.476635,\n      imageWidth * 0.303738,\n      imageWidth * 0.476635,\n      imageWidth * 0.313084\n    )\n    ctx.closePath()\n    const grad = ctx.createLinearGradient(0, 0, imageWidth, 0)\n    grad.addColorStop(0, pointerColor.medium.getRgbaColor())\n    grad.addColorStop(0.388888, pointerColor.medium.getRgbaColor())\n    grad.addColorStop(0.5, pointerColor.light.getRgbaColor())\n    grad.addColorStop(0.611111, pointerColor.medium.getRgbaColor())\n    grad.addColorStop(1, pointerColor.medium.getRgbaColor())\n    ctx.fillStyle = grad\n    ctx.strokeStyle = pointerColor.dark.getRgbaColor()\n    ctx.fill()\n    ctx.stroke()\n    // Draw the rings\n    ctx.beginPath()\n    radius = (imageWidth * 0.037383) / 2\n    ctx.arc(\n      centerX,\n      smallPointerY_Offset + smallPointerSize / 2,\n      radius,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"]\n    )\n    ctx.fillStyle = '#C48200'\n    ctx.closePath()\n    ctx.fill()\n    ctx.beginPath()\n    radius = (imageWidth * 0.028037) / 2\n    ctx.arc(\n      centerX,\n      smallPointerY_Offset + smallPointerSize / 2,\n      radius,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"]\n    )\n    ctx.fillStyle = '#999999'\n    ctx.closePath()\n    ctx.fill()\n    ctx.beginPath()\n    radius = (imageWidth * 0.018691) / 2\n    ctx.arc(\n      centerX,\n      smallPointerY_Offset + smallPointerSize / 2,\n      radius,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_4__[\"TWO_PI\"]\n    )\n    ctx.fillStyle = '#000000'\n    ctx.closePath()\n    ctx.fill()\n    ctx.restore()\n  }\n\n  const calculateAngles = function () {\n    currentMilliSeconds = new Date().getTime() - start\n    secondPointerAngle = (currentMilliSeconds * ANGLE_STEP) / 1000\n    minutePointerAngle = (secondPointerAngle % 10800) / 30\n\n    minutes = (currentMilliSeconds / 60000) % 30\n    seconds = (currentMilliSeconds / 1000) % 60\n    milliSeconds = currentMilliSeconds % 1000\n  }\n\n  const init = function (parameters) {\n    parameters = parameters || {}\n    const drawFrame2 =\n      undefined === parameters.frame ? false : parameters.frame\n    const drawBackground2 =\n      undefined === parameters.background ? false : parameters.background\n    const drawPointers =\n      undefined === parameters.pointers ? false : parameters.pointers\n    const drawForeground2 =\n      undefined === parameters.foreground ? false : parameters.foreground\n\n    initialized = true\n\n    if (drawFrame2 && frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\n        frameContext,\n        frameDesign,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    if (drawBackground2 && backgroundVisible) {\n      // Create background in background buffer (backgroundBuffer)\n      Object(_drawBackground__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      // Create custom layer in background buffer (backgroundBuffer)\n      Object(_drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        backgroundContext,\n        customLayer,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      drawTickmarksImage(backgroundContext, imageWidth, 60, 0.075, 0.1, 0, 0)\n      drawTickmarksImage(\n        backgroundContext,\n        smallPointerSize,\n        30,\n        0.095,\n        0.13,\n        smallPointerX_Offset,\n        smallPointerY_Offset\n      )\n    }\n    if (drawPointers) {\n      drawLargePointer(largePointerContext)\n      drawSmallPointer(smallPointerContext)\n    }\n\n    if (drawForeground2 && foregroundVisible) {\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        false\n      )\n    }\n  }\n\n  const resetBuffers = function (buffers) {\n    buffers = buffers || {}\n    const resetFrame = undefined === buffers.frame ? false : buffers.frame\n    const resetBackground =\n      undefined === buffers.background ? false : buffers.background\n    const resetPointers =\n      undefined === buffers.pointers ? false : buffers.pointers\n    const resetForeground =\n      undefined === buffers.foreground ? false : buffers.foreground\n\n    if (resetFrame) {\n      frameBuffer.width = size\n      frameBuffer.height = size\n      frameContext = frameBuffer.getContext('2d')\n    }\n\n    if (resetBackground) {\n      backgroundBuffer.width = size\n      backgroundBuffer.height = size\n      backgroundContext = backgroundBuffer.getContext('2d')\n    }\n\n    if (resetPointers) {\n      smallPointerBuffer.width = size\n      smallPointerBuffer.height = size\n      smallPointerContext = smallPointerBuffer.getContext('2d')\n\n      largePointerBuffer.width = size\n      largePointerBuffer.height = size\n      largePointerContext = largePointerBuffer.getContext('2d')\n    }\n\n    if (resetForeground) {\n      foregroundBuffer.width = size\n      foregroundBuffer.height = size\n      foregroundContext = foregroundBuffer.getContext('2d')\n    }\n  }\n\n  const tickTock = function () {\n    if (!lap) {\n      calculateAngles()\n      self.repaint()\n    }\n    if (running) {\n      tickTimer = setTimeout(tickTock, 200)\n    }\n  }\n\n  //* *********************************** Public methods **************************************\n  // Returns true if the stopwatch is running\n  this.isRunning = function () {\n    return running\n  }\n\n  // Starts the stopwatch\n  this.start = function () {\n    if (!running) {\n      running = true\n      start = new Date().getTime() - currentMilliSeconds\n      tickTock()\n    }\n    return this\n  }\n\n  // Stops the stopwatch\n  this.stop = function () {\n    if (running) {\n      running = false\n      clearTimeout(tickTimer)\n      // calculateAngles();\n    }\n    if (lap) {\n      lap = false\n      calculateAngles()\n      this.repaint()\n    }\n    return this\n  }\n\n  // Resets the stopwatch\n  this.reset = function () {\n    if (running) {\n      running = false\n      lap = false\n      clearTimeout(tickTimer)\n    }\n    start = new Date().getTime()\n    calculateAngles()\n    this.repaint()\n    return this\n  }\n\n  // Laptimer, stop/restart stopwatch\n  this.lap = function () {\n    if (running && !lap) {\n      lap = true\n    } else if (lap) {\n      lap = false\n    }\n    return this\n  }\n\n  this.getMeasuredTime = function () {\n    return minutes + ':' + seconds + ':' + milliSeconds\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    resetBuffers({\n      frame: true\n    })\n    frameDesign = newFrameDesign\n    init({\n      frame: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    resetBuffers({\n      background: true\n    })\n    backgroundColor = newBackgroundColor\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers({\n      foreground: true\n    })\n    foregroundType = newForegroundType\n    init({\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerColor = function (newPointerColor) {\n    resetBuffers({\n      pointers: true\n    })\n    pointerColor = newPointerColor\n    init({\n      pointers: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init({\n        frame: true,\n        background: true,\n        pointers: true,\n        foreground: true\n      })\n    }\n\n    mainCtx.clearRect(0, 0, imageWidth, imageHeight)\n\n    // Draw frame\n    if (frameVisible) {\n      mainCtx.drawImage(frameBuffer, 0, 0)\n    }\n\n    // Draw buffered image to visible canvas\n    if (backgroundVisible) {\n      mainCtx.drawImage(backgroundBuffer, 0, 0)\n    }\n\n    // have to draw to a rotated temporary image area so we can translate in\n    // absolute x, y values when drawing to main context\n    const shadowOffset = imageWidth * 0.006\n\n    const rotationAngle =\n      (minutePointerAngle + 2 * Math.sin(minutePointerAngle * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"])) *\n      _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]\n    const secRotationAngle =\n      (secondPointerAngle + 2 * Math.sin(secondPointerAngle * _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"])) *\n      _tools__WEBPACK_IMPORTED_MODULE_4__[\"RAD_FACTOR\"]\n\n    // Draw the minute pointer\n    // Define rotation center\n    mainCtx.save()\n    mainCtx.translate(centerX, smallPointerY_Offset + smallPointerSize / 2)\n    mainCtx.rotate(rotationAngle)\n    mainCtx.translate(-centerX, -(smallPointerY_Offset + smallPointerSize / 2))\n    // Set the pointer shadow params\n    mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset / 2\n    mainCtx.shadowBlur = shadowOffset\n    // Draw the pointer\n    mainCtx.drawImage(smallPointerBuffer, 0, 0)\n    mainCtx.restore()\n\n    // Draw the second pointer\n    // Define rotation center\n    mainCtx.save()\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(secRotationAngle)\n    mainCtx.translate(-centerX, -centerY)\n    // Set the pointer shadow params\n    mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset / 2\n    mainCtx.shadowBlur = shadowOffset\n    // Draw the pointer\n    mainCtx.drawImage(largePointerBuffer, 0, 0)\n    // Undo the translations & shadow settings\n    mainCtx.restore()\n\n    // Draw the foreground\n    if (foregroundVisible) {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n  }\n\n  // Has a size been specified?\n  size =\n    size === 0 ? Math.min(mainCtx.canvas.width, mainCtx.canvas.height) : size\n\n  // Set the size - also clears it\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  const imageWidth = size\n  const imageHeight = size\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight / 2\n\n  const smallPointerSize = 0.285 * imageWidth\n  const smallPointerX_Offset = centerX - smallPointerSize / 2\n  const smallPointerY_Offset = 0.17 * imageWidth\n\n  // Buffer for the frame\n  const frameBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  frameContext = frameBuffer.getContext('2d')\n\n  // Buffer for static background painting code\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  backgroundContext = backgroundBuffer.getContext('2d')\n\n  // Buffer for small pointer image painting code\n  const smallPointerBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  smallPointerContext = smallPointerBuffer.getContext('2d')\n\n  // Buffer for large pointer image painting code\n  const largePointerBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  largePointerContext = largePointerBuffer.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_4__[\"createBuffer\"])(size, size)\n  foregroundContext = foregroundBuffer.getContext('2d')\n\n  // Visualize the component\n  start = new Date().getTime()\n  tickTock()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Stopwatch);\n\n\n//# sourceURL=webpack://steelseries/./src/StopWatch.js?");

/***/ }),

/***/ "./src/TrafficLight.js":
/*!*****************************!*\
  !*** ./src/TrafficLight.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst Trafficlight = function (canvas, parameters) {\n  parameters = parameters || {}\n  let width = undefined === parameters.width ? 0 : parameters.width\n  let height = undefined === parameters.height ? 0 : parameters.height\n  //\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"getCanvasContext\"])(canvas)\n  let redOn = false\n  let yellowOn = false\n  let greenOn = false\n  let initialized = false\n  const housingBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const housingCtx = housingBuffer.getContext('2d')\n  const lightGreenBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const lightGreenCtx = lightGreenBuffer.getContext('2d')\n  const greenOnBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const greenOnCtx = greenOnBuffer.getContext('2d')\n  const greenOffBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const greenOffCtx = greenOffBuffer.getContext('2d')\n  const lightYellowBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const lightYellowCtx = lightYellowBuffer.getContext('2d')\n  const yellowOnBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const yellowOnCtx = yellowOnBuffer.getContext('2d')\n  const yellowOffBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const yellowOffCtx = yellowOffBuffer.getContext('2d')\n  const lightRedBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const lightRedCtx = lightRedBuffer.getContext('2d')\n  const redOnBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const redOnCtx = redOnBuffer.getContext('2d')\n  const redOffBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n  const redOffCtx = redOffBuffer.getContext('2d')\n  // End of variables\n\n  // Has a size been specified?\n  if (width === 0) {\n    width = mainCtx.canvas.width\n  }\n  if (height === 0) {\n    height = mainCtx.canvas.height\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = width\n  mainCtx.canvas.height = height\n\n  const prefHeight = width < height * 0.352517 ? width * 2.836734 : height\n  const imageWidth = prefHeight * 0.352517\n  const imageHeight = prefHeight\n\n  housingBuffer.width = imageWidth\n  housingBuffer.height = imageHeight\n\n  lightGreenBuffer.width = imageWidth\n  lightGreenBuffer.height = imageHeight\n\n  greenOnBuffer.width = imageWidth\n  greenOnBuffer.height = imageHeight\n\n  greenOffBuffer.width = imageWidth\n  greenOffBuffer.height = imageHeight\n\n  lightYellowBuffer.width = imageWidth\n  lightYellowBuffer.height = imageHeight\n\n  yellowOnBuffer.width = imageWidth\n  yellowOnBuffer.height = imageHeight\n\n  yellowOffBuffer.width = imageWidth\n  yellowOffBuffer.height = imageHeight\n\n  lightRedBuffer.width = imageWidth\n  lightRedBuffer.height = imageHeight\n\n  redOnBuffer.width = imageWidth\n  redOnBuffer.height = imageHeight\n\n  redOffBuffer.width = imageWidth\n  redOffBuffer.height = imageHeight\n\n  const drawHousing = function (ctx) {\n    ctx.save()\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0.107142 * imageWidth, 0)\n    ctx.lineTo(imageWidth - 0.107142 * imageWidth, 0)\n    ctx.quadraticCurveTo(imageWidth, 0, imageWidth, 0.107142 * imageWidth)\n    ctx.lineTo(imageWidth, imageHeight - 0.107142 * imageWidth)\n    ctx.quadraticCurveTo(\n      imageWidth,\n      imageHeight,\n      imageWidth - 0.107142 * imageWidth,\n      imageHeight\n    )\n    ctx.lineTo(0.107142 * imageWidth, imageHeight)\n    ctx.quadraticCurveTo(\n      0,\n      imageHeight,\n      0,\n      imageHeight - 0.107142 * imageWidth\n    )\n    ctx.lineTo(0, 0.107142 * imageWidth)\n    ctx.quadraticCurveTo(0, 0, 0.107142 * imageWidth, imageHeight)\n    ctx.closePath()\n    const housingFill = ctx.createLinearGradient(\n      0.040816 * imageWidth,\n      0.007194 * imageHeight,\n      0.952101 * imageWidth,\n      0.995882 * imageHeight\n    )\n    housingFill.addColorStop(0, 'rgb(152, 152, 154)')\n    housingFill.addColorStop(0.01, 'rgb(152, 152, 154)')\n    housingFill.addColorStop(0.09, '#333333')\n    housingFill.addColorStop(0.24, 'rgb(152, 152, 154)')\n    housingFill.addColorStop(0.55, 'rgb(31, 31, 31)')\n    housingFill.addColorStop(0.78, '#363636')\n    housingFill.addColorStop(0.98, '#000000')\n    housingFill.addColorStop(1, '#000000')\n    ctx.fillStyle = housingFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(\n      0.030612 * imageWidth + 0.084183 * imageWidth,\n      0.010791 * imageHeight\n    )\n    ctx.lineTo(\n      0.030612 * imageWidth + 0.938775 * imageWidth - 0.084183 * imageWidth,\n      0.010791 * imageHeight\n    )\n    ctx.quadraticCurveTo(\n      0.030612 * imageWidth + 0.938775 * imageWidth,\n      0.010791 * imageHeight,\n      0.030612 * imageWidth + 0.938775 * imageWidth,\n      0.010791 * imageHeight + 0.084183 * imageWidth\n    )\n    ctx.lineTo(\n      0.030612 * imageWidth + 0.938775 * imageWidth,\n      0.010791 * imageHeight + 0.978417 * imageHeight - 0.084183 * imageWidth\n    )\n    ctx.quadraticCurveTo(\n      0.030612 * imageWidth + 0.938775 * imageWidth,\n      0.010791 * imageHeight + 0.978417 * imageHeight,\n      0.030612 * imageWidth + 0.938775 * imageWidth - 0.084183 * imageWidth,\n      0.010791 * imageHeight + 0.978417 * imageHeight\n    )\n    ctx.lineTo(\n      0.030612 * imageWidth + 0.084183 * imageWidth,\n      0.010791 * imageHeight + 0.978417 * imageHeight\n    )\n    ctx.quadraticCurveTo(\n      0.030612 * imageWidth,\n      0.010791 * imageHeight + 0.978417 * imageHeight,\n      0.030612 * imageWidth,\n      0.010791 * imageHeight + 0.978417 * imageHeight - 0.084183 * imageWidth\n    )\n    ctx.lineTo(\n      0.030612 * imageWidth,\n      0.010791 * imageHeight + 0.084183 * imageWidth\n    )\n    ctx.quadraticCurveTo(\n      0.030612 * imageWidth,\n      0.010791 * imageHeight,\n      0.030612 * imageWidth + 0.084183 * imageWidth,\n      0.010791 * imageHeight\n    )\n    ctx.closePath()\n    const housingFrontFill = ctx.createLinearGradient(\n      -0.132653 * imageWidth,\n      -0.053956 * imageHeight,\n      2.061408 * imageWidth,\n      0.667293 * imageHeight\n    )\n    housingFrontFill.addColorStop(0, '#000000')\n    housingFrontFill.addColorStop(0.01, '#000000')\n    housingFrontFill.addColorStop(0.16, '#373735')\n    housingFrontFill.addColorStop(0.31, '#000000')\n    housingFrontFill.addColorStop(0.44, '#303030')\n    housingFrontFill.addColorStop(0.65, '#000000')\n    housingFrontFill.addColorStop(0.87, '#363636')\n    housingFrontFill.addColorStop(0.98, '#000000')\n    housingFrontFill.addColorStop(1, '#000000')\n    ctx.fillStyle = housingFrontFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.restore()\n  }\n\n  const drawLightGreen = function (ctx) {\n    ctx.save()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.805755 * imageHeight,\n      0.397959 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightGreenFrameFill = ctx.createLinearGradient(\n      0,\n      0.665467 * imageHeight,\n      0,\n      0.946043 * imageHeight\n    )\n    lightGreenFrameFill.addColorStop(0, '#ffffff')\n    lightGreenFrameFill.addColorStop(0.05, 'rgb(204, 204, 204)')\n    lightGreenFrameFill.addColorStop(0.1, 'rgb(153, 153, 153)')\n    lightGreenFrameFill.addColorStop(0.17, '#666666')\n    lightGreenFrameFill.addColorStop(0.27, '#333333')\n    lightGreenFrameFill.addColorStop(1, '#010101')\n    ctx.fillStyle = lightGreenFrameFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.scale(1.083333, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.461538 * imageWidth,\n      0.816546 * imageHeight,\n      0.367346 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightGreenInnerFill = ctx.createLinearGradient(\n      0,\n      0.68705 * imageHeight,\n      0,\n      0.946043 * imageHeight\n    )\n    lightGreenInnerFill.addColorStop(0, '#000000')\n    lightGreenInnerFill.addColorStop(0.35, '#040404')\n    lightGreenInnerFill.addColorStop(0.66, '#000000')\n    lightGreenInnerFill.addColorStop(1, '#010101')\n    ctx.fillStyle = lightGreenInnerFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.357142 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightGreenEffectFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.362244 * imageWidth\n    )\n    lightGreenEffectFill.addColorStop(0, '#000000')\n    lightGreenEffectFill.addColorStop(0.88, '#000000')\n    lightGreenEffectFill.addColorStop(0.95, 'rgb(94, 94, 94)')\n    lightGreenEffectFill.addColorStop(1, '#010101')\n    ctx.fillStyle = lightGreenEffectFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.357142 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightGreenInnerShadowFill = ctx.createLinearGradient(\n      0,\n      0.68705 * imageHeight,\n      0,\n      0.917266 * imageHeight\n    )\n    lightGreenInnerShadowFill.addColorStop(0, '#000000')\n    lightGreenInnerShadowFill.addColorStop(1, 'rgba(1, 1, 1, 0)')\n    ctx.fillStyle = lightGreenInnerShadowFill\n    ctx.fill()\n    ctx.restore()\n    ctx.restore()\n  }\n\n  const drawGreenOn = function (ctx) {\n    ctx.save()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.32653 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const greenOnFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.32653 * imageWidth\n    )\n    greenOnFill.addColorStop(0, 'rgb(85, 185, 123)')\n    greenOnFill.addColorStop(1, 'rgb(0, 31, 0)')\n    ctx.fillStyle = greenOnFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0, 0.812949 * imageHeight)\n    ctx.bezierCurveTo(\n      0,\n      0.910071 * imageHeight,\n      0.224489 * imageWidth,\n      0.989208 * imageHeight,\n      0.5 * imageWidth,\n      0.989208 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.77551 * imageWidth,\n      0.989208 * imageHeight,\n      imageWidth,\n      0.910071 * imageHeight,\n      imageWidth,\n      0.809352 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.908163 * imageWidth,\n      0.751798 * imageHeight,\n      0.704081 * imageWidth,\n      0.68705 * imageHeight,\n      0.5 * imageWidth,\n      0.68705 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.285714 * imageWidth,\n      0.68705 * imageHeight,\n      0.081632 * imageWidth,\n      0.751798 * imageHeight,\n      0,\n      0.812949 * imageHeight\n    )\n    ctx.closePath()\n    const greenOnGlowFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.515306 * imageWidth\n    )\n    greenOnGlowFill.addColorStop(0, 'rgb(65, 187, 126)')\n    greenOnGlowFill.addColorStop(1, 'rgba(4, 37, 8, 0)')\n    ctx.fillStyle = greenOnGlowFill\n    ctx.fill()\n    ctx.restore()\n    ctx.restore()\n  }\n\n  const drawGreenOff = function (ctx) {\n    ctx.save()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.32653 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const greenOffFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.32653 * imageWidth\n    )\n    greenOffFill.addColorStop(0, 'rgba(0, 255, 0, 0.25)')\n    greenOffFill.addColorStop(1, 'rgba(0, 255, 0, 0.05)')\n    ctx.fillStyle = greenOffFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.32653 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const greenOffInnerShadowFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.809352 * imageHeight,\n      0.32653 * imageWidth\n    )\n    greenOffInnerShadowFill.addColorStop(0, 'rgba(1, 1, 1, 0)')\n    greenOffInnerShadowFill.addColorStop(0.55, 'rgba(0, 0, 0, 0)')\n    greenOffInnerShadowFill.addColorStop(0.5501, 'rgba(0, 0, 0, 0)')\n    greenOffInnerShadowFill.addColorStop(0.78, 'rgba(0, 0, 0, 0.12)')\n    greenOffInnerShadowFill.addColorStop(0.79, 'rgba(0, 0, 0, 0.12)')\n    greenOffInnerShadowFill.addColorStop(1, 'rgba(0, 0, 0, 0.5)')\n    ctx.fillStyle = greenOffInnerShadowFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.fillStyle = ctx.createPattern(hatchBuffer, 'repeat')\n    ctx.fill()\n\n    ctx.restore()\n  }\n\n  const drawLightYellow = function (ctx) {\n    ctx.save()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.496402 * imageHeight,\n      0.397959 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightYellowFrameFill = ctx.createLinearGradient(\n      0,\n      0.356115 * imageHeight,\n      0,\n      0.63669 * imageHeight\n    )\n    lightYellowFrameFill.addColorStop(0, '#ffffff')\n    lightYellowFrameFill.addColorStop(0.05, 'rgb(204, 204, 204)')\n    lightYellowFrameFill.addColorStop(0.1, 'rgb(153, 153, 153)')\n    lightYellowFrameFill.addColorStop(0.17, '#666666')\n    lightYellowFrameFill.addColorStop(0.27, '#333333')\n    lightYellowFrameFill.addColorStop(1, '#010101')\n    ctx.fillStyle = lightYellowFrameFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.scale(1.083333, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.461538 * imageWidth,\n      0.507194 * imageHeight,\n      0.367346 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightYellowInnerFill = ctx.createLinearGradient(\n      0,\n      0.377697 * imageHeight,\n      0,\n      0.63669 * imageHeight\n    )\n    lightYellowInnerFill.addColorStop(0, '#000000')\n    lightYellowInnerFill.addColorStop(0.35, '#040404')\n    lightYellowInnerFill.addColorStop(0.66, '#000000')\n    lightYellowInnerFill.addColorStop(1, '#010101')\n    ctx.fillStyle = lightYellowInnerFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.357142 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightYellowEffectFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.362244 * imageWidth\n    )\n    lightYellowEffectFill.addColorStop(0, '#000000')\n    lightYellowEffectFill.addColorStop(0.88, '#000000')\n    lightYellowEffectFill.addColorStop(0.95, '#5e5e5e')\n    lightYellowEffectFill.addColorStop(1, '#010101')\n    ctx.fillStyle = lightYellowEffectFill\n    ctx.fill()\n    ctx.restore()\n\n    // lIGHT_YELLOW_4_E_INNER_SHADOW_3_4\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.357142 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightYellowInnerShadowFill = ctx.createLinearGradient(\n      0,\n      0.377697 * imageHeight,\n      0,\n      0.607913 * imageHeight\n    )\n    lightYellowInnerShadowFill.addColorStop(0, '#000000')\n    lightYellowInnerShadowFill.addColorStop(1, 'rgba(1, 1, 1, 0)')\n    ctx.fillStyle = lightYellowInnerShadowFill\n    ctx.fill()\n    ctx.restore()\n    ctx.restore()\n  }\n\n  const drawYellowOn = function (ctx) {\n    ctx.save()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.32653 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const yellowOnFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.32653 * imageWidth\n    )\n    yellowOnFill.addColorStop(0, '#fed434')\n    yellowOnFill.addColorStop(1, '#82330c')\n    ctx.fillStyle = yellowOnFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0, 0.503597 * imageHeight)\n    ctx.bezierCurveTo(\n      0,\n      0.600719 * imageHeight,\n      0.224489 * imageWidth,\n      0.679856 * imageHeight,\n      0.5 * imageWidth,\n      0.679856 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.77551 * imageWidth,\n      0.679856 * imageHeight,\n      imageWidth,\n      0.600719 * imageHeight,\n      imageWidth,\n      0.5 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.908163 * imageWidth,\n      0.442446 * imageHeight,\n      0.704081 * imageWidth,\n      0.377697 * imageHeight,\n      0.5 * imageWidth,\n      0.377697 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.285714 * imageWidth,\n      0.377697 * imageHeight,\n      0.081632 * imageWidth,\n      0.442446 * imageHeight,\n      0,\n      0.503597 * imageHeight\n    )\n    ctx.closePath()\n    const yellowOnGlowFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.515306 * imageWidth\n    )\n    yellowOnGlowFill.addColorStop(0, '#fed434')\n    yellowOnGlowFill.addColorStop(1, 'rgba(130, 51, 12, 0)')\n    ctx.fillStyle = yellowOnGlowFill\n    ctx.fill()\n    ctx.restore()\n    ctx.restore()\n  }\n\n  const drawYellowOff = function (ctx) {\n    ctx.save()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.32653 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const yellowOffFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.32653 * imageWidth\n    )\n    yellowOffFill.addColorStop(0, 'rgba(255, 255, 0, 0.25)')\n    yellowOffFill.addColorStop(1, 'rgba(255, 255, 0, 0.05)')\n    ctx.fillStyle = yellowOffFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.32653 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const yellowOffInnerShadowFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.5 * imageHeight,\n      0.32653 * imageWidth\n    )\n    yellowOffInnerShadowFill.addColorStop(0, 'rgba(1, 1, 1, 0)')\n    yellowOffInnerShadowFill.addColorStop(0.55, 'rgba(0, 0, 0, 0)')\n    yellowOffInnerShadowFill.addColorStop(0.5501, 'rgba(0, 0, 0, 0)')\n    yellowOffInnerShadowFill.addColorStop(0.78, 'rgba(0, 0, 0, 0.12)')\n    yellowOffInnerShadowFill.addColorStop(0.79, 'rgba(0, 0, 0, 0.13)')\n    yellowOffInnerShadowFill.addColorStop(1, 'rgba(0, 0, 0, 0.5)')\n    ctx.fillStyle = yellowOffInnerShadowFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.fillStyle = ctx.createPattern(hatchBuffer, 'repeat')\n    ctx.fill()\n\n    ctx.restore()\n  }\n\n  const drawLightRed = function (ctx) {\n    ctx.save()\n\n    // lIGHT_RED_7_E_FRAME_0_1\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.18705 * imageHeight,\n      0.397959 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightRedFrameFill = ctx.createLinearGradient(\n      0.5 * imageWidth,\n      0.046762 * imageHeight,\n      0.5 * imageWidth,\n      0.327338 * imageHeight\n    )\n    lightRedFrameFill.addColorStop(0, '#ffffff')\n    lightRedFrameFill.addColorStop(0.05, '#cccccc')\n    lightRedFrameFill.addColorStop(0.1, '#999999')\n    lightRedFrameFill.addColorStop(0.17, '#666666')\n    lightRedFrameFill.addColorStop(0.27, '#333333')\n    lightRedFrameFill.addColorStop(1, '#010101')\n    ctx.fillStyle = lightRedFrameFill\n    ctx.fill()\n    ctx.restore()\n\n    // lIGHT_RED_7_E_INNER_CLIP_1_2\n    ctx.save()\n    ctx.scale(1.083333, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.461538 * imageWidth,\n      0.197841 * imageHeight,\n      0.367346 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightRedInnerFill = ctx.createLinearGradient(\n      0.5 * imageWidth,\n      0.068345 * imageHeight,\n      0.5 * imageWidth,\n      0.327338 * imageHeight\n    )\n    lightRedInnerFill.addColorStop(0, '#000000')\n    lightRedInnerFill.addColorStop(0.35, '#040404')\n    lightRedInnerFill.addColorStop(0.66, '#000000')\n    lightRedInnerFill.addColorStop(1, '#010101')\n    ctx.fillStyle = lightRedInnerFill\n    ctx.fill()\n    ctx.restore()\n\n    // lIGHT_RED_7_E_LIGHT_EFFECT_2_3\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.357142 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightRedEffectFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.362244 * imageWidth\n    )\n    lightRedEffectFill.addColorStop(0, '#000000')\n    lightRedEffectFill.addColorStop(0.88, '#000000')\n    lightRedEffectFill.addColorStop(0.95, '#5e5e5e')\n    lightRedEffectFill.addColorStop(1, '#010101')\n    ctx.fillStyle = lightRedEffectFill\n    ctx.fill()\n    ctx.restore()\n\n    // lIGHT_RED_7_E_INNER_SHADOW_3_4\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.357142 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const lightRedInnerShadowFill = ctx.createLinearGradient(\n      0.5 * imageWidth,\n      0.068345 * imageHeight,\n      0.5 * imageWidth,\n      0.298561 * imageHeight\n    )\n    lightRedInnerShadowFill.addColorStop(0, '#000000')\n    lightRedInnerShadowFill.addColorStop(1, 'rgba(1, 1, 1, 0)')\n    ctx.fillStyle = lightRedInnerShadowFill\n    ctx.fill()\n    ctx.restore()\n    ctx.restore()\n  }\n\n  const drawRedOn = function (ctx) {\n    ctx.save()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.32653 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const redOnFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.32653 * imageWidth\n    )\n    redOnFill.addColorStop(0, '#ff0000')\n    redOnFill.addColorStop(1, '#410004')\n    ctx.fillStyle = redOnFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(0, 0.194244 * imageHeight)\n    ctx.bezierCurveTo(\n      0,\n      0.291366 * imageHeight,\n      0.224489 * imageWidth,\n      0.370503 * imageHeight,\n      0.5 * imageWidth,\n      0.370503 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.77551 * imageWidth,\n      0.370503 * imageHeight,\n      imageWidth,\n      0.291366 * imageHeight,\n      imageWidth,\n      0.190647 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.908163 * imageWidth,\n      0.133093 * imageHeight,\n      0.704081 * imageWidth,\n      0.068345 * imageHeight,\n      0.5 * imageWidth,\n      0.068345 * imageHeight\n    )\n    ctx.bezierCurveTo(\n      0.285714 * imageWidth,\n      0.068345 * imageHeight,\n      0.081632 * imageWidth,\n      0.133093 * imageHeight,\n      0,\n      0.194244 * imageHeight\n    )\n    ctx.closePath()\n    const redOnGlowFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.515306 * imageWidth\n    )\n    redOnGlowFill.addColorStop(0, '#ff0000')\n    redOnGlowFill.addColorStop(1, 'rgba(118, 5, 1, 0)')\n    ctx.fillStyle = redOnGlowFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.restore()\n  }\n\n  const drawRedOff = function (ctx) {\n    ctx.save()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.32653 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const redOffFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.32653 * imageWidth\n    )\n    redOffFill.addColorStop(0, 'rgba(255, 0, 0, 0.25)')\n    redOffFill.addColorStop(1, 'rgba(255, 0, 0, 0.05)')\n    ctx.fillStyle = redOffFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.save()\n    ctx.scale(1, 1)\n    ctx.beginPath()\n    ctx.arc(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.32653 * imageWidth,\n      0,\n      _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n      false\n    )\n    const redOffInnerShadowFill = ctx.createRadialGradient(\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0,\n      0.5 * imageWidth,\n      0.190647 * imageHeight,\n      0.32653 * imageWidth\n    )\n    redOffInnerShadowFill.addColorStop(0, 'rgba(1, 1, 1, 0)')\n    redOffInnerShadowFill.addColorStop(0.55, 'rgba(0, 0, 0, 0)')\n    redOffInnerShadowFill.addColorStop(0.5501, 'rgba(0, 0, 0, 0)')\n    redOffInnerShadowFill.addColorStop(0.78, 'rgba(0, 0, 0, 0.12)')\n    redOffInnerShadowFill.addColorStop(0.79, 'rgba(0, 0, 0, 0.13)')\n    redOffInnerShadowFill.addColorStop(1, 'rgba(0, 0, 0, 0.5)')\n    ctx.fillStyle = redOffInnerShadowFill\n    ctx.fill()\n    ctx.restore()\n\n    ctx.fillStyle = ctx.createPattern(hatchBuffer, 'repeat')\n    ctx.fill()\n\n    ctx.restore()\n  }\n\n  function drawToBuffer (width, height, drawFunction) {\n    const buffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n    buffer.width = width\n    buffer.height = height\n    drawFunction(buffer.getContext('2d'))\n    return buffer\n  }\n\n  const hatchBuffer = drawToBuffer(2, 2, function (ctx) {\n    ctx.save()\n    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)'\n    ctx.beginPath()\n    ctx.lineTo(0, 0, 1, 0)\n    ctx.lineTo(0, 1, 0, 1)\n    ctx.stroke()\n    ctx.restore()\n  })\n\n  const init = function () {\n    initialized = true\n\n    drawHousing(housingCtx)\n    drawLightGreen(lightGreenCtx)\n    drawGreenOn(greenOnCtx)\n    drawGreenOff(greenOffCtx)\n    drawLightYellow(lightYellowCtx)\n    drawYellowOn(yellowOnCtx)\n    drawYellowOff(yellowOffCtx)\n    drawLightRed(lightRedCtx)\n    drawRedOn(redOnCtx)\n    drawRedOff(redOffCtx)\n  }\n\n  // **************   P U B L I C   M E T H O D S   ********************************\n  this.setRedOn = function (on) {\n    redOn = !!on\n    this.repaint()\n  }\n\n  this.isRedOn = function () {\n    return redOn\n  }\n\n  this.setYellowOn = function (on) {\n    yellowOn = !!on\n    this.repaint()\n  }\n\n  this.isYellowOn = function () {\n    return yellowOn\n  }\n\n  this.setGreenOn = function (on) {\n    greenOn = !!on\n    this.repaint()\n  }\n\n  this.isGreenOn = function () {\n    return greenOn\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init()\n    }\n\n    mainCtx.save()\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    // housing\n    mainCtx.drawImage(housingBuffer, 0, 0)\n\n    // Green light\n    mainCtx.drawImage(lightGreenBuffer, 0, 0)\n\n    if (greenOn) {\n      mainCtx.drawImage(greenOnBuffer, 0, 0)\n    }\n\n    mainCtx.drawImage(greenOffBuffer, 0, 0)\n\n    // Yellow light\n    mainCtx.drawImage(lightYellowBuffer, 0, 0)\n\n    if (yellowOn) {\n      mainCtx.drawImage(yellowOnBuffer, 0, 0)\n    }\n\n    mainCtx.drawImage(yellowOffBuffer, 0, 0)\n\n    // Red light\n    mainCtx.drawImage(lightRedBuffer, 0, 0)\n\n    if (redOn) {\n      mainCtx.drawImage(redOnBuffer, 0, 0)\n    }\n\n    mainCtx.drawImage(redOffBuffer, 0, 0)\n    mainCtx.restore()\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Trafficlight);\n\n\n//# sourceURL=webpack://steelseries/./src/TrafficLight.js?");

/***/ }),

/***/ "./src/WindDirection.js":
/*!******************************!*\
  !*** ./src/WindDirection.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ \"./src/tween.js\");\n/* harmony import */ var _drawPointerImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawPointerImage */ \"./src/drawPointerImage.js\");\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony import */ var _drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawRadialCustomImage */ \"./src/drawRadialCustomImage.js\");\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony import */ var _createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createLcdBackgroundImage */ \"./src/createLcdBackgroundImage.js\");\n/* harmony import */ var _drawRoseImage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./drawRoseImage */ \"./src/drawRoseImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst WindDirection = function (canvas, parameters) {\n  parameters = parameters || {}\n  let size = undefined === parameters.size ? 0 : parameters.size\n  let frameDesign =\n    undefined === parameters.frameDesign\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"FrameDesign\"].METAL\n      : parameters.frameDesign\n  const frameVisible =\n    undefined === parameters.frameVisible ? true : parameters.frameVisible\n  let backgroundColor =\n    undefined === parameters.backgroundColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"BackgroundColor\"].DARK_GRAY\n      : parameters.backgroundColor\n  const backgroundVisible =\n    undefined === parameters.backgroundVisible\n      ? true\n      : parameters.backgroundVisible\n  let pointerTypeLatest =\n    undefined === parameters.pointerTypeLatest\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"PointerType\"].TYPE1\n      : parameters.pointerTypeLatest\n  let pointerTypeAverage =\n    undefined === parameters.pointerTypeAverage\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"PointerType\"].TYPE8\n      : parameters.pointerTypeAverage\n  let pointerColor =\n    undefined === parameters.pointerColor\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].RED\n      : parameters.pointerColor\n  let pointerColorAverage =\n    undefined === parameters.pointerColorAverage\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ColorDef\"].BLUE\n      : parameters.pointerColorAverage\n  const knobType =\n    undefined === parameters.knobType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobType\"].STANDARD_KNOB\n      : parameters.knobType\n  const knobStyle =\n    undefined === parameters.knobStyle\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"KnobStyle\"].SILVER\n      : parameters.knobStyle\n  let foregroundType =\n    undefined === parameters.foregroundType\n      ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"ForegroundType\"].TYPE1\n      : parameters.foregroundType\n  const foregroundVisible =\n    undefined === parameters.foregroundVisible\n      ? true\n      : parameters.foregroundVisible\n  let pointSymbols =\n    undefined === parameters.pointSymbols\n      ? ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']\n      : parameters.pointSymbols\n  const pointSymbolsVisible =\n    undefined === parameters.pointSymbolsVisible\n      ? true\n      : parameters.pointSymbolsVisible\n  const customLayer =\n    undefined === parameters.customLayer ? null : parameters.customLayer\n  const degreeScale =\n    undefined === parameters.degreeScale ? true : parameters.degreeScale\n  const degreeScaleHalf =\n    undefined === parameters.degreeScaleHalf\n      ? false\n      : parameters.degreeScaleHalf\n  const roseVisible =\n    undefined === parameters.roseVisible ? false : parameters.roseVisible\n  let lcdColor =\n    undefined === parameters.lcdColor ? _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LcdColor\"].STANDARD : parameters.lcdColor\n  const lcdVisible =\n    undefined === parameters.lcdVisible ? true : parameters.lcdVisible\n  const digitalFont =\n    undefined === parameters.digitalFont ? false : parameters.digitalFont\n  let section = undefined === parameters.section ? null : parameters.section\n  let area = undefined === parameters.area ? null : parameters.area\n  let lcdTitleStrings =\n    undefined === parameters.lcdTitleStrings\n      ? ['Latest', 'Average']\n      : parameters.lcdTitleStrings\n  const titleString =\n    undefined === parameters.titleString ? '' : parameters.titleString\n  const useColorLabels =\n    undefined === parameters.useColorLabels ? false : parameters.useColorLabels\n  const fullScaleDeflectionTime =\n    undefined === parameters.fullScaleDeflectionTime\n      ? 2.5\n      : parameters.fullScaleDeflectionTime\n\n  let tweenLatest\n  let tweenAverage\n  let valueLatest = 0\n  let valueAverage = 0\n  const angleStep = _tools__WEBPACK_IMPORTED_MODULE_8__[\"RAD_FACTOR\"]\n  let angleLatest = this.valueLatest\n  let angleAverage = this.valueAverage\n  const rotationOffset = -_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"]\n  const angleRange = _tools__WEBPACK_IMPORTED_MODULE_8__[\"TWO_PI\"]\n  const range = 360\n  let repainting = false\n\n  // Get the canvas context and clear it\n  const mainCtx = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"getCanvasContext\"])(canvas)\n  // Has a size been specified?\n  if (size === 0) {\n    size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height)\n  }\n\n  // Set the size - also clears the canvas\n  mainCtx.canvas.width = size\n  mainCtx.canvas.height = size\n\n  const imageWidth = size\n  const imageHeight = size\n\n  const centerX = imageWidth / 2\n  const centerY = imageHeight / 2\n\n  const lcdFontHeight = Math.floor(imageWidth / 10)\n  const stdFont = lcdFontHeight + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n  const lcdFont = lcdFontHeight + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"lcdFontName\"]\n  const lcdWidth = imageWidth * 0.3\n  const lcdHeight = imageHeight * 0.12\n  const lcdPosX = (imageWidth - lcdWidth) / 2\n  const lcdPosY1 = imageHeight * 0.32\n  const lcdPosY2 = imageHeight * 0.565\n\n  let initialized = false\n\n  // **************   Buffer creation  ********************\n  // Buffer for all static background painting code\n  const backgroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size, size)\n  let backgroundContext = backgroundBuffer.getContext('2d')\n\n  // Buffer for LCD displays\n  let lcdBuffer\n\n  // Buffer for latest pointer images painting code\n  const pointerBufferLatest = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size, size)\n  let pointerContextLatest = pointerBufferLatest.getContext('2d')\n\n  // Buffer for average pointer image\n  const pointerBufferAverage = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size, size)\n  let pointerContextAverage = pointerBufferAverage.getContext('2d')\n\n  // Buffer for static foreground painting code\n  const foregroundBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"createBuffer\"])(size, size)\n  let foregroundContext = foregroundBuffer.getContext('2d')\n\n  // **************   Image creation  ********************\n  const drawLcdText = function (value, bLatest) {\n    mainCtx.save()\n    mainCtx.textAlign = 'center'\n    mainCtx.strokeStyle = lcdColor.textColor\n    mainCtx.fillStyle = lcdColor.textColor\n\n    // convert value from -180,180 range into 0-360 range\n    while (value < -180) {\n      value += 360\n    }\n    if (!degreeScaleHalf && value < 0) {\n      value += 360\n    }\n\n    if (degreeScaleHalf && value > 180) {\n      value = -(360 - value)\n    }\n\n    if (value >= 0) {\n      value = '00' + Math.round(value)\n      value = value.substring(value.length, value.length - 3)\n    } else {\n      value = '00' + Math.abs(Math.round(value))\n      value = '-' + value.substring(value.length, value.length - 3)\n    }\n\n    if (\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LcdColor\"].STANDARD ||\n      lcdColor === _definitions__WEBPACK_IMPORTED_MODULE_9__[\"LcdColor\"].STANDARD_GREEN\n    ) {\n      mainCtx.shadowColor = 'gray'\n      mainCtx.shadowOffsetX = imageWidth * 0.007\n      mainCtx.shadowOffsetY = imageWidth * 0.007\n      mainCtx.shadowBlur = imageWidth * 0.007\n    }\n    mainCtx.font = digitalFont ? lcdFont : stdFont\n    mainCtx.fillText(\n      value + '\\u00B0',\n      imageWidth / 2 + lcdWidth * 0.05,\n      (bLatest ? lcdPosY1 : lcdPosY2) + lcdHeight * 0.5 + lcdFontHeight * 0.38,\n      lcdWidth * 0.9\n    )\n\n    mainCtx.restore()\n  }\n\n  const drawAreaSectionImage = function (ctx, start, stop, color, filled) {\n    ctx.save()\n    ctx.strokeStyle = color\n    ctx.fillStyle = color\n    ctx.lineWidth = imageWidth * 0.035\n    const startAngle = (angleRange / range) * start\n    const stopAngle = startAngle + (stop - start) / (range / angleRange)\n    ctx.translate(centerX, centerY)\n    ctx.rotate(rotationOffset)\n    ctx.beginPath()\n    if (filled) {\n      ctx.moveTo(0, 0)\n      ctx.arc(\n        0,\n        0,\n        imageWidth * 0.365 - ctx.lineWidth / 2,\n        startAngle,\n        stopAngle,\n        false\n      )\n    } else {\n      ctx.arc(0, 0, imageWidth * 0.365, startAngle, stopAngle, false)\n    }\n    if (filled) {\n      ctx.moveTo(0, 0)\n      ctx.fill()\n    } else {\n      ctx.stroke()\n    }\n\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  const drawTickmarksImage = function (ctx) {\n    const OUTER_POINT = imageWidth * 0.38\n    const MAJOR_INNER_POINT = imageWidth * 0.35\n    // MED_INNER_POINT = imageWidth * 0.355,\n    const MINOR_INNER_POINT = imageWidth * 0.36\n    const TEXT_WIDTH = imageWidth * 0.1\n    const TEXT_TRANSLATE_X = imageWidth * 0.31\n    const CARDINAL_TRANSLATE_X = imageWidth * 0.36\n    let stdFont\n    let smlFont\n    let i\n    let val\n    let to\n\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n\n    ctx.save()\n    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n    ctx.translate(centerX, centerY)\n\n    if (!degreeScale) {\n      stdFont = 0.12 * imageWidth + 'px serif'\n      smlFont = 0.06 * imageWidth + 'px serif'\n\n      // let angleStep = RAD_FACTOR;\n      ctx.lineWidth = 1\n      ctx.strokeStyle = backgroundColor.symbolColor.getRgbaColor()\n\n      for (i = 0; i < 360; i += 2.5) {\n        if (i % 5 === 0) {\n          ctx.beginPath()\n          ctx.moveTo(imageWidth * 0.38, 0)\n          ctx.lineTo(imageWidth * 0.36, 0)\n          ctx.closePath()\n          ctx.stroke()\n        }\n\n        // Draw the labels\n        ctx.save()\n        switch (i) {\n          case 0: // E\n            ctx.translate(imageWidth * 0.35, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n            ctx.font = stdFont\n            ctx.fillText(pointSymbols[2], 0, 0)\n            ctx.translate(-imageWidth * 0.35, 0)\n            break\n          case 45: // SE\n            ctx.translate(imageWidth * 0.29, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n            ctx.font = smlFont\n            ctx.fillText(pointSymbols[3], 0, 0)\n            ctx.translate(-imageWidth * 0.29, 0)\n            break\n          case 90: // S\n            ctx.translate(imageWidth * 0.35, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n            ctx.font = stdFont\n            ctx.fillText(pointSymbols[4], 0, 0)\n            ctx.translate(-imageWidth * 0.35, 0)\n            break\n          case 135: // SW\n            ctx.translate(imageWidth * 0.29, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n            ctx.font = smlFont\n            ctx.fillText(pointSymbols[5], 0, 0)\n            ctx.translate(-imageWidth * 0.29, 0)\n            break\n          case 180: // W\n            ctx.translate(imageWidth * 0.35, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n            ctx.font = stdFont\n            ctx.fillText(pointSymbols[6], 0, 0)\n            ctx.translate(-imageWidth * 0.35, 0)\n            break\n          case 225: // NW\n            ctx.translate(imageWidth * 0.29, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n            ctx.font = smlFont\n            ctx.fillText(pointSymbols[7], 0, 0)\n            ctx.translate(-imageWidth * 0.29, 0)\n            break\n          case 270: // N\n            ctx.translate(imageWidth * 0.35, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n            ctx.font = stdFont\n            ctx.fillText(pointSymbols[0], 0, 0)\n            ctx.translate(-imageWidth * 0.35, 0)\n            break\n          case 315: // NE\n            ctx.translate(imageWidth * 0.29, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n            ctx.font = smlFont\n            ctx.fillText(pointSymbols[1], 0, 0)\n            ctx.translate(-imageWidth * 0.29, 0)\n            break\n        }\n        ctx.restore()\n\n        if (\n          roseVisible &&\n          (i === 0 ||\n            i === 22.5 ||\n            i === 45 ||\n            i === 67.5 ||\n            i === 90 ||\n            i === 112.5 ||\n            i === 135 ||\n            i === 157.5 ||\n            i === 180 ||\n            i === 202.5 ||\n            i === 225 ||\n            i === 247.5 ||\n            i === 270 ||\n            i === 292.5 ||\n            i === 315 ||\n            i === 337.5 ||\n            i === 360)\n        ) {\n          // ROSE_LINE\n          ctx.save()\n          ctx.beginPath()\n          // indent the 16 half quadrant lines a bit for visual effect\n          if (i % 45) {\n            ctx.moveTo(imageWidth * 0.29, 0)\n          } else {\n            ctx.moveTo(imageWidth * 0.38, 0)\n          }\n          ctx.lineTo(imageWidth * 0.1, 0)\n          ctx.closePath()\n          ctx.restore()\n          ctx.stroke()\n        }\n        ctx.rotate(angleStep * 2.5)\n      }\n    } else {\n      stdFont = Math.floor(0.1 * imageWidth) + 'px serif bold'\n      smlFont = Math.floor(imageWidth * 0.04) + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n\n      ctx.rotate(angleStep * 5)\n      for (i = 5; i <= 360; i += 5) {\n        // Draw the labels\n        ctx.save()\n        if (pointSymbolsVisible) {\n          switch (i) {\n            case 360:\n              ctx.translate(CARDINAL_TRANSLATE_X, 0)\n              ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n              ctx.font = stdFont\n              ctx.fillText(pointSymbols[2], 0, 0, TEXT_WIDTH)\n              ctx.translate(-CARDINAL_TRANSLATE_X, 0)\n              break\n            case 90:\n              ctx.translate(CARDINAL_TRANSLATE_X, 0)\n              ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n              ctx.font = stdFont\n              ctx.fillText(pointSymbols[4], 0, 0, TEXT_WIDTH)\n              ctx.translate(-CARDINAL_TRANSLATE_X, 0)\n              break\n            case 180:\n              ctx.translate(CARDINAL_TRANSLATE_X, 0)\n              ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n              ctx.font = stdFont\n              ctx.fillText(pointSymbols[6], 0, 0, TEXT_WIDTH)\n              ctx.translate(-CARDINAL_TRANSLATE_X, 0)\n              break\n            case 270:\n              ctx.translate(CARDINAL_TRANSLATE_X, 0)\n              ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n              ctx.font = stdFont\n              ctx.fillText(pointSymbols[0], 0, 0, TEXT_WIDTH)\n              ctx.translate(-CARDINAL_TRANSLATE_X, 0)\n              break\n\n            case 5:\n            case 85:\n            case 95:\n            case 175:\n            case 185:\n            case 265:\n            case 275:\n            case 355:\n              // leave room for ordinal labels\n              break\n\n            default:\n              if ((i + 90) % 20) {\n                ctx.lineWidth = (i + 90) % 5 ? 1.5 : 1\n                ctx.beginPath()\n                ctx.moveTo(OUTER_POINT, 0)\n                to = (i + 90) % 10 ? MINOR_INNER_POINT : MAJOR_INNER_POINT\n                ctx.lineTo(to, 0)\n                ctx.closePath()\n                ctx.stroke()\n              } else {\n                ctx.lineWidth = 1.5\n                ctx.beginPath()\n                ctx.moveTo(OUTER_POINT, 0)\n                ctx.lineTo(MAJOR_INNER_POINT, 0)\n                ctx.closePath()\n                ctx.stroke()\n                val = (i + 90) % 360\n                ctx.translate(TEXT_TRANSLATE_X, 0)\n                ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n                ctx.font = smlFont\n                ctx.fillText('0'.substring(val >= 100) + val, 0, 0, TEXT_WIDTH)\n                ctx.translate(-TEXT_TRANSLATE_X, 0)\n              }\n          }\n        } else {\n          if ((i + 90) % 20) {\n            ctx.lineWidth = (i + 90) % 5 ? 1.5 : 1\n            ctx.beginPath()\n            ctx.moveTo(OUTER_POINT, 0)\n            to = (i + 90) % 10 ? MINOR_INNER_POINT : MAJOR_INNER_POINT\n            ctx.lineTo(to, 0)\n            ctx.closePath()\n            ctx.stroke()\n          } else {\n            ctx.lineWidth = 1.5\n            ctx.beginPath()\n            ctx.moveTo(OUTER_POINT, 0)\n            ctx.lineTo(MAJOR_INNER_POINT, 0)\n            ctx.closePath()\n            ctx.stroke()\n            val = (i + 90) % 360\n            if (degreeScaleHalf) {\n              // invert 180-360\n              if (val > 180) {\n                val = -(360 - val)\n              }\n            }\n            ctx.translate(TEXT_TRANSLATE_X, 0)\n            ctx.rotate(_tools__WEBPACK_IMPORTED_MODULE_8__[\"HALF_PI\"])\n            ctx.font = smlFont\n            ctx.fillText(val, 0, 0, TEXT_WIDTH)\n            ctx.translate(-TEXT_TRANSLATE_X, 0)\n          }\n        }\n        ctx.restore()\n        ctx.rotate(angleStep * 5)\n      }\n    }\n    ctx.translate(-centerX, -centerY)\n    ctx.restore()\n  }\n\n  const drawLcdTitles = function (ctx) {\n    if (lcdTitleStrings.length > 0) {\n      ctx.save()\n      ctx.textAlign = 'center'\n      ctx.textBaseline = 'middle'\n      ctx.fillStyle = useColorLabels\n        ? pointerColor.medium.getRgbaColor()\n        : backgroundColor.labelColor.getRgbaColor()\n      ctx.font = 0.04 * imageWidth + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n      ctx.fillText(\n        lcdTitleStrings[0],\n        imageWidth / 2,\n        imageHeight * 0.29,\n        imageWidth * 0.3\n      )\n      ctx.fillStyle = useColorLabels\n        ? pointerColorAverage.medium.getRgbaColor()\n        : backgroundColor.labelColor.getRgbaColor()\n      ctx.fillText(\n        lcdTitleStrings[1],\n        imageWidth / 2,\n        imageHeight * 0.71,\n        imageWidth * 0.3\n      )\n      if (titleString.length > 0) {\n        ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n        ctx.font = 0.0467 * imageWidth + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_8__[\"stdFontName\"]\n        ctx.fillText(\n          titleString,\n          imageWidth / 2,\n          imageHeight * 0.5,\n          imageWidth * 0.3\n        )\n      }\n    }\n  }\n\n  // **************   Initialization  ********************\n  // Draw all static painting code to background\n\n  const init = function (parameters) {\n    parameters = parameters || {}\n    const drawBackground2 =\n      undefined === parameters.background ? false : parameters.background\n    const drawPointer =\n      undefined === parameters.pointer ? false : parameters.pointer\n    const drawForeground2 =\n      undefined === parameters.foreground ? false : parameters.foreground\n\n    initialized = true\n\n    if (drawBackground2 && frameVisible) {\n      Object(_drawFrame__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n        backgroundContext,\n        frameDesign,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n    }\n\n    if (drawBackground2 && backgroundVisible) {\n      // Create background in background buffer (backgroundBuffer)\n      Object(_drawBackground__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n        backgroundContext,\n        backgroundColor,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      // Create custom layer in background buffer (backgroundBuffer)\n      Object(_drawRadialCustomImage__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(\n        backgroundContext,\n        customLayer,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight\n      )\n\n      // Create section in background buffer (backgroundBuffer)\n      if (section !== null && section.length > 0) {\n        let sectionIndex = section.length\n        do {\n          sectionIndex--\n          drawAreaSectionImage(\n            backgroundContext,\n            section[sectionIndex].start,\n            section[sectionIndex].stop,\n            section[sectionIndex].color,\n            false\n          )\n        } while (sectionIndex > 0)\n      }\n\n      // Create area in background buffer (backgroundBuffer)\n      if (area !== null && area.length > 0) {\n        let areaIndex = area.length\n        do {\n          areaIndex--\n          drawAreaSectionImage(\n            backgroundContext,\n            area[areaIndex].start,\n            area[areaIndex].stop,\n            area[areaIndex].color,\n            true\n          )\n        } while (areaIndex > 0)\n      }\n\n      drawTickmarksImage(backgroundContext)\n    }\n\n    if (drawBackground2 && roseVisible) {\n      Object(_drawRoseImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(\n        backgroundContext,\n        centerX,\n        centerY,\n        imageWidth,\n        imageHeight,\n        backgroundColor\n      )\n    }\n\n    // Create lcd background if selected in background buffer (backgroundBuffer)\n    if (drawBackground2 && lcdVisible) {\n      lcdBuffer = Object(_createLcdBackgroundImage__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(lcdWidth, lcdHeight, lcdColor)\n      backgroundContext.drawImage(lcdBuffer, lcdPosX, lcdPosY1)\n      backgroundContext.drawImage(lcdBuffer, lcdPosX, lcdPosY2)\n      // Create title in background buffer (backgroundBuffer)\n      drawLcdTitles(backgroundContext)\n    }\n\n    if (drawPointer) {\n      Object(_drawPointerImage__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        pointerContextAverage,\n        imageWidth,\n        pointerTypeAverage,\n        pointerColorAverage,\n        backgroundColor.labelColor\n      )\n      Object(_drawPointerImage__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n        pointerContextLatest,\n        imageWidth,\n        pointerTypeLatest,\n        pointerColor,\n        backgroundColor.labelColor\n      )\n    }\n\n    if (drawForeground2 && foregroundVisible) {\n      const knobVisible =\n        !(pointerTypeLatest.type === 'type15' ||\n        pointerTypeLatest.type === 'type16')\n      Object(_drawForeground__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n        foregroundContext,\n        foregroundType,\n        imageWidth,\n        imageHeight,\n        knobVisible,\n        knobType,\n        knobStyle\n      )\n    }\n  }\n\n  const resetBuffers = function (buffers) {\n    buffers = buffers || {}\n    const resetBackground =\n      undefined === buffers.background ? false : buffers.background\n    const resetPointer =\n      undefined === buffers.pointer ? false : buffers.pointer\n    const resetForeground =\n      undefined === buffers.foreground ? false : buffers.foreground\n\n    // Buffer for all static background painting code\n    if (resetBackground) {\n      backgroundBuffer.width = size\n      backgroundBuffer.height = size\n      backgroundContext = backgroundBuffer.getContext('2d')\n    }\n    // Buffers for pointer image painting code\n    if (resetPointer) {\n      pointerBufferLatest.width = size\n      pointerBufferLatest.height = size\n      pointerContextLatest = pointerBufferLatest.getContext('2d')\n\n      pointerBufferAverage.width = size\n      pointerBufferAverage.height = size\n      pointerContextAverage = pointerBufferAverage.getContext('2d')\n    }\n    // Buffer for static foreground painting code\n    if (resetForeground) {\n      foregroundBuffer.width = size\n      foregroundBuffer.height = size\n      foregroundContext = foregroundBuffer.getContext('2d')\n    }\n  }\n\n  //* *********************************** Public methods **************************************\n  this.setValueLatest = function (newValue) {\n    // Actually need to handle 0-360 rather than 0-359\n    // 1-360 are used for directions\n    // 0 is used as a special case to indicate 'calm'\n    newValue = parseFloat(newValue)\n    newValue = newValue === 360 ? 360 : newValue % 360\n    if (valueLatest !== newValue) {\n      valueLatest = newValue\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValueLatest = function () {\n    return valueLatest\n  }\n\n  this.setValueAverage = function (newValue) {\n    // Actually need to handle 0-360 rather than 0-359\n    // 1-360 are used for directions\n    // 0 is used as a special case to indicate 'calm'\n    newValue = parseFloat(newValue)\n    newValue = newValue === 360 ? 360 : newValue % 360\n    if (valueAverage !== newValue) {\n      valueAverage = newValue\n      this.repaint()\n    }\n    return this\n  }\n\n  this.getValueAverage = function () {\n    return valueAverage\n  }\n\n  this.setValueAnimatedLatest = function (newValue, callback) {\n    const gauge = this\n    let diff\n    let time\n    // Actually need to handle 0-360 rather than 0-359\n    // 1-360 are used for directions\n    // 0 is used as a special case to indicate 'calm'\n    newValue = parseFloat(newValue)\n    const targetValue = newValue === 360 ? 360 : newValue % 360\n\n    if (valueLatest !== targetValue) {\n      if (undefined !== tweenLatest && tweenLatest.isPlaying) {\n        tweenLatest.stop()\n      }\n\n      diff = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"getShortestAngle\"])(valueLatest, targetValue)\n\n      if (diff !== 0) {\n        // 360 - 0 is a diff of zero\n        time = (fullScaleDeflectionTime * Math.abs(diff)) / 180\n        time = Math.max(time, fullScaleDeflectionTime / 5)\n        tweenLatest = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n          {},\n          '',\n          _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n          valueLatest,\n          valueLatest + diff,\n          time\n        )\n        tweenLatest.onMotionChanged = function (event) {\n          valueLatest =\n            event.target._pos === 360 ? 360 : event.target._pos % 360\n          if (!repainting) {\n            repainting = true\n            Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(gauge.repaint)\n          }\n        }\n\n        tweenLatest.onMotionFinished = function () {\n          valueLatest = targetValue\n          if (!repainting) {\n            repainting = true\n            Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(gauge.repaint)\n          }\n          // do we have a callback function to process?\n          if (callback && typeof callback === 'function') {\n            callback()\n          }\n        }\n\n        tweenLatest.start()\n      } else {\n        // target different from current, but diff is zero (0 -> 360 for instance), so just repaint\n        valueLatest = targetValue\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n    }\n    return this\n  }\n\n  this.setValueAnimatedAverage = function (newValue, callback) {\n    const gauge = this\n    let diff\n    let time\n    // Actually need to handle 0-360 rather than 0-359\n    // 1-360 are used for directions\n    // 0 is used as a special case to indicate 'calm'\n    newValue = parseFloat(newValue)\n    const targetValue = newValue === 360 ? 360 : newValue % 360\n    if (valueAverage !== newValue) {\n      if (undefined !== tweenAverage && tweenAverage.isPlaying) {\n        tweenAverage.stop()\n      }\n\n      diff = Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"getShortestAngle\"])(valueAverage, targetValue)\n      if (diff !== 0) {\n        // 360 - 0 is a diff of zero\n        time = (fullScaleDeflectionTime * Math.abs(diff)) / 180\n        time = Math.max(time, fullScaleDeflectionTime / 5)\n        tweenAverage = new _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n          {},\n          '',\n          _tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regularEaseInOut,\n          valueAverage,\n          valueAverage + diff,\n          time\n        )\n        tweenAverage.onMotionChanged = function (event) {\n          valueAverage =\n            event.target._pos === 360 ? 360 : event.target._pos % 360\n          if (!repainting) {\n            repainting = true\n            Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(gauge.repaint)\n          }\n        }\n\n        tweenAverage.onMotionFinished = function () {\n          valueAverage = targetValue\n          if (!repainting) {\n            repainting = true\n            Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(gauge.repaint)\n          }\n          // do we have a callback function to process?\n          if (callback && typeof callback === 'function') {\n            callback()\n          }\n        }\n\n        tweenAverage.start()\n      } else {\n        // target different from current, but diff is zero (0 -> 360 for instance), so just repaint\n        valueAverage = targetValue\n        if (!repainting) {\n          repainting = true\n          Object(_tools__WEBPACK_IMPORTED_MODULE_8__[\"requestAnimFrame\"])(gauge.repaint)\n        }\n      }\n    }\n    return this\n  }\n\n  this.setArea = function (areaVal) {\n    area = areaVal\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setSection = function (areaSec) {\n    section = areaSec\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setFrameDesign = function (newFrameDesign) {\n    frameDesign = newFrameDesign\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setBackgroundColor = function (newBackgroundColor) {\n    backgroundColor = newBackgroundColor\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setForegroundType = function (newForegroundType) {\n    resetBuffers({\n      foreground: true\n    })\n    foregroundType = newForegroundType\n    init({\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerColor = function (newPointerColor) {\n    resetBuffers({\n      pointer: true\n    })\n    pointerColor = newPointerColor\n    init({\n      pointer: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerColorAverage = function (newPointerColor) {\n    resetBuffers({\n      pointer: true\n    })\n    pointerColorAverage = newPointerColor\n    init({\n      pointer: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerType = function (newPointerType) {\n    pointerTypeLatest = newPointerType\n    resetBuffers({\n      pointer: true,\n      foreground: true\n    })\n    init({\n      pointer: true,\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointerTypeAverage = function (newPointerType) {\n    pointerTypeAverage = newPointerType\n    resetBuffers({\n      pointer: true,\n      foreground: true\n    })\n    init({\n      pointer: true,\n      foreground: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setPointSymbols = function (newPointSymbols) {\n    pointSymbols = newPointSymbols\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLcdColor = function (newLcdColor) {\n    lcdColor = newLcdColor\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.setLcdTitleStrings = function (titles) {\n    lcdTitleStrings = titles\n    resetBuffers({\n      background: true\n    })\n    init({\n      background: true\n    })\n    this.repaint()\n    return this\n  }\n\n  this.repaint = function () {\n    if (!initialized) {\n      init({\n        frame: true,\n        background: true,\n        led: true,\n        pointer: true,\n        foreground: true\n      })\n    }\n\n    mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height)\n\n    if (frameVisible || backgroundVisible) {\n      mainCtx.drawImage(backgroundBuffer, 0, 0)\n    }\n\n    // Draw lcd display\n    if (lcdVisible) {\n      drawLcdText(valueLatest, true)\n      drawLcdText(valueAverage, false)\n    }\n\n    // Define rotation angle\n    angleAverage = valueAverage * angleStep\n\n    // we have to draw to a rotated temporary image area so we can translate in\n    // absolute x, y values when drawing to main context\n    const shadowOffset = imageWidth * 0.006\n\n    // Define rotation center\n    mainCtx.save()\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(angleAverage)\n    mainCtx.translate(-centerX, -centerY)\n    // Set the pointer shadow params\n    mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n    mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset\n    mainCtx.shadowBlur = shadowOffset * 2\n    // Draw the pointer\n    mainCtx.drawImage(pointerBufferAverage, 0, 0)\n    // Define rotation angle difference for average pointer\n    angleLatest = valueLatest * angleStep - angleAverage\n    mainCtx.translate(centerX, centerY)\n    mainCtx.rotate(angleLatest)\n    mainCtx.translate(-centerX, -centerY)\n    mainCtx.drawImage(pointerBufferLatest, 0, 0)\n    mainCtx.restore()\n\n    if (foregroundVisible) {\n      mainCtx.drawImage(foregroundBuffer, 0, 0)\n    }\n\n    repainting = false\n  }\n\n  // Visualize the component\n  this.repaint()\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (WindDirection);\n\n\n//# sourceURL=webpack://steelseries/./src/WindDirection.js?");

/***/ }),

/***/ "./src/brushedMetalTexture.js":
/*!************************************!*\
  !*** ./src/brushedMetalTexture.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst brushedMetalTexture = function (color, radius, amount, monochrome, shine) {\n  this.fill = function (startX, startY, endX, endY) {\n    let i\n    let x\n    let y // loop counters\n    let sinArr\n    // alpha = color & 0xff000000;\n    const alpha = 255\n    const red = (color >> 16) & 0xff\n    const green = (color >> 8) & 0xff\n    const blue = color & 0xff\n    let n = 0\n    const variation = 255 * amount\n    let indx\n    let tr\n    let tg\n    let tb\n    let f\n\n    startX = Math.floor(startX)\n    startY = Math.floor(startY)\n    endX = Math.ceil(endX)\n    endY = Math.ceil(endY)\n\n    const width = endX - startX\n    const height = endY - startY\n\n    // Create output canvas\n    const outCanvas = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"createBuffer\"])(width, height)\n    const outCanvasContext = outCanvas.getContext('2d')\n\n    // Create pixel arrays\n    const inPixels = outCanvasContext.createImageData(width, height)\n    const outPixels = outCanvasContext.createImageData(width, height)\n\n    // Precreate sin() values\n    if (shine !== 0) {\n      sinArr = []\n      for (i = 0; i < width; i++) {\n        sinArr[i] = (255 * shine * Math.sin((i / width) * _tools__WEBPACK_IMPORTED_MODULE_0__[\"PI\"])) | 0\n      }\n    }\n\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width; x++) {\n        indx = y * width * 4 + x * 4\n        tr = red\n        tg = green\n        tb = blue\n        if (shine !== 0) {\n          f = sinArr[x]\n          tr += f\n          tg += f\n          tb += f\n        }\n\n        if (monochrome) {\n          n = ((2 * Math.random() - 1) * variation) | 0\n          inPixels.data[indx] = clamp(tr + n)\n          inPixels.data[indx + 1] = clamp(tg + n)\n          inPixels.data[indx + 2] = clamp(tb + n)\n          inPixels.data[indx + 3] = alpha\n        } else {\n          inPixels.data[indx] = random(tr, variation)\n          inPixels.data[indx + 1] = random(tg, variation)\n          inPixels.data[indx + 2] = random(tb, variation)\n          inPixels.data[indx + 3] = alpha\n        }\n      }\n    }\n\n    if (radius > 0) {\n      horizontalBlur(inPixels, outPixels, width, height, radius, alpha)\n      outCanvasContext.putImageData(outPixels, startX, startY)\n    } else {\n      outCanvasContext.putImageData(inPixels, startX, startY)\n    }\n    return outCanvas\n  }\n\n  function random (x, vari) {\n    x += ((2 * Math.random() - 1) * vari) | 0\n    return x < 0 ? 0 : x > 255 ? 255 : x\n  }\n\n  function clamp (C) {\n    return C < 0 ? 0 : C > 255 ? 255 : C\n  }\n\n  function horizontalBlur (inPix, outPix, width, height, radius, alpha) {\n    let x\n    let y // loop counters\n    let i\n    let indx\n    let totR\n    let totG\n    let totB\n\n    if (radius >= width) {\n      radius = width - 1\n    }\n    const mul = 1 / (radius * 2 + 1)\n    indx = 0\n    for (y = 0; y < height; y++) {\n      totR = totG = totB = 0\n      for (x = 0; x < radius; x++) {\n        i = (indx + x) * 4\n        totR += inPix.data[i]\n        totG += inPix.data[i + 1]\n        totB += inPix.data[i + 2]\n      }\n      for (x = 0; x < width; x++) {\n        if (x > radius) {\n          i = (indx - radius - 1) * 4\n          totR -= inPix.data[i]\n          totG -= inPix.data[i + 1]\n          totB -= inPix.data[i + 2]\n        }\n        if (x + radius < width) {\n          i = (indx + radius) * 4\n          totR += inPix.data[i]\n          totG += inPix.data[i + 1]\n          totB += inPix.data[i + 2]\n        }\n        i = indx * 4\n        outPix.data[i] = (totR * mul) | 0\n        outPix.data[i + 1] = (totG * mul) | 0\n        outPix.data[i + 2] = (totB * mul) | 0\n        outPix.data[i + 3] = alpha\n        indx++\n      }\n    }\n  }\n\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (brushedMetalTexture);\n\n\n//# sourceURL=webpack://steelseries/./src/brushedMetalTexture.js?");

/***/ }),

/***/ "./src/carbonBuffer.js":
/*!*****************************!*\
  !*** ./src/carbonBuffer.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst carbonBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"drawToBuffer\"])(12, 12, function (ctx) {\n  const imageWidth = ctx.canvas.width\n  const imageHeight = ctx.canvas.height\n  let offsetY = 0\n  let grad\n\n  ctx.save()\n\n  // RULB\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(0, 0, imageWidth * 0.5, imageHeight * 0.5)\n  ctx.closePath()\n  ctx.restore()\n\n  grad = ctx.createLinearGradient(\n    0,\n    offsetY * imageHeight,\n    0,\n    0.5 * imageHeight + offsetY * imageHeight\n  )\n  grad.addColorStop(0, 'rgb(35, 35, 35)')\n  grad.addColorStop(1, 'rgb(23, 23, 23)')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  // RULF\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(\n    imageWidth * 0.083333,\n    0,\n    imageWidth * 0.333333,\n    imageHeight * 0.416666\n  )\n  ctx.closePath()\n  ctx.restore()\n  offsetY = 0\n  grad = ctx.createLinearGradient(\n    0,\n    offsetY * imageHeight,\n    0,\n    0.416666 * imageHeight + offsetY * imageHeight\n  )\n  grad.addColorStop(0, 'rgb(38, 38, 38)')\n  grad.addColorStop(1, 'rgb(30, 30, 30)')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  // RLRB\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(\n    imageWidth * 0.5,\n    imageHeight * 0.5,\n    imageWidth * 0.5,\n    imageHeight * 0.5\n  )\n  ctx.closePath()\n  ctx.restore()\n  offsetY = 0.5\n  grad = ctx.createLinearGradient(\n    0,\n    offsetY * imageHeight,\n    0,\n    0.5 * imageHeight + offsetY * imageHeight\n  )\n  grad.addColorStop(0, 'rgb(35, 35, 35)')\n  grad.addColorStop(1, 'rgb(23, 23, 23)')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  // RLRF\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(\n    imageWidth * 0.583333,\n    imageHeight * 0.5,\n    imageWidth * 0.333333,\n    imageHeight * 0.416666\n  )\n  ctx.closePath()\n  ctx.restore()\n  offsetY = 0.5\n  grad = ctx.createLinearGradient(\n    0,\n    offsetY * imageHeight,\n    0,\n    0.416666 * imageHeight + offsetY * imageHeight\n  )\n  grad.addColorStop(0, 'rgb(38, 38, 38)')\n  grad.addColorStop(1, 'rgb(30, 30, 30)')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  // RURB\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(imageWidth * 0.5, 0, imageWidth * 0.5, imageHeight * 0.5)\n  ctx.closePath()\n  ctx.restore()\n  offsetY = 0\n  grad = ctx.createLinearGradient(\n    0,\n    offsetY * imageHeight,\n    0,\n    0.5 * imageHeight + offsetY * imageHeight\n  )\n  grad.addColorStop(0, '#303030')\n  grad.addColorStop(1, 'rgb(40, 40, 40)')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  // RURF\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(\n    imageWidth * 0.583333,\n    imageHeight * 0.083333,\n    imageWidth * 0.333333,\n    imageHeight * 0.416666\n  )\n  ctx.closePath()\n  ctx.restore()\n  offsetY = 0.083333\n  grad = ctx.createLinearGradient(\n    0,\n    offsetY * imageHeight,\n    0,\n    0.416666 * imageHeight + offsetY * imageHeight\n  )\n  grad.addColorStop(0, 'rgb(53, 53, 53)')\n  grad.addColorStop(1, 'rgb(45, 45, 45)')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  // RLLB\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(0, imageHeight * 0.5, imageWidth * 0.5, imageHeight * 0.5)\n  ctx.closePath()\n  ctx.restore()\n  offsetY = 0.5\n  grad = ctx.createLinearGradient(\n    0,\n    offsetY * imageHeight,\n    0,\n    0.5 * imageHeight + offsetY * imageHeight\n  )\n  grad.addColorStop(0, '#303030')\n  grad.addColorStop(1, '#282828')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  // RLLF\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(\n    imageWidth * 0.083333,\n    imageHeight * 0.583333,\n    imageWidth * 0.333333,\n    imageHeight * 0.416666\n  )\n  ctx.closePath()\n  ctx.restore()\n  offsetY = 0.583333\n  grad = ctx.createLinearGradient(\n    0,\n    offsetY * imageHeight,\n    0,\n    0.416666 * imageHeight + offsetY * imageHeight\n  )\n  grad.addColorStop(0, '#353535')\n  grad.addColorStop(1, '#2d2d2d')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  ctx.restore()\n})\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (carbonBuffer);\n\n\n//# sourceURL=webpack://steelseries/./src/carbonBuffer.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! exports provided: BackgroundColorDef, LcdColorDef, ColorDef, LedColorDef, GaugeTypeDef, OrientationDef, KnobTypeDef, KnobStyleDef, FrameDesignDef, PointerTypeDef, ForegroundTypeDef, LabelNumberFormatDef, TickLabelOrientationDef, TrendStateDef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BackgroundColorDef\", function() { return BackgroundColorDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LcdColorDef\", function() { return LcdColorDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorDef\", function() { return ColorDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LedColorDef\", function() { return LedColorDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GaugeTypeDef\", function() { return GaugeTypeDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OrientationDef\", function() { return OrientationDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KnobTypeDef\", function() { return KnobTypeDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KnobStyleDef\", function() { return KnobStyleDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FrameDesignDef\", function() { return FrameDesignDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointerTypeDef\", function() { return PointerTypeDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ForegroundTypeDef\", function() { return ForegroundTypeDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LabelNumberFormatDef\", function() { return LabelNumberFormatDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TickLabelOrientationDef\", function() { return TickLabelOrientationDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TrendStateDef\", function() { return TrendStateDef; });\nlet BackgroundColorDef;\n(function () {\n  BackgroundColorDef = function (\n    gradientStart,\n    gradientFraction,\n    gradientStop,\n    labelColor,\n    symbolColor,\n    name\n  ) {\n    this.gradientStart = gradientStart\n    this.gradientFraction = gradientFraction\n    this.gradientStop = gradientStop\n    this.labelColor = labelColor\n    this.symbolColor = symbolColor\n    this.name = name\n  }\n})()\n\n\nlet LcdColorDef;\n(function () {\n  LcdColorDef = function (\n    gradientStartColor,\n    gradientFraction1Color,\n    gradientFraction2Color,\n    gradientFraction3Color,\n    gradientStopColor,\n    textColor\n  ) {\n    this.gradientStartColor = gradientStartColor\n    this.gradientFraction1Color = gradientFraction1Color\n    this.gradientFraction2Color = gradientFraction2Color\n    this.gradientFraction3Color = gradientFraction3Color\n    this.gradientStopColor = gradientStopColor\n    this.textColor = textColor\n  }\n})()\n\n\nlet ColorDef;\n(function () {\n  ColorDef = function (veryDark, dark, medium, light, lighter, veryLight) {\n    this.veryDark = veryDark\n    this.dark = dark\n    this.medium = medium\n    this.light = light\n    this.lighter = lighter\n    this.veryLight = veryLight\n  }\n})()\n\n\nlet LedColorDef;\n(function () {\n  LedColorDef = function (\n    innerColor1_ON,\n    innerColor2_ON,\n    outerColor_ON,\n    coronaColor,\n    innerColor1_OFF,\n    innerColor2_OFF,\n    outerColor_OFF\n  ) {\n    this.innerColor1_ON = innerColor1_ON\n    this.innerColor2_ON = innerColor2_ON\n    this.outerColor_ON = outerColor_ON\n    this.coronaColor = coronaColor\n    this.innerColor1_OFF = innerColor1_OFF\n    this.innerColor2_OFF = innerColor2_OFF\n    this.outerColor_OFF = outerColor_OFF\n  }\n})()\n\n\nlet GaugeTypeDef;\n(function () {\n  GaugeTypeDef = function (type) {\n    this.type = type\n  }\n})()\n\n\nlet OrientationDef;\n(function () {\n  OrientationDef = function (type) {\n    this.type = type\n  }\n})()\n\n\nlet KnobTypeDef;\n(function () {\n  KnobTypeDef = function (type) {\n    this.type = type\n  }\n})()\n\n\nlet KnobStyleDef;\n(function () {\n  KnobStyleDef = function (style) {\n    this.style = style\n  }\n})()\n\n\nlet FrameDesignDef;\n(function () {\n  FrameDesignDef = function (design) {\n    this.design = design\n  }\n})()\n\n\nlet PointerTypeDef;\n(function () {\n  PointerTypeDef = function (type) {\n    this.type = type\n  }\n})()\n\n\nlet ForegroundTypeDef;\n(function () {\n  ForegroundTypeDef = function (type) {\n    this.type = type\n  }\n})()\n\n\nlet LabelNumberFormatDef;\n(function () {\n  LabelNumberFormatDef = function (format) {\n    this.format = format\n  }\n})()\n\n\nlet TickLabelOrientationDef;\n(function () {\n  TickLabelOrientationDef = function (type) {\n    this.type = type\n  }\n})()\n\n\nlet TrendStateDef;\n(function () {\n  TrendStateDef = function (state) {\n    this.state = state\n  }\n})()\n\n\n\n//# sourceURL=webpack://steelseries/./src/constants.js?");

/***/ }),

/***/ "./src/createKnobImage.js":
/*!********************************!*\
  !*** ./src/createKnobImage.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst createKnobImage = function (size, knob, style) {\n  let knobBuffer\n  let knobCtx\n  const maxPostCenterX = size / 2\n  const maxPostCenterY = size / 2\n  let grad\n  const cacheKey = size.toString() + knob.type + style.style\n\n  // check if we have already created and cached this buffer, if not create it\n  if (!createKnobImage.cache[cacheKey]) {\n    knobBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"createBuffer\"])(size * 1.18889, size * 1.18889)\n    knobCtx = knobBuffer.getContext('2d')\n\n    switch (knob.type) {\n      case 'metalKnob':\n        // METALKNOB_FRAME\n        knobCtx.beginPath()\n        knobCtx.moveTo(0, size * 0.5)\n        knobCtx.bezierCurveTo(\n          0,\n          size * 0.222222,\n          size * 0.222222,\n          0,\n          size * 0.5,\n          0\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.777777,\n          0,\n          size,\n          size * 0.222222,\n          size,\n          size * 0.5\n        )\n        knobCtx.bezierCurveTo(\n          size,\n          size * 0.777777,\n          size * 0.777777,\n          size,\n          size * 0.5,\n          size\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.222222,\n          size,\n          0,\n          size * 0.777777,\n          0,\n          size * 0.5\n        )\n        knobCtx.closePath()\n        grad = knobCtx.createLinearGradient(0, 0, 0, size)\n        grad.addColorStop(0, 'rgb(92, 95, 101)')\n        grad.addColorStop(0.47, 'rgb(46, 49, 53)')\n        grad.addColorStop(1, 'rgb(22, 23, 26)')\n        knobCtx.fillStyle = grad\n        knobCtx.fill()\n\n        // METALKNOB_MAIN\n        knobCtx.beginPath()\n        knobCtx.moveTo(size * 0.055555, size * 0.5)\n        knobCtx.bezierCurveTo(\n          size * 0.055555,\n          size * 0.277777,\n          size * 0.277777,\n          size * 0.055555,\n          size * 0.5,\n          size * 0.055555\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.722222,\n          size * 0.055555,\n          size * 0.944444,\n          size * 0.277777,\n          size * 0.944444,\n          size * 0.5\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.944444,\n          size * 0.722222,\n          size * 0.722222,\n          size * 0.944444,\n          size * 0.5,\n          size * 0.944444\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.277777,\n          size * 0.944444,\n          size * 0.055555,\n          size * 0.722222,\n          size * 0.055555,\n          size * 0.5\n        )\n        knobCtx.closePath()\n        grad = knobCtx.createLinearGradient(\n          0,\n          0.055555 * size,\n          0,\n          0.944443 * size\n        )\n        switch (style.style) {\n          case 'black':\n            grad.addColorStop(0, 'rgb(43, 42, 47)')\n            grad.addColorStop(1, 'rgb(26, 27, 32)')\n            break\n\n          case 'brass':\n            grad.addColorStop(0, 'rgb(150, 110, 54)')\n            grad.addColorStop(1, 'rgb(124, 95, 61)')\n            break\n\n          case 'silver':\n          /* falls through */\n          default:\n            grad.addColorStop(0, 'rgb(204, 204, 204)')\n            grad.addColorStop(1, 'rgb(87, 92, 98)')\n            break\n        }\n        knobCtx.fillStyle = grad\n        knobCtx.fill()\n\n        // METALKNOB_LOWERHL\n        knobCtx.beginPath()\n        knobCtx.moveTo(size * 0.777777, size * 0.833333)\n        knobCtx.bezierCurveTo(\n          size * 0.722222,\n          size * 0.722222,\n          size * 0.611111,\n          size * 0.666666,\n          size * 0.5,\n          size * 0.666666\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.388888,\n          size * 0.666666,\n          size * 0.277777,\n          size * 0.722222,\n          size * 0.222222,\n          size * 0.833333\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.277777,\n          size * 0.888888,\n          size * 0.388888,\n          size * 0.944444,\n          size * 0.5,\n          size * 0.944444\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.611111,\n          size * 0.944444,\n          size * 0.722222,\n          size * 0.888888,\n          size * 0.777777,\n          size * 0.833333\n        )\n        knobCtx.closePath()\n        grad = knobCtx.createRadialGradient(\n          0.555555 * size,\n          0.944444 * size,\n          0,\n          0.555555 * size,\n          0.944444 * size,\n          0.388888 * size\n        )\n        grad.addColorStop(0, 'rgba(255, 255, 255, 0.6)')\n        grad.addColorStop(1, 'rgba(255, 255, 255, 0)')\n        knobCtx.fillStyle = grad\n        knobCtx.fill()\n\n        // METALKNOB_UPPERHL\n        knobCtx.beginPath()\n        knobCtx.moveTo(size * 0.944444, size * 0.277777)\n        knobCtx.bezierCurveTo(\n          size * 0.833333,\n          size * 0.111111,\n          size * 0.666666,\n          0,\n          size * 0.5,\n          0\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.333333,\n          0,\n          size * 0.166666,\n          size * 0.111111,\n          size * 0.055555,\n          size * 0.277777\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.166666,\n          size * 0.333333,\n          size * 0.333333,\n          size * 0.388888,\n          size * 0.5,\n          size * 0.388888\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.666666,\n          size * 0.388888,\n          size * 0.833333,\n          size * 0.333333,\n          size * 0.944444,\n          size * 0.277777\n        )\n        knobCtx.closePath()\n        grad = knobCtx.createRadialGradient(\n          0.5 * size,\n          0,\n          0,\n          0.5 * size,\n          0,\n          0.583333 * size\n        )\n        grad.addColorStop(0, 'rgba(255, 255, 255, 0.749019)')\n        grad.addColorStop(1, 'rgba(255, 255, 255, 0)')\n        knobCtx.fillStyle = grad\n        knobCtx.fill()\n\n        // METALKNOB_INNERFRAME\n        knobCtx.beginPath()\n        knobCtx.moveTo(size * 0.277777, size * 0.555555)\n        knobCtx.bezierCurveTo(\n          size * 0.277777,\n          size * 0.388888,\n          size * 0.388888,\n          size * 0.277777,\n          size * 0.5,\n          size * 0.277777\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.611111,\n          size * 0.277777,\n          size * 0.777777,\n          size * 0.388888,\n          size * 0.777777,\n          size * 0.555555\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.777777,\n          size * 0.666666,\n          size * 0.611111,\n          size * 0.777777,\n          size * 0.5,\n          size * 0.777777\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.388888,\n          size * 0.777777,\n          size * 0.277777,\n          size * 0.666666,\n          size * 0.277777,\n          size * 0.555555\n        )\n        knobCtx.closePath()\n        grad = knobCtx.createLinearGradient(\n          0,\n          0.277777 * size,\n          0,\n          0.722221 * size\n        )\n        grad.addColorStop(0, '#000000')\n        grad.addColorStop(1, 'rgb(204, 204, 204)')\n        knobCtx.fillStyle = grad\n        knobCtx.fill()\n\n        // METALKNOB_INNERBACKGROUND\n        knobCtx.beginPath()\n        knobCtx.moveTo(size * 0.333333, size * 0.555555)\n        knobCtx.bezierCurveTo(\n          size * 0.333333,\n          size * 0.444444,\n          size * 0.388888,\n          size * 0.333333,\n          size * 0.5,\n          size * 0.333333\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.611111,\n          size * 0.333333,\n          size * 0.722222,\n          size * 0.444444,\n          size * 0.722222,\n          size * 0.555555\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.722222,\n          size * 0.611111,\n          size * 0.611111,\n          size * 0.722222,\n          size * 0.5,\n          size * 0.722222\n        )\n        knobCtx.bezierCurveTo(\n          size * 0.388888,\n          size * 0.722222,\n          size * 0.333333,\n          size * 0.611111,\n          size * 0.333333,\n          size * 0.555555\n        )\n        knobCtx.closePath()\n        grad = knobCtx.createLinearGradient(\n          0,\n          0.333333 * size,\n          0,\n          0.666666 * size\n        )\n        grad.addColorStop(0, 'rgb(10, 9, 1)')\n        grad.addColorStop(1, 'rgb(42, 41, 37)')\n        knobCtx.fillStyle = grad\n        knobCtx.fill()\n        break\n\n      case 'standardKnob':\n        grad = knobCtx.createLinearGradient(0, 0, 0, size)\n        grad.addColorStop(0, 'rgb(180, 180, 180)')\n        grad.addColorStop(0.46, 'rgb(63, 63, 63)')\n        grad.addColorStop(1, 'rgb(40, 40, 40)')\n        knobCtx.fillStyle = grad\n        knobCtx.beginPath()\n        knobCtx.arc(maxPostCenterX, maxPostCenterY, size / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n        knobCtx.closePath()\n        knobCtx.fill()\n        grad = knobCtx.createLinearGradient(\n          0,\n          size - size * 0.77,\n          0,\n          size - size * 0.77 + size * 0.77\n        )\n        switch (style.style) {\n          case 'black':\n            grad.addColorStop(0, 'rgb(191, 191, 191)')\n            grad.addColorStop(0.5, 'rgb(45, 44, 49)')\n            grad.addColorStop(1, 'rgb(125, 126, 128)')\n            break\n\n          case 'brass':\n            grad.addColorStop(0, 'rgb(223, 208, 174)')\n            grad.addColorStop(0.5, 'rgb(123, 95, 63)')\n            grad.addColorStop(1, 'rgb(207, 190, 157)')\n            break\n\n          case 'silver':\n          /* falls through */\n          default:\n            grad.addColorStop(0, 'rgb(215, 215, 215)')\n            grad.addColorStop(0.5, 'rgb(116, 116, 116)')\n            grad.addColorStop(1, 'rgb(215, 215, 215)')\n            break\n        }\n        knobCtx.fillStyle = grad\n        knobCtx.beginPath()\n        knobCtx.arc(\n          maxPostCenterX,\n          maxPostCenterY,\n          (size * 0.77) / 2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n          true\n        )\n        knobCtx.closePath()\n        knobCtx.fill()\n\n        grad = knobCtx.createRadialGradient(\n          maxPostCenterX,\n          maxPostCenterY,\n          0,\n          maxPostCenterX,\n          maxPostCenterY,\n          (size * 0.77) / 2\n        )\n        grad.addColorStop(0, 'rgba(0, 0, 0, 0)')\n        grad.addColorStop(0.75, 'rgba(0, 0, 0, 0)')\n        grad.addColorStop(0.76, 'rgba(0, 0, 0, 0.01)')\n        grad.addColorStop(1, 'rgba(0, 0, 0, 0.2)')\n        knobCtx.fillStyle = grad\n        knobCtx.beginPath()\n        knobCtx.arc(\n          maxPostCenterX,\n          maxPostCenterY,\n          (size * 0.77) / 2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n          true\n        )\n        knobCtx.closePath()\n        knobCtx.fill()\n        break\n    }\n\n    // cache the buffer\n    createKnobImage.cache[cacheKey] = knobBuffer\n  }\n  return createKnobImage.cache[cacheKey]\n}\ncreateKnobImage.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createKnobImage);\n\n\n//# sourceURL=webpack://steelseries/./src/createKnobImage.js?");

/***/ }),

/***/ "./src/createLcdBackgroundImage.js":
/*!*****************************************!*\
  !*** ./src/createLcdBackgroundImage.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst createLcdBackgroundImage = function (width, height, lcdColor) {\n  let lcdBuffer\n  let lcdCtx\n  const xB = 0\n  const yB = 0\n  const wB = width\n  const hB = height\n  const rB = Math.min(width, height) * 0.095\n  let grad\n  const xF = 1\n  const yF = 1\n  const wF = width - 2\n  const hF = height - 2\n  const rF = rB - 1\n  const cacheKey = width.toString() + height + JSON.stringify(lcdColor)\n\n  // check if we have already created and cached this buffer, if not create it\n  if (!createLcdBackgroundImage.cache[cacheKey]) {\n    lcdBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"createBuffer\"])(width, height)\n    lcdCtx = lcdBuffer.getContext('2d')\n    // background\n    grad = lcdCtx.createLinearGradient(0, yB, 0, yB + hB)\n    grad.addColorStop(0, '#4c4c4c')\n    grad.addColorStop(0.08, '#666666')\n    grad.addColorStop(0.92, '#666666')\n    grad.addColorStop(1, '#e6e6e6')\n    lcdCtx.fillStyle = grad\n    Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(lcdCtx, xB, yB, wB, hB, rB)\n    lcdCtx.fill()\n\n    // foreground\n    grad = lcdCtx.createLinearGradient(0, yF, 0, yF + hF)\n    grad.addColorStop(0, lcdColor.gradientStartColor)\n    grad.addColorStop(0.03, lcdColor.gradientFraction1Color)\n    grad.addColorStop(0.49, lcdColor.gradientFraction2Color)\n    grad.addColorStop(0.5, lcdColor.gradientFraction3Color)\n    grad.addColorStop(1, lcdColor.gradientStopColor)\n    lcdCtx.fillStyle = grad\n    Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(lcdCtx, xF, yF, wF, hF, rF)\n    lcdCtx.fill()\n    // cache the buffer\n    createLcdBackgroundImage.cache[cacheKey] = lcdBuffer\n  }\n  return createLcdBackgroundImage.cache[cacheKey]\n}\ncreateLcdBackgroundImage.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createLcdBackgroundImage);\n\n\n//# sourceURL=webpack://steelseries/./src/createLcdBackgroundImage.js?");

/***/ }),

/***/ "./src/createLedImage.js":
/*!*******************************!*\
  !*** ./src/createLedImage.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst createLedImage = function (size, state, ledColor) {\n  let ledBuffer\n  let ledCtx\n  // Bug in Chrome browser, radialGradients do not draw correctly if the center is not an integer value\n  const ledCenterX = 2 * Math.round(size / 4)\n  const ledCenterY = 2 * Math.round(size / 4)\n  let grad\n  const cacheKey = size.toString() + state + ledColor.outerColor_ON\n\n  // check if we have already created and cached this buffer, if not create it\n  if (!createLedImage.cache[cacheKey]) {\n    ledBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"createBuffer\"])(size, size)\n    ledCtx = ledBuffer.getContext('2d')\n\n    switch (state) {\n      case 0: // LED OFF\n        // OFF Gradient\n        grad = ledCtx.createRadialGradient(\n          ledCenterX,\n          ledCenterY,\n          0,\n          ledCenterX,\n          ledCenterY,\n          (size * 0.5) / 2\n        )\n        grad.addColorStop(0, ledColor.innerColor1_OFF)\n        grad.addColorStop(0.2, ledColor.innerColor2_OFF)\n        grad.addColorStop(1, ledColor.outerColor_OFF)\n        ledCtx.fillStyle = grad\n\n        ledCtx.beginPath()\n        ledCtx.arc(ledCenterX, ledCenterY, (size * 0.5) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n        ledCtx.closePath()\n        ledCtx.fill()\n\n        // InnerShadow\n        grad = ledCtx.createRadialGradient(\n          ledCenterX,\n          ledCenterY,\n          0,\n          ledCenterX,\n          ledCenterY,\n          (size * 0.5) / 2\n        )\n        grad.addColorStop(0, 'rgba(0, 0, 0, 0)')\n        grad.addColorStop(0.8, 'rgba(0, 0, 0, 0)')\n        grad.addColorStop(1, 'rgba(0, 0, 0, 0.4)')\n        ledCtx.fillStyle = grad\n\n        ledCtx.beginPath()\n        ledCtx.arc(ledCenterX, ledCenterY, (size * 0.5) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n        ledCtx.closePath()\n        ledCtx.fill()\n\n        // LightReflex\n        grad = ledCtx.createLinearGradient(\n          0,\n          0.35 * size,\n          0,\n          0.35 * size + 0.15 * size\n        )\n        grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)')\n        grad.addColorStop(1, 'rgba(255, 255, 255, 0)')\n        ledCtx.fillStyle = grad\n\n        ledCtx.beginPath()\n        ledCtx.arc(\n          ledCenterX,\n          0.35 * size + (0.2 * size) / 2,\n          size * 0.2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n          true\n        )\n        ledCtx.closePath()\n        ledCtx.fill()\n        break\n\n      case 1: // LED ON\n        // ON Gradient\n        grad = ledCtx.createRadialGradient(\n          ledCenterX,\n          ledCenterY,\n          0,\n          ledCenterX,\n          ledCenterY,\n          (size * 0.5) / 2\n        )\n        grad.addColorStop(0, ledColor.innerColor1_ON)\n        grad.addColorStop(0.2, ledColor.innerColor2_ON)\n        grad.addColorStop(1, ledColor.outerColor_ON)\n        ledCtx.fillStyle = grad\n\n        ledCtx.beginPath()\n        ledCtx.arc(ledCenterX, ledCenterY, (size * 0.5) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n        ledCtx.closePath()\n        ledCtx.fill()\n\n        // InnerShadow\n        grad = ledCtx.createRadialGradient(\n          ledCenterX,\n          ledCenterY,\n          0,\n          ledCenterX,\n          ledCenterY,\n          (size * 0.5) / 2\n        )\n        grad.addColorStop(0, 'rgba(0, 0, 0, 0)')\n        grad.addColorStop(0.8, 'rgba(0, 0, 0, 0)')\n        grad.addColorStop(1, 'rgba(0, 0, 0, 0.4)')\n        ledCtx.fillStyle = grad\n\n        ledCtx.beginPath()\n        ledCtx.arc(ledCenterX, ledCenterY, (size * 0.5) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n        ledCtx.closePath()\n        ledCtx.fill()\n\n        // LightReflex\n        grad = ledCtx.createLinearGradient(\n          0,\n          0.35 * size,\n          0,\n          0.35 * size + 0.15 * size\n        )\n        grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)')\n        grad.addColorStop(1, 'rgba(255, 255, 255, 0)')\n        ledCtx.fillStyle = grad\n\n        ledCtx.beginPath()\n        ledCtx.arc(\n          ledCenterX,\n          0.35 * size + (0.2 * size) / 2,\n          size * 0.2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n          true\n        )\n        ledCtx.closePath()\n        ledCtx.fill()\n\n        // Corona\n        grad = ledCtx.createRadialGradient(\n          ledCenterX,\n          ledCenterY,\n          0,\n          ledCenterX,\n          ledCenterY,\n          size / 2\n        )\n        grad.addColorStop(0, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0))\n        grad.addColorStop(0.6, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.4))\n        grad.addColorStop(0.7, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.25))\n        grad.addColorStop(0.8, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.15))\n        grad.addColorStop(0.85, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.05))\n        grad.addColorStop(1, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0))\n        ledCtx.fillStyle = grad\n\n        ledCtx.beginPath()\n        ledCtx.arc(ledCenterX, ledCenterY, size / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n        ledCtx.closePath()\n        ledCtx.fill()\n        break\n    }\n    // cache the buffer\n    createLedImage.cache[cacheKey] = ledBuffer\n  }\n  return createLedImage.cache[cacheKey]\n}\ncreateLedImage.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createLedImage);\n\n\n//# sourceURL=webpack://steelseries/./src/createLedImage.js?");

/***/ }),

/***/ "./src/createMeasuredValueImage.js":
/*!*****************************************!*\
  !*** ./src/createMeasuredValueImage.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst createMeasuredValueImage = function (\n  size,\n  indicatorColor,\n  radial,\n  vertical\n) {\n  let indicatorBuffer\n  let indicatorCtx\n  const cacheKey = size.toString() + indicatorColor + radial + vertical\n\n  // check if we have already created and cached this buffer, if so return it and exit\n  if (!createMeasuredValueImage.cache[cacheKey]) {\n    indicatorBuffer = _tools__WEBPACK_IMPORTED_MODULE_0__[\"doc\"].createElement('canvas')\n    indicatorCtx = indicatorBuffer.getContext('2d')\n    indicatorBuffer.width = size\n    indicatorBuffer.height = size\n    indicatorCtx.fillStyle = indicatorColor\n    if (radial) {\n      indicatorCtx.beginPath()\n      indicatorCtx.moveTo(size * 0.5, size)\n      indicatorCtx.lineTo(0, 0)\n      indicatorCtx.lineTo(size, 0)\n      indicatorCtx.closePath()\n      indicatorCtx.fill()\n    } else {\n      if (vertical) {\n        indicatorCtx.beginPath()\n        indicatorCtx.moveTo(size, size * 0.5)\n        indicatorCtx.lineTo(0, 0)\n        indicatorCtx.lineTo(0, size)\n        indicatorCtx.closePath()\n        indicatorCtx.fill()\n      } else {\n        indicatorCtx.beginPath()\n        indicatorCtx.moveTo(size * 0.5, 0)\n        indicatorCtx.lineTo(size, size)\n        indicatorCtx.lineTo(0, size)\n        indicatorCtx.closePath()\n        indicatorCtx.fill()\n      }\n    }\n    // cache the buffer\n    createMeasuredValueImage.cache[cacheKey] = indicatorBuffer\n  }\n  return createMeasuredValueImage.cache[cacheKey]\n}\ncreateMeasuredValueImage.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createMeasuredValueImage);\n\n\n//# sourceURL=webpack://steelseries/./src/createMeasuredValueImage.js?");

/***/ }),

/***/ "./src/createTrendIndicator.js":
/*!*************************************!*\
  !*** ./src/createTrendIndicator.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst createTrendIndicator = function (width, onSection, colors) {\n  const height = width * 2\n  let trendBuffer\n  let trendCtx\n  let fill\n  const cacheKey = onSection.state + width + JSON.stringify(colors)\n\n  const drawUpArrow = function () {\n    // draw up arrow (red)\n    const ledColor = colors[0]\n\n    if (onSection.state === 'up') {\n      fill = trendCtx.createRadialGradient(\n        0.5 * width,\n        0.2 * height,\n        0,\n        0.5 * width,\n        0.2 * height,\n        0.5 * width\n      )\n      fill.addColorStop(0, ledColor.innerColor1_ON)\n      fill.addColorStop(0.2, ledColor.innerColor2_ON)\n      fill.addColorStop(1, ledColor.outerColor_ON)\n    } else {\n      fill = trendCtx.createLinearGradient(0, 0, 0, 0.5 * height)\n      fill.addColorStop(0, '#323232')\n      fill.addColorStop(1, '#5c5c5c')\n    }\n    trendCtx.fillStyle = fill\n    trendCtx.beginPath()\n    trendCtx.moveTo(0.5 * width, 0)\n    trendCtx.lineTo(width, 0.2 * height)\n    trendCtx.lineTo(0.752 * width, 0.2 * height)\n    trendCtx.lineTo(0.752 * width, 0.37 * height)\n    trendCtx.lineTo(0.252 * width, 0.37 * height)\n    trendCtx.lineTo(0.252 * width, 0.2 * height)\n    trendCtx.lineTo(0, 0.2 * height)\n    trendCtx.closePath()\n    trendCtx.fill()\n    if (onSection.state !== 'up') {\n      // Inner shadow\n      trendCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)'\n      trendCtx.beginPath()\n      trendCtx.moveTo(0, 0.2 * height)\n      trendCtx.lineTo(0.5 * width, 0)\n      trendCtx.lineTo(width, 0.2 * height)\n      trendCtx.moveTo(0.252 * width, 0.2 * height)\n      trendCtx.lineTo(0.252 * width, 0.37 * height)\n      trendCtx.stroke()\n      // Inner highlight\n      trendCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)'\n      trendCtx.beginPath()\n      trendCtx.moveTo(0.252 * width, 0.37 * height)\n      trendCtx.lineTo(0.752 * width, 0.37 * height)\n      trendCtx.lineTo(0.752 * width, 0.2 * height)\n      trendCtx.lineTo(width, 0.2 * height)\n      trendCtx.stroke()\n    } else {\n      // draw halo\n      fill = trendCtx.createRadialGradient(\n        0.5 * width,\n        0.2 * height,\n        0,\n        0.5 * width,\n        0.2 * height,\n        0.7 * width\n      )\n      fill.addColorStop(0, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0))\n      fill.addColorStop(0.5, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.3))\n      fill.addColorStop(0.7, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.2))\n      fill.addColorStop(0.8, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.1))\n      fill.addColorStop(0.85, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.05))\n      fill.addColorStop(1, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0))\n      trendCtx.fillStyle = fill\n\n      trendCtx.beginPath()\n      trendCtx.arc(0.5 * width, 0.2 * height, 0.7 * width, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n      trendCtx.closePath()\n      trendCtx.fill()\n    }\n  }\n\n  const drawEquals = function () {\n    // draw equal symbol\n    const ledColor = colors[1]\n\n    trendCtx.beginPath()\n    if (onSection.state === 'steady') {\n      fill = ledColor.outerColor_ON\n      trendCtx.fillStyle = fill\n      trendCtx.rect(\n        0.128 * width,\n        0.41 * height,\n        0.744 * width,\n        0.074 * height\n      )\n      trendCtx.rect(\n        0.128 * width,\n        0.516 * height,\n        0.744 * width,\n        0.074 * height\n      )\n      trendCtx.closePath()\n      trendCtx.fill()\n    } else {\n      fill = trendCtx.createLinearGradient(\n        0,\n        0.41 * height,\n        0,\n        0.41 * height + 0.074 * height\n      )\n      fill.addColorStop(0, '#323232')\n      fill.addColorStop(1, '#5c5c5c')\n      trendCtx.fillStyle = fill\n      trendCtx.rect(\n        0.128 * width,\n        0.41 * height,\n        0.744 * width,\n        0.074 * height\n      )\n      trendCtx.closePath()\n      trendCtx.fill()\n      fill = trendCtx.createLinearGradient(\n        0,\n        0.516 * height,\n        0,\n        0.516 * height + 0.074 * height\n      )\n      fill.addColorStop(0, '#323232')\n      fill.addColorStop(1, '#5c5c5c')\n      trendCtx.fillStyle = fill\n      trendCtx.rect(\n        0.128 * width,\n        0.516 * height,\n        0.744 * width,\n        0.074 * height\n      )\n      trendCtx.closePath()\n      trendCtx.fill()\n    }\n    if (onSection.state !== 'steady') {\n      // inner shadow\n      trendCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)'\n      trendCtx.beginPath()\n      trendCtx.moveTo(0.128 * width, 0.41 * height + 0.074 * height)\n      trendCtx.lineTo(0.128 * width, 0.41 * height)\n      trendCtx.lineTo(0.128 * width + 0.744 * width, 0.41 * height)\n      trendCtx.stroke()\n      trendCtx.beginPath()\n      trendCtx.moveTo(0.128 * width, 0.516 * height + 0.074 * height)\n      trendCtx.lineTo(0.128 * width, 0.516 * height)\n      trendCtx.lineTo(0.128 * width + 0.744 * width, 0.516 * height)\n      trendCtx.stroke()\n      // inner highlight\n      trendCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)'\n      trendCtx.beginPath()\n      trendCtx.moveTo(0.128 * width + 0.744 * width, 0.41 * height)\n      trendCtx.lineTo(\n        0.128 * width + 0.744 * width,\n        0.41 * height + 0.074 * height\n      )\n      trendCtx.lineTo(0.128 * width, 0.41 * height + 0.074 * height)\n      trendCtx.stroke()\n      trendCtx.beginPath()\n      trendCtx.moveTo(0.128 * width + 0.744 * width, 0.516 * height)\n      trendCtx.lineTo(\n        0.128 * width + 0.744 * width,\n        0.516 * height + 0.074 * height\n      )\n      trendCtx.lineTo(0.128 * width, 0.516 * height + 0.074 * height)\n      trendCtx.stroke()\n    } else {\n      // draw halo\n      fill = trendCtx.createRadialGradient(\n        0.5 * width,\n        0.5 * height,\n        0,\n        0.5 * width,\n        0.5 * height,\n        0.7 * width\n      )\n      fill.addColorStop(0, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0))\n      fill.addColorStop(0.5, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.3))\n      fill.addColorStop(0.7, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.2))\n      fill.addColorStop(0.8, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.1))\n      fill.addColorStop(0.85, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.05))\n      fill.addColorStop(1, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0))\n      trendCtx.fillStyle = fill\n      trendCtx.beginPath()\n      trendCtx.arc(0.5 * width, 0.5 * height, 0.7 * width, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n      trendCtx.closePath()\n      trendCtx.fill()\n    }\n  }\n\n  const drawDownArrow = function () {\n    // draw down arrow\n    const ledColor = colors[2]\n    if (onSection.state === 'down') {\n      fill = trendCtx.createRadialGradient(\n        0.5 * width,\n        0.8 * height,\n        0,\n        0.5 * width,\n        0.8 * height,\n        0.5 * width\n      )\n      fill.addColorStop(0, ledColor.innerColor1_ON)\n      fill.addColorStop(0.2, ledColor.innerColor2_ON)\n      fill.addColorStop(1, ledColor.outerColor_ON)\n    } else {\n      fill = trendCtx.createLinearGradient(0, 0.63 * height, 0, height)\n      fill.addColorStop(0, '#323232')\n      fill.addColorStop(1, '#5c5c5c')\n    }\n    trendCtx.beginPath()\n    trendCtx.fillStyle = fill\n    trendCtx.moveTo(0.5 * width, height)\n    trendCtx.lineTo(width, 0.8 * height)\n    trendCtx.lineTo(0.725 * width, 0.8 * height)\n    trendCtx.lineTo(0.725 * width, 0.63 * height)\n    trendCtx.lineTo(0.252 * width, 0.63 * height)\n    trendCtx.lineTo(0.252 * width, 0.8 * height)\n    trendCtx.lineTo(0, 0.8 * height)\n    trendCtx.closePath()\n    trendCtx.fill()\n    if (onSection.state !== 'down') {\n      // Inner shadow\n      trendCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)'\n      trendCtx.beginPath()\n      trendCtx.moveTo(0, 0.8 * height)\n      trendCtx.lineTo(0.252 * width, 0.8 * height)\n      trendCtx.moveTo(0.252 * width, 0.63 * height)\n      trendCtx.lineTo(0.752 * width, 0.63 * height)\n      trendCtx.stroke()\n      trendCtx.beginPath()\n      trendCtx.moveTo(0.752 * width, 0.8 * height)\n      trendCtx.lineTo(width, 0.8 * height)\n      trendCtx.stroke()\n      // Inner highlight\n      trendCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)'\n      trendCtx.beginPath()\n      trendCtx.moveTo(0, 0.8 * height)\n      trendCtx.lineTo(0.5 * width, height)\n      trendCtx.lineTo(width, 0.8 * height)\n      trendCtx.stroke()\n      trendCtx.beginPath()\n      trendCtx.moveTo(0.752 * width, 0.8 * height)\n      trendCtx.lineTo(0.752 * width, 0.63 * height)\n      trendCtx.stroke()\n    } else {\n      // draw halo\n      fill = trendCtx.createRadialGradient(\n        0.5 * width,\n        0.8 * height,\n        0,\n        0.5 * width,\n        0.8 * height,\n        0.7 * width\n      )\n      fill.addColorStop(0, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0))\n      fill.addColorStop(0.5, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.3))\n      fill.addColorStop(0.7, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.2))\n      fill.addColorStop(0.8, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.1))\n      fill.addColorStop(0.85, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0.05))\n      fill.addColorStop(1, Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"setAlpha\"])(ledColor.coronaColor, 0))\n      trendCtx.fillStyle = fill\n      trendCtx.beginPath()\n      trendCtx.arc(0.5 * width, 0.8 * height, 0.7 * width, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n      trendCtx.closePath()\n      trendCtx.fill()\n    }\n  }\n\n  // Check if we have already cached this indicator, if not create it\n  if (!createTrendIndicator.cache[cacheKey]) {\n    // create oversized buffer for the glow\n    trendBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"createBuffer\"])(width * 2, width * 4)\n    trendCtx = trendBuffer.getContext('2d')\n    trendCtx.translate(width * 0.5, width * 0.5)\n    // Must draw the active section last so the 'glow' is on top\n    switch (onSection.state) {\n      case 'up':\n        drawDownArrow()\n        drawEquals()\n        drawUpArrow()\n        break\n      case 'steady':\n        drawDownArrow()\n        drawUpArrow()\n        drawEquals()\n        break\n      case 'down':\n      /* falls through */\n      default:\n        drawUpArrow()\n        drawEquals()\n        drawDownArrow()\n        break\n    }\n    // cache the buffer\n    createTrendIndicator.cache[cacheKey] = trendBuffer\n  }\n  return createTrendIndicator.cache[cacheKey]\n}\ncreateTrendIndicator.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createTrendIndicator);\n\n\n//# sourceURL=webpack://steelseries/./src/createTrendIndicator.js?");

/***/ }),

/***/ "./src/definitions.js":
/*!****************************!*\
  !*** ./src/definitions.js ***!
  \****************************/
/*! exports provided: BackgroundColor, LcdColor, ColorDef, LedColor, GaugeType, Orientation, KnobType, KnobStyle, FrameDesign, PointerType, ForegroundType, LabelNumberFormat, TickLabelOrientation, TrendState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BackgroundColor\", function() { return BackgroundColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LcdColor\", function() { return LcdColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorDef\", function() { return Color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LedColor\", function() { return LedColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GaugeType\", function() { return GaugeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Orientation\", function() { return Orientation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KnobType\", function() { return KnobType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KnobStyle\", function() { return KnobStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FrameDesign\", function() { return FrameDesign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointerType\", function() { return PointerType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ForegroundType\", function() { return ForegroundType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LabelNumberFormat\", function() { return LabelNumberFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TickLabelOrientation\", function() { return TickLabelOrientation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TrendState\", function() { return TrendState; });\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\n\n\n\nconst BackgroundColor = {\n  DARK_GRAY: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](51, 51, 51, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](153, 153, 153, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](180, 180, 180, 1),\n    'DARK_GRAY'\n  ),\n  SATIN_GRAY: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](45, 57, 57, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](45, 57, 57, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](45, 57, 57, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](167, 184, 180, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](137, 154, 150, 1),\n    'SATIN_GRAY'\n  ),\n  LIGHT_GRAY: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](130, 130, 130, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](181, 181, 181, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](253, 253, 253, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](80, 80, 80, 1),\n    'LIGHT_GRAY'\n  ),\n  WHITE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](80, 80, 80, 1),\n    'WHITE'\n  ),\n  BLACK: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](150, 150, 150, 1),\n    'BLACK'\n  ),\n  BEIGE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](178, 172, 150, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](204, 205, 184, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](231, 231, 214, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](80, 80, 80, 1),\n    'BEIGE'\n  ),\n  BROWN: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](245, 225, 193, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](245, 225, 193, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 250, 240, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](109, 73, 47, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](89, 53, 27, 1),\n    'BROWN'\n  ),\n  RED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](198, 93, 95, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](212, 132, 134, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](242, 218, 218, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](90, 0, 0, 1),\n    'RED'\n  ),\n  GREEN: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](65, 120, 40, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](129, 171, 95, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](218, 237, 202, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 90, 0, 1),\n    'GREEN'\n  ),\n  BLUE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](45, 83, 122, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](115, 144, 170, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](227, 234, 238, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 90, 1),\n    'BLUE'\n  ),\n  ANTHRACITE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](50, 50, 54, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](47, 47, 51, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](69, 69, 74, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](250, 250, 250, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](180, 180, 180, 1),\n    'ANTHRACITE'\n  ),\n  MUD: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](80, 86, 82, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](70, 76, 72, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](57, 62, 58, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 240, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](225, 225, 210, 1),\n    'MUD'\n  ),\n  PUNCHED_SHEET: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](50, 50, 54, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](47, 47, 51, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](69, 69, 74, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](180, 180, 180, 1),\n    'PUNCHED_SHEET'\n  ),\n  CARBON: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](50, 50, 54, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](47, 47, 51, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](69, 69, 74, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](180, 180, 180, 1),\n    'CARBON'\n  ),\n  STAINLESS: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](130, 130, 130, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](181, 181, 181, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](253, 253, 253, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](80, 80, 80, 1),\n    'STAINLESS'\n  ),\n  BRUSHED_METAL: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](50, 50, 54, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](47, 47, 51, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](69, 69, 74, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](80, 80, 80, 1),\n    'BRUSHED_METAL'\n  ),\n  BRUSHED_STAINLESS: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](50, 50, 54, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](47, 47, 51, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](110, 110, 112, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](80, 80, 80, 1),\n    'BRUSHED_STAINLESS'\n  ),\n  TURNED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"BackgroundColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](130, 130, 130, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](181, 181, 181, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](253, 253, 253, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](80, 80, 80, 1),\n    'TURNED'\n  )\n}\n\nconst LcdColor = {\n  BEIGE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#c8c8b1',\n    'rgb(241, 237, 207)',\n    'rgb(234, 230, 194)',\n    'rgb(225, 220, 183)',\n    'rgb(237, 232, 191)',\n    '#000000'\n  ),\n  BLUE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#ffffff',\n    'rgb(231, 246, 255)',\n    'rgb(170, 224, 255)',\n    'rgb(136, 212, 255)',\n    'rgb(192, 232, 255)',\n    '#124564'\n  ),\n  ORANGE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#ffffff',\n    'rgb(255, 245, 225)',\n    'rgb(255, 217, 147)',\n    'rgb(255, 201, 104)',\n    'rgb(255, 227, 173)',\n    '#503700'\n  ),\n  RED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#ffffff',\n    'rgb(255, 225, 225)',\n    'rgb(253, 152, 152)',\n    'rgb(252, 114, 115)',\n    'rgb(254, 178, 178)',\n    '#4f0c0e'\n  ),\n  YELLOW: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#ffffff',\n    'rgb(245, 255, 186)',\n    'rgb(210, 255, 0)',\n    'rgb(158, 205, 0)',\n    'rgb(210, 255, 0)',\n    '#405300'\n  ),\n  WHITE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#ffffff',\n    '#ffffff',\n    'rgb(241, 246, 242)',\n    'rgb(229, 239, 244)',\n    '#ffffff',\n    '#000000'\n  ),\n  GRAY: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#414141',\n    'rgb(117, 117, 117)',\n    'rgb(87, 87, 87)',\n    '#414141',\n    'rgb(81, 81, 81)',\n    '#ffffff'\n  ),\n  BLACK: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#414141',\n    '#666666',\n    '#333333',\n    '#000000',\n    '#333333',\n    '#cccccc'\n  ),\n  GREEN: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(33, 67, 67)',\n    'rgb(33, 67, 67)',\n    'rgb(29, 58, 58)',\n    'rgb(28, 57, 57)',\n    'rgb(23, 46, 46)',\n    'rgba(0, 185, 165, 255)'\n  ),\n  BLUE2: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(0, 68, 103)',\n    'rgb(8, 109, 165)',\n    'rgb(0, 72, 117)',\n    'rgb(0, 72, 117)',\n    'rgb(0, 68, 103)',\n    'rgb(111, 182, 228)'\n  ),\n  BLUE_BLACK: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(22, 125, 212)',\n    'rgb(3, 162, 254)',\n    'rgb(3, 162, 254)',\n    'rgb(3, 162, 254)',\n    'rgb(11, 172, 244)',\n    '#000000'\n  ),\n  BLUE_DARKBLUE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(18, 33, 88)',\n    'rgb(18, 33, 88)',\n    'rgb(19, 30, 90)',\n    'rgb(17, 31, 94)',\n    'rgb(21, 25, 90)',\n    'rgb(23, 99, 221)'\n  ),\n  BLUE_GRAY: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(135, 174, 255)',\n    'rgb(101, 159, 255)',\n    'rgb(44, 93, 255)',\n    'rgb(27, 65, 254)',\n    'rgb(12, 50, 255)',\n    '#b2b4ed'\n  ),\n  STANDARD: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(131, 133, 119)',\n    'rgb(176, 183, 167)',\n    'rgb(165, 174, 153)',\n    'rgb(166, 175, 156)',\n    'rgb(175, 184, 165)',\n    'rgb(35, 42, 52)'\n  ),\n  STANDARD_GREEN: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#ffffff',\n    'rgb(219, 230, 220)',\n    'rgb(179, 194, 178)',\n    'rgb(153, 176, 151)',\n    'rgb(114, 138, 109)',\n    '#080C06'\n  ),\n  BLUE_BLUE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(100, 168, 253)',\n    'rgb(100, 168, 253)',\n    'rgb(95, 160, 250)',\n    'rgb(80, 144, 252)',\n    'rgb(74, 134, 255)',\n    '#002cbb'\n  ),\n  RED_DARKRED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(72, 36, 50)',\n    'rgb(185, 111, 110)',\n    'rgb(148, 66, 72)',\n    'rgb(83, 19, 20)',\n    'rgb(7, 6, 14)',\n    '#FE8B92'\n  ),\n  DARKBLUE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(14, 24, 31)',\n    'rgb(46, 105, 144)',\n    'rgb(19, 64, 96)',\n    'rgb(6, 20, 29)',\n    'rgb(8, 9, 10)',\n    '#3DB3FF'\n  ),\n  LILA: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(175, 164, 255)',\n    'rgb(188, 168, 253)',\n    'rgb(176, 159, 255)',\n    'rgb(174, 147, 252)',\n    'rgb(168, 136, 233)',\n    '#076148'\n  ),\n  BLACKRED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(8, 12, 11)',\n    'rgb(10, 11, 13)',\n    'rgb(11, 10, 15)',\n    'rgb(7, 13, 9)',\n    'rgb(9, 13, 14)',\n    '#B50026'\n  ),\n  DARKGREEN: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(25, 85, 0)',\n    'rgb(47, 154, 0)',\n    'rgb(30, 101, 0)',\n    'rgb(30, 101, 0)',\n    'rgb(25, 85, 0)',\n    '#233123'\n  ),\n  AMBER: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(182, 71, 0)',\n    'rgb(236, 155, 25)',\n    'rgb(212, 93, 5)',\n    'rgb(212, 93, 5)',\n    'rgb(182, 71, 0)',\n    '#593A0A'\n  ),\n  LIGHTBLUE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    'rgb(125, 146, 184)',\n    'rgb(197, 212, 231)',\n    'rgb(138, 155, 194)',\n    'rgb(138, 155, 194)',\n    'rgb(125, 146, 184)',\n    '#090051'\n  ),\n  SECTIONS: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LcdColorDef\"](\n    '#b2b2b2',\n    '#ffffff',\n    '#c4c4c4',\n    '#c4c4c4',\n    '#b2b2b2',\n    '#000000'\n  )\n}\n\nconst Color = {\n  RED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](82, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](158, 0, 19, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](213, 0, 25, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](240, 82, 88, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 171, 173, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 217, 218, 1)\n  ),\n  GREEN: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](8, 54, 4, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 107, 14, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](15, 148, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](121, 186, 37, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](190, 231, 141, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](234, 247, 218, 1)\n  ),\n  BLUE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 11, 68, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 73, 135, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 108, 201, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 141, 242, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](122, 200, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](204, 236, 255, 1)\n  ),\n  ORANGE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](118, 83, 30, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](215, 67, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](240, 117, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 166, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 128, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 247, 194, 1)\n  ),\n  YELLOW: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](41, 41, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](102, 102, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](177, 165, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 242, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 250, 153, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 252, 204, 1)\n  ),\n  CYAN: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](15, 109, 109, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 109, 144, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 144, 191, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 174, 239, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](153, 223, 249, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](204, 239, 252, 1)\n  ),\n  MAGENTA: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](98, 0, 114, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](128, 24, 72, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](191, 36, 107, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 48, 143, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 172, 210, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 214, 23, 1)\n  ),\n  WHITE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](210, 210, 210, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](220, 220, 220, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](235, 235, 235, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1)\n  ),\n  GRAY: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](25, 25, 25, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](51, 51, 51, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](76, 76, 76, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](128, 128, 128, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](204, 204, 204, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](243, 243, 243, 1)\n  ),\n  BLACK: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](5, 5, 5, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](10, 10, 10, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](15, 15, 15, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](20, 20, 20, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](25, 25, 25, 1)\n  ),\n  RAITH: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 32, 65, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 65, 125, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 106, 172, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](130, 180, 214, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](148, 203, 242, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](191, 229, 255, 1)\n  ),\n  GREEN_LCD: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 55, 45, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](15, 109, 93, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 185, 165, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](48, 255, 204, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](153, 255, 227, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](204, 255, 241, 1)\n  ),\n  JUG_GREEN: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ColorDef\"](\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 56, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](32, 69, 36, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](50, 161, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](129, 206, 0, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](190, 231, 141, 1),\n    new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](234, 247, 218, 1)\n  )\n}\n\n\nconst LedColor = {\n  RED_LED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LedColorDef\"](\n    '#FF9A89',\n    '#FF9A89',\n    '#FF3300',\n    '#FF8D70',\n    '#7E1C00',\n    '#7E1C00',\n    '#641B00'\n  ),\n  GREEN_LED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LedColorDef\"](\n    '#9AFF89',\n    '#9AFF89',\n    '#59FF2A',\n    '#A5FF00',\n    '#1C7E00',\n    '#1C7E00',\n    '#1B6400'\n  ),\n  BLUE_LED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LedColorDef\"](\n    '#899AFF',\n    '#899AFF',\n    '#0033FF',\n    '#708DFF',\n    '#001C7E',\n    '#001C7E',\n    '#001B64'\n  ),\n  ORANGE_LED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LedColorDef\"](\n    '#FEA23F',\n    '#FEA23F',\n    '#FD6C00',\n    '#FD6C00',\n    '#592800',\n    '#592800',\n    '#421F00'\n  ),\n  YELLOW_LED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LedColorDef\"](\n    '#FFFF62',\n    '#FFFF62',\n    '#FFFF00',\n    '#FFFF00',\n    '#6B6D00',\n    '#6B6D00',\n    '#515300'\n  ),\n  CYAN_LED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LedColorDef\"](\n    '#00FFFF',\n    '#00FFFF',\n    '#1BC3C3',\n    '#00FFFF',\n    '#083B3B',\n    '#083B3B',\n    '#052727'\n  ),\n  MAGENTA_LED: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LedColorDef\"](\n    '#D300FF',\n    '#D300FF',\n    '#8600CB',\n    '#C300FF',\n    '#38004B',\n    '#38004B',\n    '#280035'\n  )\n}\n\nconst GaugeType = {\n  TYPE1: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"GaugeTypeDef\"]('type1'),\n  TYPE2: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"GaugeTypeDef\"]('type2'),\n  TYPE3: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"GaugeTypeDef\"]('type3'),\n  TYPE4: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"GaugeTypeDef\"]('type4'),\n  TYPE5: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"GaugeTypeDef\"]('type5')\n}\n\nconst Orientation = {\n  NORTH: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"OrientationDef\"]('north'),\n  SOUTH: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"OrientationDef\"]('south'),\n  EAST: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"OrientationDef\"]('east'),\n  WEST: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"OrientationDef\"]('west')\n}\n\nconst KnobType = {\n  STANDARD_KNOB: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"KnobTypeDef\"]('standardKnob'),\n  METAL_KNOB: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"KnobTypeDef\"]('metalKnob')\n}\n\nconst KnobStyle = {\n  BLACK: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"KnobStyleDef\"]('black'),\n  BRASS: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"KnobStyleDef\"]('brass'),\n  SILVER: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"KnobStyleDef\"]('silver')\n}\n\nconst FrameDesign = {\n  BLACK_METAL: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('blackMetal'),\n  METAL: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('metal'),\n  SHINY_METAL: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('shinyMetal'),\n  BRASS: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('brass'),\n  STEEL: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('steel'),\n  CHROME: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('chrome'),\n  GOLD: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('gold'),\n  ANTHRACITE: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('anthracite'),\n  TILTED_GRAY: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('tiltedGray'),\n  TILTED_BLACK: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('tiltedBlack'),\n  GLOSSY_METAL: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"FrameDesignDef\"]('glossyMetal')\n}\n\nconst PointerType = {\n  TYPE1: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type1'),\n  TYPE2: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type2'),\n  TYPE3: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type3'),\n  TYPE4: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type4'),\n  TYPE5: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type5'),\n  TYPE6: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type6'),\n  TYPE7: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type7'),\n  TYPE8: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type8'),\n  TYPE9: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type9'),\n  TYPE10: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type10'),\n  TYPE11: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type11'),\n  TYPE12: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type12'),\n  TYPE13: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type13'),\n  TYPE14: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type14'),\n  TYPE15: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type15'),\n  TYPE16: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"PointerTypeDef\"]('type16')\n}\n\nconst ForegroundType = {\n  TYPE1: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ForegroundTypeDef\"]('type1'),\n  TYPE2: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ForegroundTypeDef\"]('type2'),\n  TYPE3: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ForegroundTypeDef\"]('type3'),\n  TYPE4: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ForegroundTypeDef\"]('type4'),\n  TYPE5: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"ForegroundTypeDef\"]('type5')\n}\n\nconst LabelNumberFormat = {\n  STANDARD: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LabelNumberFormatDef\"]('standard'),\n  FRACTIONAL: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LabelNumberFormatDef\"]('fractional'),\n  SCIENTIFIC: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"LabelNumberFormatDef\"]('scientific')\n}\n\nconst TickLabelOrientation = {\n  NORMAL: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"TickLabelOrientationDef\"]('normal'),\n  HORIZONTAL: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"TickLabelOrientationDef\"]('horizontal'),\n  TANGENT: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"TickLabelOrientationDef\"]('tangent')\n}\n\nconst TrendState = {\n  UP: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"TrendStateDef\"]('up'),\n  STEADY: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"TrendStateDef\"]('steady'),\n  DOWN: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"TrendStateDef\"]('down'),\n  OFF: new _constants__WEBPACK_IMPORTED_MODULE_1__[\"TrendStateDef\"]('off')\n}\n\n\n//# sourceURL=webpack://steelseries/./src/definitions.js?");

/***/ }),

/***/ "./src/drawBackground.js":
/*!*******************************!*\
  !*** ./src/drawBackground.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _carbonBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carbonBuffer */ \"./src/carbonBuffer.js\");\n/* harmony import */ var _punchedSheetBuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./punchedSheetBuffer */ \"./src/punchedSheetBuffer.js\");\n/* harmony import */ var _brushedMetalTexture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./brushedMetalTexture */ \"./src/brushedMetalTexture.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\n\n\n\nconst drawBackground = function (\n  ctx,\n  backgroundColor,\n  centerX,\n  centerY,\n  imageWidth,\n  imageHeight\n) {\n  let radBBuffer\n  let radBCtx\n  let grad\n  let fractions\n  let colors\n  const backgroundOffsetX = (imageWidth * 0.831775) / 2\n  let mono\n  let textureColor\n  let texture\n  let radius\n  let turnRadius\n  let stepSize\n  let end\n  let i\n  const cacheKey = imageWidth.toString() + imageHeight + backgroundColor.name\n\n  // check if we have already created and cached this buffer, if not create it\n  if (!drawBackground.cache[cacheKey]) {\n    // Setup buffer\n    radBBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"createBuffer\"])(imageWidth, imageHeight)\n    radBCtx = radBBuffer.getContext('2d')\n\n    // Background ellipse\n    radBCtx.beginPath()\n    radBCtx.arc(centerX, centerY, backgroundOffsetX, 0, _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"], true)\n    radBCtx.closePath()\n\n    // If the backgroundColor is a texture fill it with the texture instead of the gradient\n    if (\n      backgroundColor.name === 'CARBON' ||\n      backgroundColor.name === 'PUNCHED_SHEET' ||\n      backgroundColor.name === 'BRUSHED_METAL' ||\n      backgroundColor.name === 'BRUSHED_STAINLESS'\n    ) {\n      if (backgroundColor.name === 'CARBON') {\n        radBCtx.fillStyle = radBCtx.createPattern(_carbonBuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"], 'repeat')\n        radBCtx.fill()\n      }\n\n      if (backgroundColor.name === 'PUNCHED_SHEET') {\n        radBCtx.fillStyle = radBCtx.createPattern(_punchedSheetBuffer__WEBPACK_IMPORTED_MODULE_1__[\"default\"], 'repeat')\n        radBCtx.fill()\n      }\n\n      // Add another inner shadow to make the look more realistic\n      grad = radBCtx.createLinearGradient(\n        backgroundOffsetX,\n        0,\n        imageWidth - backgroundOffsetX,\n        0\n      )\n      grad.addColorStop(0, 'rgba(0, 0, 0, 0.25)')\n      grad.addColorStop(0.5, 'rgba(0, 0, 0, 0)')\n      grad.addColorStop(1, 'rgba(0, 0, 0, 0.25)')\n      radBCtx.fillStyle = grad\n      radBCtx.beginPath()\n      radBCtx.arc(centerX, centerY, backgroundOffsetX, 0, _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"], true)\n      radBCtx.closePath()\n      radBCtx.fill()\n\n      if (\n        backgroundColor.name === 'BRUSHED_METAL' ||\n        backgroundColor.name === 'BRUSHED_STAINLESS'\n      ) {\n        mono = backgroundColor.name === 'BRUSHED_METAL'\n        textureColor = parseInt(\n          backgroundColor.gradientStop.getHexColor().substr(-6),\n          16\n        )\n        texture = Object(_brushedMetalTexture__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(textureColor, 5, 0.1, mono, 0.5)\n        radBCtx.fillStyle = radBCtx.createPattern(\n          texture.fill(0, 0, imageWidth, imageHeight),\n          'no-repeat'\n        )\n        radBCtx.fill()\n      }\n    } else if (\n      backgroundColor.name === 'STAINLESS' ||\n      backgroundColor.name === 'TURNED'\n    ) {\n      // Define the fractions of the conical gradient paint\n      fractions = [\n        0,\n        0.03,\n        0.1,\n        0.14,\n        0.24,\n        0.33,\n        0.38,\n        0.5,\n        0.62,\n        0.67,\n        0.76,\n        0.81,\n        0.85,\n        0.97,\n        1\n      ]\n\n      // Define the colors of the conical gradient paint\n      colors = [\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#B2B2B4'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#ACACAE'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#8E8E8E'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#8E8E8E'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#8E8E8E'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#8E8E8E'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#ACACAE'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#B2B2B4'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n        new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD')\n      ]\n\n      grad = new _tools__WEBPACK_IMPORTED_MODULE_3__[\"ConicalGradient\"](fractions, colors)\n      grad.fillCircle(radBCtx, centerX, centerY, 0, backgroundOffsetX)\n\n      if (backgroundColor.name === 'TURNED') {\n        // Define the turning radius\n        radius = backgroundOffsetX\n        turnRadius = radius * 0.55\n        // Step size proporational to radius\n        stepSize = _tools__WEBPACK_IMPORTED_MODULE_3__[\"RAD_FACTOR\"] * (500 / radius)\n        // Save before we start\n        radBCtx.save()\n        // restrict the turnings to the desired area\n        radBCtx.beginPath()\n        radBCtx.arc(centerX, centerY, radius, 0, _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"])\n        radBCtx.closePath()\n        radBCtx.clip()\n        // set the style for the turnings\n        radBCtx.lineWidth = 0.5\n        end = _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"] - stepSize * 0.3\n        // Step the engine round'n'round\n        for (i = 0; i < end; i += stepSize) {\n          // draw a 'turn'\n          radBCtx.strokeStyle = 'rgba(240, 240, 255, 0.25)'\n          radBCtx.beginPath()\n          radBCtx.arc(centerX + turnRadius, centerY, turnRadius, 0, _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"])\n          radBCtx.stroke()\n          // rotate the 'piece' a fraction to draw 'shadow'\n          radBCtx.translate(centerX, centerY)\n          radBCtx.rotate(stepSize * 0.3)\n          radBCtx.translate(-centerX, -centerY)\n          // draw a 'turn'\n          radBCtx.strokeStyle = 'rgba(25, 10, 10, 0.1)'\n          radBCtx.beginPath()\n          radBCtx.arc(centerX + turnRadius, centerY, turnRadius, 0, _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"])\n          radBCtx.stroke()\n          // now rotate on to the next 'scribe' position minus the 'fraction'\n          radBCtx.translate(centerX, centerY)\n          radBCtx.rotate(stepSize - stepSize * 0.3)\n          radBCtx.translate(-centerX, -centerY)\n        }\n        // Restore canvas now we are done\n        radBCtx.restore()\n      }\n    } else {\n      grad = radBCtx.createLinearGradient(\n        0,\n        imageWidth * 0.084112,\n        0,\n        backgroundOffsetX * 2\n      )\n      grad.addColorStop(0, backgroundColor.gradientStart.getRgbaColor())\n      grad.addColorStop(0.4, backgroundColor.gradientFraction.getRgbaColor())\n      grad.addColorStop(1, backgroundColor.gradientStop.getRgbaColor())\n      radBCtx.fillStyle = grad\n      radBCtx.fill()\n    }\n    // Inner shadow\n    grad = radBCtx.createRadialGradient(\n      centerX,\n      centerY,\n      0,\n      centerX,\n      centerY,\n      backgroundOffsetX\n    )\n    grad.addColorStop(0, 'rgba(0, 0, 0, 0)')\n    grad.addColorStop(0.7, 'rgba(0, 0, 0, 0)')\n    grad.addColorStop(0.71, 'rgba(0, 0, 0, 0)')\n    grad.addColorStop(0.86, 'rgba(0, 0, 0, 0.03)')\n    grad.addColorStop(0.92, 'rgba(0, 0, 0, 0.07)')\n    grad.addColorStop(0.97, 'rgba(0, 0, 0, 0.15)')\n    grad.addColorStop(1, 'rgba(0, 0, 0, 0.3)')\n    radBCtx.fillStyle = grad\n\n    radBCtx.beginPath()\n    radBCtx.arc(centerX, centerY, backgroundOffsetX, 0, _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"], true)\n    radBCtx.closePath()\n    radBCtx.fill()\n\n    // cache the buffer\n    drawBackground.cache[cacheKey] = radBBuffer\n  }\n  ctx.drawImage(drawBackground.cache[cacheKey], 0, 0)\n  return this\n}\ndrawBackground.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawBackground);\n\n\n//# sourceURL=webpack://steelseries/./src/drawBackground.js?");

/***/ }),

/***/ "./src/drawForeground.js":
/*!*******************************!*\
  !*** ./src/drawForeground.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createKnobImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createKnobImage */ \"./src/createKnobImage.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\n\nconst drawForeground = function (\n  ctx,\n  foregroundType,\n  imageWidth,\n  imageHeight,\n  withCenterKnob,\n  knob,\n  style,\n  gaugeType,\n  orientation\n) {\n  let radFgBuffer\n  let radFgCtx\n  const knobSize = Math.ceil(imageHeight * 0.084112)\n  let knobX = imageWidth * 0.5 - knobSize / 2\n  let knobY = imageHeight * 0.5 - knobSize / 2\n  const shadowOffset = imageWidth * 0.008\n  let gradHighlight\n  let gradHighlight2\n  const cacheKey =\n    foregroundType.type +\n    imageWidth +\n    imageHeight +\n    withCenterKnob +\n    (knob !== undefined ? knob.type : '-') +\n    (style !== undefined ? style.style : '-') +\n    (orientation !== undefined ? orientation.type : '-')\n\n  // check if we have already created and cached this buffer, if so return it and exit\n  if (!drawForeground.cache[cacheKey]) {\n    // Setup buffer\n    radFgBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_1__[\"createBuffer\"])(imageWidth, imageHeight)\n    radFgCtx = radFgBuffer.getContext('2d')\n\n    // center post\n    if (withCenterKnob) {\n      // Set the pointer shadow params\n      radFgCtx.shadowColor = 'rgba(0, 0, 0, 0.8)'\n      radFgCtx.shadowOffsetX = radFgCtx.shadowOffsetY = shadowOffset\n      radFgCtx.shadowBlur = shadowOffset * 2\n\n      if (gaugeType === _definitions__WEBPACK_IMPORTED_MODULE_2__[\"GaugeType\"].TYPE5) {\n        if (_definitions__WEBPACK_IMPORTED_MODULE_2__[\"Orientation\"].WEST === orientation) {\n          knobX = imageWidth * 0.733644 - knobSize / 2\n          radFgCtx.drawImage(\n            Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(knobSize, knob, style),\n            knobX,\n            knobY\n          )\n        } else if (_definitions__WEBPACK_IMPORTED_MODULE_2__[\"Orientation\"].EAST === orientation) {\n          knobX = imageWidth * (1 - 0.733644) - knobSize / 2\n          radFgCtx.drawImage(\n            Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(knobSize, knob, style),\n            knobX,\n            knobY\n          )\n        } else {\n          knobY = imageHeight * 0.733644 - knobSize / 2\n          radFgCtx.drawImage(\n            Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(knobSize, knob, style),\n            knobX,\n            imageHeight * 0.6857\n          )\n        }\n      } else {\n        radFgCtx.drawImage(\n          Object(_createKnobImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(knobSize, knob, style),\n          knobX,\n          knobY\n        )\n      }\n      // Undo shadow drawing\n      radFgCtx.shadowOffsetX = radFgCtx.shadowOffsetY = 0\n      radFgCtx.shadowBlur = 0\n    }\n\n    // highlight\n    switch (foregroundType.type) {\n      case 'type2':\n        radFgCtx.beginPath()\n        radFgCtx.moveTo(imageWidth * 0.135514, imageHeight * 0.696261)\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.214953,\n          imageHeight * 0.588785,\n          imageWidth * 0.317757,\n          imageHeight * 0.5,\n          imageWidth * 0.462616,\n          imageHeight * 0.425233\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.612149,\n          imageHeight * 0.345794,\n          imageWidth * 0.733644,\n          imageHeight * 0.317757,\n          imageWidth * 0.873831,\n          imageHeight * 0.322429\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.766355,\n          imageHeight * 0.112149,\n          imageWidth * 0.528037,\n          imageHeight * 0.023364,\n          imageWidth * 0.313084,\n          imageHeight * 0.130841\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.09813,\n          imageHeight * 0.238317,\n          imageWidth * 0.028037,\n          imageHeight * 0.485981,\n          imageWidth * 0.135514,\n          imageHeight * 0.696261\n        )\n        radFgCtx.closePath()\n        gradHighlight = radFgCtx.createLinearGradient(\n          0.313084 * imageWidth,\n          0.135514 * imageHeight,\n          0.495528 * imageWidth,\n          0.493582 * imageHeight\n        )\n        gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.275)')\n        gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.015)')\n        break\n\n      case 'type3':\n        radFgCtx.beginPath()\n        radFgCtx.moveTo(imageWidth * 0.084112, imageHeight * 0.509345)\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.21028,\n          imageHeight * 0.556074,\n          imageWidth * 0.462616,\n          imageHeight * 0.560747,\n          imageWidth * 0.5,\n          imageHeight * 0.560747\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.537383,\n          imageHeight * 0.560747,\n          imageWidth * 0.794392,\n          imageHeight * 0.560747,\n          imageWidth * 0.915887,\n          imageHeight * 0.509345\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.915887,\n          imageHeight * 0.2757,\n          imageWidth * 0.738317,\n          imageHeight * 0.084112,\n          imageWidth * 0.5,\n          imageHeight * 0.084112\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.261682,\n          imageHeight * 0.084112,\n          imageWidth * 0.084112,\n          imageHeight * 0.2757,\n          imageWidth * 0.084112,\n          imageHeight * 0.509345\n        )\n        radFgCtx.closePath()\n        gradHighlight = radFgCtx.createLinearGradient(\n          0,\n          0.093457 * imageHeight,\n          0,\n          0.556073 * imageHeight\n        )\n        gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.275)')\n        gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.015)')\n        break\n\n      case 'type4':\n        radFgCtx.beginPath()\n        radFgCtx.moveTo(imageWidth * 0.67757, imageHeight * 0.24299)\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.771028,\n          imageHeight * 0.308411,\n          imageWidth * 0.822429,\n          imageHeight * 0.411214,\n          imageWidth * 0.813084,\n          imageHeight * 0.528037\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.799065,\n          imageHeight * 0.654205,\n          imageWidth * 0.719626,\n          imageHeight * 0.757009,\n          imageWidth * 0.593457,\n          imageHeight * 0.799065\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.485981,\n          imageHeight * 0.831775,\n          imageWidth * 0.369158,\n          imageHeight * 0.808411,\n          imageWidth * 0.285046,\n          imageHeight * 0.728971\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.2757,\n          imageHeight * 0.719626,\n          imageWidth * 0.252336,\n          imageHeight * 0.714953,\n          imageWidth * 0.233644,\n          imageHeight * 0.728971\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.214953,\n          imageHeight * 0.747663,\n          imageWidth * 0.219626,\n          imageHeight * 0.771028,\n          imageWidth * 0.228971,\n          imageHeight * 0.7757\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.331775,\n          imageHeight * 0.878504,\n          imageWidth * 0.476635,\n          imageHeight * 0.915887,\n          imageWidth * 0.616822,\n          imageHeight * 0.869158\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.771028,\n          imageHeight * 0.822429,\n          imageWidth * 0.873831,\n          imageHeight * 0.691588,\n          imageWidth * 0.88785,\n          imageHeight * 0.53271\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.897196,\n          imageHeight * 0.38785,\n          imageWidth * 0.836448,\n          imageHeight * 0.257009,\n          imageWidth * 0.719626,\n          imageHeight * 0.182242\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.705607,\n          imageHeight * 0.172897,\n          imageWidth * 0.682242,\n          imageHeight * 0.163551,\n          imageWidth * 0.663551,\n          imageHeight * 0.186915\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.654205,\n          imageHeight * 0.205607,\n          imageWidth * 0.668224,\n          imageHeight * 0.238317,\n          imageWidth * 0.67757,\n          imageHeight * 0.24299\n        )\n        radFgCtx.closePath()\n        gradHighlight = radFgCtx.createRadialGradient(\n          0.5 * imageWidth,\n          0.5 * imageHeight,\n          0,\n          0.5 * imageWidth,\n          0.5 * imageHeight,\n          0.38785 * imageWidth\n        )\n        gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0)')\n        gradHighlight.addColorStop(0.82, 'rgba(255, 255, 255, 0)')\n        gradHighlight.addColorStop(0.83, 'rgba(255, 255, 255, 0)')\n        gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.15)')\n\n        radFgCtx.beginPath()\n        radFgCtx.moveTo(imageWidth * 0.261682, imageHeight * 0.224299)\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.285046,\n          imageHeight * 0.238317,\n          imageWidth * 0.252336,\n          imageHeight * 0.285046,\n          imageWidth * 0.24299,\n          imageHeight * 0.317757\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.24299,\n          imageHeight * 0.350467,\n          imageWidth * 0.271028,\n          imageHeight * 0.383177,\n          imageWidth * 0.271028,\n          imageHeight * 0.397196\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.2757,\n          imageHeight * 0.415887,\n          imageWidth * 0.261682,\n          imageHeight * 0.457943,\n          imageWidth * 0.238317,\n          imageHeight * 0.509345\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.224299,\n          imageHeight * 0.542056,\n          imageWidth * 0.17757,\n          imageHeight * 0.612149,\n          imageWidth * 0.158878,\n          imageHeight * 0.612149\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.144859,\n          imageHeight * 0.612149,\n          imageWidth * 0.088785,\n          imageHeight * 0.546728,\n          imageWidth * 0.130841,\n          imageHeight * 0.369158\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.140186,\n          imageHeight * 0.336448,\n          imageWidth * 0.214953,\n          imageHeight * 0.200934,\n          imageWidth * 0.261682,\n          imageHeight * 0.224299\n        )\n        radFgCtx.closePath()\n        gradHighlight2 = radFgCtx.createLinearGradient(\n          0.130841 * imageWidth,\n          0.369158 * imageHeight,\n          0.273839 * imageWidth,\n          0.412877 * imageHeight\n        )\n        gradHighlight2.addColorStop(0, 'rgba(255, 255, 255, 0.275)')\n        gradHighlight2.addColorStop(1, 'rgba(255, 255, 255, 0.015)')\n        radFgCtx.fillStyle = gradHighlight2\n        radFgCtx.fill()\n        break\n\n      case 'type5':\n        radFgCtx.beginPath()\n        radFgCtx.moveTo(imageWidth * 0.084112, imageHeight * 0.5)\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.084112,\n          imageHeight * 0.271028,\n          imageWidth * 0.271028,\n          imageHeight * 0.084112,\n          imageWidth * 0.5,\n          imageHeight * 0.084112\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.700934,\n          imageHeight * 0.084112,\n          imageWidth * 0.864485,\n          imageHeight * 0.224299,\n          imageWidth * 0.906542,\n          imageHeight * 0.411214\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.911214,\n          imageHeight * 0.439252,\n          imageWidth * 0.911214,\n          imageHeight * 0.518691,\n          imageWidth * 0.845794,\n          imageHeight * 0.537383\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.794392,\n          imageHeight * 0.546728,\n          imageWidth * 0.551401,\n          imageHeight * 0.411214,\n          imageWidth * 0.392523,\n          imageHeight * 0.457943\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.168224,\n          imageHeight * 0.509345,\n          imageWidth * 0.135514,\n          imageHeight * 0.7757,\n          imageWidth * 0.093457,\n          imageHeight * 0.593457\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.088785,\n          imageHeight * 0.560747,\n          imageWidth * 0.084112,\n          imageHeight * 0.53271,\n          imageWidth * 0.084112,\n          imageHeight * 0.5\n        )\n        radFgCtx.closePath()\n        gradHighlight = radFgCtx.createLinearGradient(\n          0,\n          0.084112 * imageHeight,\n          0,\n          0.644859 * imageHeight\n        )\n        gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.275)')\n        gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.015)')\n        break\n\n      case 'type1':\n      /* falls through */\n      default:\n        radFgCtx.beginPath()\n        radFgCtx.moveTo(imageWidth * 0.084112, imageHeight * 0.509345)\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.205607,\n          imageHeight * 0.448598,\n          imageWidth * 0.336448,\n          imageHeight * 0.415887,\n          imageWidth * 0.5,\n          imageHeight * 0.415887\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.672897,\n          imageHeight * 0.415887,\n          imageWidth * 0.789719,\n          imageHeight * 0.443925,\n          imageWidth * 0.915887,\n          imageHeight * 0.509345\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.915887,\n          imageHeight * 0.2757,\n          imageWidth * 0.738317,\n          imageHeight * 0.084112,\n          imageWidth * 0.5,\n          imageHeight * 0.084112\n        )\n        radFgCtx.bezierCurveTo(\n          imageWidth * 0.261682,\n          imageHeight * 0.084112,\n          imageWidth * 0.084112,\n          imageHeight * 0.2757,\n          imageWidth * 0.084112,\n          imageHeight * 0.509345\n        )\n        radFgCtx.closePath()\n        gradHighlight = radFgCtx.createLinearGradient(\n          0,\n          0.088785 * imageHeight,\n          0,\n          0.490654 * imageHeight\n        )\n        gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.275)')\n        gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.015)')\n        break\n    }\n    radFgCtx.fillStyle = gradHighlight\n    radFgCtx.fill()\n\n    // cache the buffer\n    drawForeground.cache[cacheKey] = radFgBuffer\n  }\n  ctx.drawImage(drawForeground.cache[cacheKey], 0, 0)\n  return this\n}\ndrawForeground.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawForeground);\n\n\n//# sourceURL=webpack://steelseries/./src/drawForeground.js?");

/***/ }),

/***/ "./src/drawFrame.js":
/*!**************************!*\
  !*** ./src/drawFrame.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst drawFrame = function (\n  ctx,\n  frameDesign,\n  centerX,\n  centerY,\n  imageWidth,\n  imageHeight\n) {\n  let radFBuffer\n  let radFCtx\n  let grad\n  let outerX\n  let innerX\n  let fractions\n  let colors\n  const cacheKey = imageWidth.toString() + imageHeight + frameDesign.design\n\n  // check if we have already created and cached this buffer, if not create it\n  if (!drawFrame.cache[cacheKey]) {\n    // Setup buffer\n    radFBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"createBuffer\"])(imageWidth, imageHeight)\n    radFCtx = radFBuffer.getContext('2d')\n\n    // outer gray frame\n    radFCtx.fillStyle = '#848484'\n    radFCtx.strokeStyle = 'rgba(132, 132, 132, 0.5)'\n    radFCtx.beginPath()\n    radFCtx.arc(centerX, centerY, imageWidth / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n    radFCtx.closePath()\n    radFCtx.fill()\n    radFCtx.stroke()\n\n    radFCtx.beginPath()\n    radFCtx.arc(centerX, centerY, (imageWidth * 0.990654) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n    radFCtx.closePath()\n\n    // main gradient frame\n    switch (frameDesign.design) {\n      case 'metal':\n        grad = radFCtx.createLinearGradient(\n          0,\n          imageWidth * 0.004672,\n          0,\n          imageHeight * 0.990654\n        )\n        grad.addColorStop(0, '#fefefe')\n        grad.addColorStop(0.07, 'rgb(210, 210, 210)')\n        grad.addColorStop(0.12, 'rgb(179, 179, 179)')\n        grad.addColorStop(1, 'rgb(213, 213, 213)')\n        radFCtx.fillStyle = grad\n        radFCtx.fill()\n        break\n\n      case 'brass':\n        grad = radFCtx.createLinearGradient(\n          0,\n          imageWidth * 0.004672,\n          0,\n          imageHeight * 0.990654\n        )\n        grad.addColorStop(0, 'rgb(249, 243, 155)')\n        grad.addColorStop(0.05, 'rgb(246, 226, 101)')\n        grad.addColorStop(0.1, 'rgb(240, 225, 132)')\n        grad.addColorStop(0.5, 'rgb(90, 57, 22)')\n        grad.addColorStop(0.9, 'rgb(249, 237, 139)')\n        grad.addColorStop(0.95, 'rgb(243, 226, 108)')\n        grad.addColorStop(1, 'rgb(202, 182, 113)')\n        radFCtx.fillStyle = grad\n        radFCtx.fill()\n        break\n\n      case 'steel':\n        grad = radFCtx.createLinearGradient(\n          0,\n          imageWidth * 0.004672,\n          0,\n          imageHeight * 0.990654\n        )\n        grad.addColorStop(0, 'rgb(231, 237, 237)')\n        grad.addColorStop(0.05, 'rgb(189, 199, 198)')\n        grad.addColorStop(0.1, 'rgb(192, 201, 200)')\n        grad.addColorStop(0.5, 'rgb(23, 31, 33)')\n        grad.addColorStop(0.9, 'rgb(196, 205, 204)')\n        grad.addColorStop(0.95, 'rgb(194, 204, 203)')\n        grad.addColorStop(1, 'rgb(189, 201, 199)')\n        radFCtx.fillStyle = grad\n        radFCtx.fill()\n        break\n\n      case 'gold':\n        grad = radFCtx.createLinearGradient(\n          0,\n          imageWidth * 0.004672,\n          0,\n          imageHeight * 0.990654\n        )\n        grad.addColorStop(0, 'rgb(255, 255, 207)')\n        grad.addColorStop(0.15, 'rgb(255, 237, 96)')\n        grad.addColorStop(0.22, 'rgb(254, 199, 57)')\n        grad.addColorStop(0.3, 'rgb(255, 249, 203)')\n        grad.addColorStop(0.38, 'rgb(255, 199, 64)')\n        grad.addColorStop(0.44, 'rgb(252, 194, 60)')\n        grad.addColorStop(0.51, 'rgb(255, 204, 59)')\n        grad.addColorStop(0.6, 'rgb(213, 134, 29)')\n        grad.addColorStop(0.68, 'rgb(255, 201, 56)')\n        grad.addColorStop(0.75, 'rgb(212, 135, 29)')\n        grad.addColorStop(1, 'rgb(247, 238, 101)')\n        radFCtx.fillStyle = grad\n        radFCtx.fill()\n        break\n\n      case 'anthracite':\n        grad = radFCtx.createLinearGradient(\n          0,\n          0.004672 * imageHeight,\n          0,\n          0.995326 * imageHeight\n        )\n        grad.addColorStop(0, 'rgb(118, 117, 135)')\n        grad.addColorStop(0.06, 'rgb(74, 74, 82)')\n        grad.addColorStop(0.12, 'rgb(50, 50, 54)')\n        grad.addColorStop(1, 'rgb(79, 79, 87)')\n        radFCtx.fillStyle = grad\n        radFCtx.fill()\n        break\n\n      case 'tiltedGray':\n        grad = radFCtx.createLinearGradient(\n          0.233644 * imageWidth,\n          0.084112 * imageHeight,\n          0.81258 * imageWidth,\n          0.910919 * imageHeight\n        )\n        grad.addColorStop(0, '#ffffff')\n        grad.addColorStop(0.07, 'rgb(210, 210, 210)')\n        grad.addColorStop(0.16, 'rgb(179, 179, 179)')\n        grad.addColorStop(0.33, '#ffffff')\n        grad.addColorStop(0.55, '#c5c5c5')\n        grad.addColorStop(0.79, '#ffffff')\n        grad.addColorStop(1, '#666666')\n        radFCtx.fillStyle = grad\n        radFCtx.fill()\n        break\n\n      case 'tiltedBlack':\n        grad = radFCtx.createLinearGradient(\n          0.228971 * imageWidth,\n          0.079439 * imageHeight,\n          0.802547 * imageWidth,\n          0.898591 * imageHeight\n        )\n        grad.addColorStop(0, '#666666')\n        grad.addColorStop(0.21, '#000000')\n        grad.addColorStop(0.47, '#666666')\n        grad.addColorStop(0.99, '#000000')\n        grad.addColorStop(1, '#000000')\n        radFCtx.fillStyle = grad\n        radFCtx.fill()\n        break\n\n      case 'glossyMetal':\n        grad = radFCtx.createRadialGradient(\n          0.5 * imageWidth,\n          0.5 * imageHeight,\n          0,\n          0.5 * imageWidth,\n          0.5 * imageWidth,\n          0.5 * imageWidth\n        )\n        grad.addColorStop(0, 'rgb(207, 207, 207)')\n        grad.addColorStop(0.96, 'rgb(205, 204, 205)')\n        grad.addColorStop(1, 'rgb(244, 244, 244)')\n        radFCtx.fillStyle = grad\n        radFCtx.fill()\n        radFCtx.beginPath()\n        radFCtx.arc(\n          0.5 * imageWidth,\n          0.5 * imageHeight,\n          (0.973962 * imageWidth) / 2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"]\n        )\n        radFCtx.closePath()\n        grad = radFCtx.createLinearGradient(\n          0,\n          imageHeight - 0.971962 * imageHeight,\n          0,\n          0.971962 * imageHeight\n        )\n        grad.addColorStop(0, 'rgb(249, 249, 249)')\n        grad.addColorStop(0.23, 'rgb(200, 195, 191)')\n        grad.addColorStop(0.36, '#ffffff')\n        grad.addColorStop(0.59, 'rgb(29, 29, 29)')\n        grad.addColorStop(0.76, 'rgb(200, 194, 192)')\n        grad.addColorStop(1, 'rgb(209, 209, 209)')\n        radFCtx.fillStyle = grad\n        radFCtx.fill()\n\n        radFCtx.beginPath()\n        radFCtx.arc(\n          0.5 * imageWidth,\n          0.5 * imageHeight,\n          (0.869158 * imageWidth) / 2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"]\n        )\n        radFCtx.closePath()\n        radFCtx.fillStyle = '#f6f6f6'\n        radFCtx.fill()\n\n        radFCtx.beginPath()\n        radFCtx.arc(\n          0.5 * imageWidth,\n          0.5 * imageHeight,\n          (0.85 * imageWidth) / 2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"]\n        )\n        radFCtx.closePath()\n        radFCtx.fillStyle = '#333333'\n        radFCtx.fill()\n        break\n\n      case 'blackMetal':\n        fractions = [0, 0.125, 0.347222, 0.5, 0.680555, 0.875, 1]\n\n        colors = [\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](254, 254, 254, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](153, 153, 153, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](153, 153, 153, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](0, 0, 0, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](254, 254, 254, 1)\n        ]\n\n        radFCtx.save()\n        radFCtx.arc(\n          centerX,\n          centerY,\n          (imageWidth * 0.990654) / 2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n          true\n        )\n        radFCtx.clip()\n        outerX = imageWidth * 0.495327\n        innerX = imageWidth * 0.42056\n        grad = new _tools__WEBPACK_IMPORTED_MODULE_0__[\"ConicalGradient\"](fractions, colors)\n        grad.fillCircle(radFCtx, centerX, centerY, innerX, outerX)\n        // fade outer edge\n        radFCtx.strokeStyle = '#848484'\n        radFCtx.strokeStyle = 'rgba(132, 132, 132, 0.8)'\n        radFCtx.beginPath()\n        radFCtx.lineWidth = imageWidth / 90\n        radFCtx.arc(centerX, centerY, imageWidth / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n        radFCtx.closePath()\n        radFCtx.stroke()\n        radFCtx.restore()\n        break\n\n      case 'shinyMetal':\n        fractions = [0, 0.125, 0.25, 0.347222, 0.5, 0.652777, 0.75, 0.875, 1]\n\n        colors = [\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](254, 254, 254, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](210, 210, 210, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](179, 179, 179, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](238, 238, 238, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](160, 160, 160, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](238, 238, 238, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](179, 179, 179, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](210, 210, 210, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](254, 254, 254, 1)\n        ]\n\n        radFCtx.save()\n        radFCtx.arc(\n          centerX,\n          centerY,\n          (imageWidth * 0.990654) / 2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n          true\n        )\n        radFCtx.clip()\n        outerX = imageWidth * 0.495327\n        innerX = imageWidth * 0.42056\n        grad = new _tools__WEBPACK_IMPORTED_MODULE_0__[\"ConicalGradient\"](fractions, colors)\n        grad.fillCircle(radFCtx, centerX, centerY, innerX, outerX)\n        // fade outer edge\n        radFCtx.strokeStyle = '#848484'\n        radFCtx.strokeStyle = 'rgba(132, 132, 132, 0.8)'\n        radFCtx.beginPath()\n        radFCtx.lineWidth = imageWidth / 90\n        radFCtx.arc(centerX, centerY, imageWidth / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n        radFCtx.closePath()\n        radFCtx.stroke()\n        radFCtx.restore()\n        break\n\n      case 'chrome':\n        fractions = [\n          0,\n          0.09,\n          0.12,\n          0.16,\n          0.25,\n          0.29,\n          0.33,\n          0.38,\n          0.48,\n          0.52,\n          0.63,\n          0.68,\n          0.8,\n          0.83,\n          0.87,\n          0.97,\n          1\n        ]\n\n        colors = [\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](136, 136, 138, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](164, 185, 190, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](158, 179, 182, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](112, 112, 112, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](221, 227, 227, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](155, 176, 179, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](156, 176, 177, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](254, 255, 255, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](156, 180, 180, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](198, 209, 211, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](246, 248, 247, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](204, 216, 216, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](164, 188, 190, 1),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"](255, 255, 255, 1)\n        ]\n\n        radFCtx.save()\n        radFCtx.arc(\n          centerX,\n          centerY,\n          (imageWidth * 0.990654) / 2,\n          0,\n          _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"],\n          true\n        )\n        radFCtx.clip()\n        outerX = imageWidth * 0.495327\n        innerX = imageWidth * 0.42056\n        grad = new _tools__WEBPACK_IMPORTED_MODULE_0__[\"ConicalGradient\"](fractions, colors)\n        grad.fillCircle(radFCtx, centerX, centerY, innerX, outerX)\n        // fade outer edge\n        radFCtx.strokeStyle = '#848484'\n        radFCtx.strokeStyle = 'rgba(132, 132, 132, 0.8)'\n        radFCtx.beginPath()\n        radFCtx.lineWidth = imageWidth / 90\n        radFCtx.arc(centerX, centerY, imageWidth / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n        radFCtx.closePath()\n        radFCtx.stroke()\n        radFCtx.restore()\n\n        break\n    }\n\n    // inner bright frame\n    radFCtx.fillStyle = 'rgb(191, 191, 191)'\n    radFCtx.beginPath()\n    radFCtx.arc(centerX, centerY, (imageWidth * 0.841121) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n    radFCtx.closePath()\n    radFCtx.fill()\n\n    // clip out center so it is transparent if the background is not visible\n    radFCtx.globalCompositeOperation = 'destination-out'\n    // Background ellipse\n    radFCtx.beginPath()\n    radFCtx.arc(centerX, centerY, (imageWidth * 0.83) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n    radFCtx.closePath()\n    radFCtx.fill()\n\n    // cache the buffer\n    drawFrame.cache[cacheKey] = radFBuffer\n  }\n  ctx.drawImage(drawFrame.cache[cacheKey], 0, 0)\n  return this\n}\ndrawFrame.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawFrame);\n\n\n//# sourceURL=webpack://steelseries/./src/drawFrame.js?");

/***/ }),

/***/ "./src/drawLinearBackgroundImage.js":
/*!******************************************!*\
  !*** ./src/drawLinearBackgroundImage.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _carbonBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carbonBuffer */ \"./src/carbonBuffer.js\");\n/* harmony import */ var _punchedSheetBuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./punchedSheetBuffer */ \"./src/punchedSheetBuffer.js\");\n/* harmony import */ var _brushedMetalTexture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./brushedMetalTexture */ \"./src/brushedMetalTexture.js\");\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\n\n\n\nconst drawLinearBackgroundImage = function (\n  ctx,\n  backgroundColor,\n  imageWidth,\n  imageHeight,\n  vertical\n) {\n  let i\n  let end\n  let grad\n  let fractions\n  let colors\n  let frameWidth\n  let linBBuffer\n  let linBCtx\n  let radius\n  let turnRadius\n  let centerX\n  let centerY\n  let stepSize\n  let mono\n  let textureColor\n  let texture\n  const cacheKey =\n    imageWidth.toString() + imageHeight + vertical + backgroundColor.name\n\n  // check if we have already created and cached this buffer, if not create it\n  if (!drawLinearBackgroundImage.cache[cacheKey]) {\n    frameWidth =\n      Math.sqrt(imageWidth * imageWidth + imageHeight * imageHeight) * 0.04\n    frameWidth =\n      Math.ceil(\n        Math.min(frameWidth, (vertical ? imageWidth : imageHeight) * 0.1)\n      ) - 1\n\n    const CORNER_RADIUS = Math.floor(\n      (vertical ? imageWidth : imageHeight) * 0.028571\n    )\n    // Setup buffer\n    linBBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"createBuffer\"])(imageWidth, imageHeight)\n    linBCtx = linBBuffer.getContext('2d')\n    linBCtx.lineWidth = 0\n\n    Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"roundedRectangle\"])(\n      linBCtx,\n      frameWidth,\n      frameWidth,\n      imageWidth - frameWidth * 2,\n      imageHeight - frameWidth * 2,\n      CORNER_RADIUS\n    )\n\n    // If the backgroundColor is a texture fill it with the texture instead of the gradient\n    if (\n      backgroundColor.name === 'CARBON' ||\n      backgroundColor.name === 'PUNCHED_SHEET' ||\n      backgroundColor.name === 'STAINLESS' ||\n      backgroundColor.name === 'BRUSHED_METAL' ||\n      backgroundColor.name === 'BRUSHED_STAINLESS' ||\n      backgroundColor.name === 'TURNED'\n    ) {\n      if (backgroundColor.name === 'CARBON') {\n        linBCtx.fillStyle = linBCtx.createPattern(_carbonBuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"], 'repeat')\n        linBCtx.fill()\n      }\n\n      if (backgroundColor.name === 'PUNCHED_SHEET') {\n        linBCtx.fillStyle = linBCtx.createPattern(_punchedSheetBuffer__WEBPACK_IMPORTED_MODULE_1__[\"default\"], 'repeat')\n        linBCtx.fill()\n      }\n\n      if (\n        backgroundColor.name === 'STAINLESS' ||\n        backgroundColor.name === 'TURNED'\n      ) {\n        // Define the fraction of the conical gradient paint\n        fractions = [\n          0,\n          0.03,\n          0.1,\n          0.14,\n          0.24,\n          0.33,\n          0.38,\n          0.5,\n          0.62,\n          0.67,\n          0.76,\n          0.81,\n          0.85,\n          0.97,\n          1\n        ]\n\n        // Define the colors of the conical gradient paint\n        colors = [\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#B2B2B4'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#ACACAE'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#8E8E8E'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#8E8E8E'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#8E8E8E'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#8E8E8E'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#ACACAE'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#B2B2B4'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD'),\n          new _tools__WEBPACK_IMPORTED_MODULE_3__[\"rgbaColor\"]('#FDFDFD')\n        ]\n        grad = new _tools__WEBPACK_IMPORTED_MODULE_3__[\"ConicalGradient\"](fractions, colors)\n        // Set a clip as we will be drawing outside the required area\n        linBCtx.clip()\n        grad.fillRect(\n          linBCtx,\n          imageWidth / 2,\n          imageHeight / 2,\n          imageWidth - frameWidth * 2,\n          imageHeight - frameWidth * 2,\n          imageWidth / 2,\n          imageHeight / 2\n        )\n        // Add an additional inner shadow to fade out brightness at the top\n        grad = linBCtx.createLinearGradient(\n          0,\n          frameWidth,\n          0,\n          imageHeight - frameWidth * 2\n        )\n        grad.addColorStop(0, 'rgba(0, 0, 0, 0.25)')\n        grad.addColorStop(0.1, 'rgba(0, 0, 0, 0.05)')\n        grad.addColorStop(1, 'rgba(0, 0, 0, 0)')\n        linBCtx.fillStyle = grad\n        linBCtx.fill()\n\n        if (backgroundColor.name === 'TURNED') {\n          // Define the turning radius\n          radius =\n            Math.sqrt(\n              (imageWidth - frameWidth * 2) * (imageWidth - frameWidth * 2) +\n                (imageHeight - frameWidth * 2) * (imageHeight - frameWidth * 2)\n            ) / 2\n          turnRadius = radius * 0.55\n          centerX = imageWidth / 2\n          centerY = imageHeight / 2\n          // Step size proporational to radius\n          stepSize = (_tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"] / 360) * (400 / radius)\n\n          // Save before we start\n          linBCtx.save()\n\n          // Set a clip as we will be drawing outside the required area\n          Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"roundedRectangle\"])(\n            linBCtx,\n            frameWidth,\n            frameWidth,\n            imageWidth - frameWidth * 2,\n            imageHeight - frameWidth * 2,\n            CORNER_RADIUS\n          )\n          linBCtx.clip()\n\n          // set the style for the turnings\n          linBCtx.lineWidth = 0.5\n          end = _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"] - stepSize * 0.3\n          // Step the engine round'n'round\n          for (i = 0; i < end; i += stepSize) {\n            // draw a 'turn'\n            linBCtx.strokeStyle = 'rgba(240, 240, 255, 0.25)'\n            linBCtx.beginPath()\n            linBCtx.arc(centerX + turnRadius, centerY, turnRadius, 0, _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"])\n            linBCtx.stroke()\n            // rotate the 'piece'\n            linBCtx.translate(centerX, centerY)\n            linBCtx.rotate(stepSize * 0.3)\n            linBCtx.translate(-centerX, -centerY)\n            // draw a 'turn'\n            linBCtx.strokeStyle = 'rgba(25, 10, 10, 0.1)'\n            linBCtx.beginPath()\n            linBCtx.arc(centerX + turnRadius, centerY, turnRadius, 0, _tools__WEBPACK_IMPORTED_MODULE_3__[\"TWO_PI\"])\n            linBCtx.stroke()\n            linBCtx.translate(centerX, centerY)\n            linBCtx.rotate(-stepSize * 0.3)\n            linBCtx.translate(-centerX, -centerY)\n\n            // rotate the 'piece'\n            linBCtx.translate(centerX, centerY)\n            linBCtx.rotate(stepSize)\n            linBCtx.translate(-centerX, -centerY)\n          }\n          // Restore canvas now we are done\n          linBCtx.restore()\n        }\n      }\n      // Add an additional inner shadow to make the look more realistic\n      grad = linBCtx.createLinearGradient(\n        frameWidth,\n        frameWidth,\n        imageWidth - frameWidth * 2,\n        imageHeight - frameWidth * 2\n      )\n      grad.addColorStop(0, 'rgba(0, 0, 0, 0.25)')\n      grad.addColorStop(0.5, 'rgba(0, 0, 0, 0)')\n      grad.addColorStop(1, 'rgba(0, 0, 0, 0.25)')\n      linBCtx.fillStyle = grad\n      Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"roundedRectangle\"])(\n        linBCtx,\n        frameWidth,\n        frameWidth,\n        imageWidth - frameWidth * 2,\n        imageHeight - frameWidth * 2,\n        CORNER_RADIUS\n      )\n      linBCtx.fill()\n\n      if (\n        backgroundColor.name === 'BRUSHED_METAL' ||\n        backgroundColor.name === 'BRUSHED_STAINLESS'\n      ) {\n        mono = backgroundColor.name === 'BRUSHED_METAL'\n        textureColor = parseInt(\n          backgroundColor.gradientStop.getHexColor().substr(-6),\n          16\n        )\n        texture = Object(_brushedMetalTexture__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(textureColor, 5, 0.1, mono, 0.5)\n        linBCtx.fillStyle = linBCtx.createPattern(\n          texture.fill(0, 0, imageWidth, imageHeight),\n          'no-repeat'\n        )\n        linBCtx.fill()\n      }\n    } else {\n      grad = linBCtx.createLinearGradient(\n        0,\n        frameWidth,\n        0,\n        imageHeight - frameWidth * 2\n      )\n      grad.addColorStop(0, backgroundColor.gradientStart.getRgbaColor())\n      grad.addColorStop(0.4, backgroundColor.gradientFraction.getRgbaColor())\n      grad.addColorStop(1, backgroundColor.gradientStop.getRgbaColor())\n      linBCtx.fillStyle = grad\n      linBCtx.fill()\n    }\n    // Add a simple inner shadow\n    colors = [\n      'rgba(0, 0, 0, 0.30)',\n      'rgba(0, 0, 0, 0.20)',\n      'rgba(0, 0, 0, 0.13)',\n      'rgba(0, 0, 0, 0.09)',\n      'rgba(0, 0, 0, 0.06)',\n      'rgba(0, 0, 0, 0.04)',\n      'rgba(0, 0, 0, 0.03)'\n    ]\n    for (i = 0; i < 7; i++) {\n      linBCtx.strokeStyle = colors[i]\n      Object(_tools__WEBPACK_IMPORTED_MODULE_3__[\"roundedRectangle\"])(\n        linBCtx,\n        frameWidth + i,\n        frameWidth + i,\n        imageWidth - frameWidth * 2 - 2 * i,\n        imageHeight - frameWidth * 2 - 2 * i,\n        CORNER_RADIUS\n      )\n      linBCtx.stroke()\n    }\n    // cache the buffer\n    drawLinearBackgroundImage.cache[cacheKey] = linBBuffer\n  }\n  ctx.drawImage(drawLinearBackgroundImage.cache[cacheKey], 0, 0)\n  return this\n}\ndrawLinearBackgroundImage.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawLinearBackgroundImage);\n\n\n//# sourceURL=webpack://steelseries/./src/drawLinearBackgroundImage.js?");

/***/ }),

/***/ "./src/drawLinearForegroundImage.js":
/*!******************************************!*\
  !*** ./src/drawLinearForegroundImage.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst drawLinearForegroundImage = function (\n  ctx,\n  imageWidth,\n  imageHeight,\n  vertical\n) {\n  let linFgBuffer\n  let linFgCtx\n  let foregroundGradient\n  let frameWidth\n  let fgOffset\n  let fgOffset2\n  const cacheKey = imageWidth.toString() + imageHeight + vertical\n\n  // check if we have already created and cached this buffer, if not create it\n  if (!drawLinearForegroundImage.cache[cacheKey]) {\n    // Setup buffer\n    linFgBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"createBuffer\"])(imageWidth, imageHeight)\n    linFgCtx = linFgBuffer.getContext('2d')\n\n    frameWidth =\n      Math.sqrt(imageWidth * imageWidth + imageHeight * imageHeight) * 0.04\n    frameWidth = Math.min(\n      frameWidth,\n      (vertical ? imageWidth : imageHeight) * 0.1\n    )\n    fgOffset = frameWidth * 1.3\n    fgOffset2 = fgOffset * 1.33\n\n    linFgCtx.beginPath()\n    linFgCtx.moveTo(fgOffset, imageHeight - fgOffset)\n    linFgCtx.lineTo(imageWidth - fgOffset, imageHeight - fgOffset)\n    linFgCtx.bezierCurveTo(\n      imageWidth - fgOffset,\n      imageHeight - fgOffset,\n      imageWidth - fgOffset2,\n      imageHeight * 0.7,\n      imageWidth - fgOffset2,\n      imageHeight * 0.5\n    )\n    linFgCtx.bezierCurveTo(\n      imageWidth - fgOffset2,\n      fgOffset2,\n      imageWidth - fgOffset,\n      fgOffset,\n      imageWidth - frameWidth,\n      fgOffset\n    )\n    linFgCtx.lineTo(fgOffset, fgOffset)\n    linFgCtx.bezierCurveTo(\n      fgOffset,\n      fgOffset,\n      fgOffset2,\n      imageHeight * 0.285714,\n      fgOffset2,\n      imageHeight * 0.5\n    )\n    linFgCtx.bezierCurveTo(\n      fgOffset2,\n      imageHeight * 0.7,\n      fgOffset,\n      imageHeight - fgOffset,\n      frameWidth,\n      imageHeight - fgOffset\n    )\n    linFgCtx.closePath()\n\n    foregroundGradient = linFgCtx.createLinearGradient(\n      0,\n      imageHeight - frameWidth,\n      0,\n      frameWidth\n    )\n    foregroundGradient.addColorStop(0, 'rgba(255, 255, 255, 0)')\n    foregroundGradient.addColorStop(0.06, 'rgba(255, 255, 255, 0)')\n    foregroundGradient.addColorStop(0.07, 'rgba(255, 255, 255, 0)')\n    foregroundGradient.addColorStop(0.12, 'rgba(255, 255, 255, 0)')\n    foregroundGradient.addColorStop(0.17, 'rgba(255, 255, 255, 0.013546)')\n    foregroundGradient.addColorStop(0.1701, 'rgba(255, 255, 255, 0)')\n    foregroundGradient.addColorStop(0.79, 'rgba(255, 255, 255, 0)')\n    foregroundGradient.addColorStop(0.8, 'rgba(255, 255, 255, 0)')\n    foregroundGradient.addColorStop(0.84, 'rgba(255, 255, 255, 0.082217)')\n    foregroundGradient.addColorStop(0.93, 'rgba(255, 255, 255, 0.288702)')\n    foregroundGradient.addColorStop(0.94, 'rgba(255, 255, 255, 0.298039)')\n    foregroundGradient.addColorStop(0.96, 'rgba(255, 255, 255, 0.119213)')\n    foregroundGradient.addColorStop(0.97, 'rgba(255, 255, 255, 0)')\n    foregroundGradient.addColorStop(1, 'rgba(255, 255, 255, 0)')\n    linFgCtx.fillStyle = foregroundGradient\n    linFgCtx.fill()\n\n    // cache the buffer\n    drawLinearForegroundImage.cache[cacheKey] = linFgBuffer\n  }\n  ctx.drawImage(drawLinearForegroundImage.cache[cacheKey], 0, 0)\n  return this\n}\ndrawLinearForegroundImage.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawLinearForegroundImage);\n\n\n//# sourceURL=webpack://steelseries/./src/drawLinearForegroundImage.js?");

/***/ }),

/***/ "./src/drawLinearFrameImage.js":
/*!*************************************!*\
  !*** ./src/drawLinearFrameImage.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst drawLinearFrameImage = function (\n  ctx,\n  frameDesign,\n  imageWidth,\n  imageHeight,\n  vertical\n) {\n  let frameWidth\n  let linFBuffer\n  let linFCtx\n  let OUTER_FRAME_CORNER_RADIUS\n  let FRAME_MAIN_CORNER_RADIUS\n  let SUBTRACT_CORNER_RADIUS\n  let grad\n  let fractions = []\n  let colors = []\n  const cacheKey =\n    imageWidth.toString() + imageHeight + frameDesign.design + vertical\n\n  // check if we have already created and cached this buffer, if not create it\n  if (!drawLinearFrameImage.cache[cacheKey]) {\n    frameWidth =\n      Math.sqrt(imageWidth * imageWidth + imageHeight * imageHeight) * 0.04\n    frameWidth = Math.ceil(\n      Math.min(frameWidth, (vertical ? imageWidth : imageHeight) * 0.1)\n    )\n\n    // Setup buffer\n    linFBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"createBuffer\"])(imageWidth, imageHeight)\n    linFCtx = linFBuffer.getContext('2d')\n\n    // Calculate corner radii\n    if (vertical) {\n      OUTER_FRAME_CORNER_RADIUS = Math.ceil(imageWidth * 0.05)\n      FRAME_MAIN_CORNER_RADIUS = OUTER_FRAME_CORNER_RADIUS - 1\n      SUBTRACT_CORNER_RADIUS = Math.floor(imageWidth * 0.028571)\n    } else {\n      OUTER_FRAME_CORNER_RADIUS = Math.ceil(imageHeight * 0.05)\n      FRAME_MAIN_CORNER_RADIUS = OUTER_FRAME_CORNER_RADIUS - 1\n      SUBTRACT_CORNER_RADIUS = Math.floor(imageHeight * 0.028571)\n    }\n\n    Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n      linFCtx,\n      0,\n      0,\n      imageWidth,\n      imageHeight,\n      OUTER_FRAME_CORNER_RADIUS\n    )\n    linFCtx.fillStyle = '#838383'\n    linFCtx.fill()\n\n    Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n      linFCtx,\n      1,\n      1,\n      imageWidth - 2,\n      imageHeight - 2,\n      FRAME_MAIN_CORNER_RADIUS\n    )\n\n    // main gradient frame\n    switch (frameDesign.design) {\n      case 'metal':\n        grad = linFCtx.createLinearGradient(\n          0,\n          imageWidth * 0.004672,\n          0,\n          imageHeight * 0.990654\n        )\n        grad.addColorStop(0, '#fefefe')\n        grad.addColorStop(0.07, 'rgb(210, 210, 210)')\n        grad.addColorStop(0.12, 'rgb(179, 179, 179)')\n        grad.addColorStop(1, 'rgb(213, 213, 213)')\n        linFCtx.fillStyle = grad\n        linFCtx.fill()\n        break\n\n      case 'brass':\n        grad = linFCtx.createLinearGradient(\n          0,\n          imageWidth * 0.004672,\n          0,\n          imageHeight * 0.990654\n        )\n        grad.addColorStop(0, 'rgb(249, 243, 155)')\n        grad.addColorStop(0.05, 'rgb(246, 226, 101)')\n        grad.addColorStop(0.1, 'rgb(240, 225, 132)')\n        grad.addColorStop(0.5, 'rgb(90, 57, 22)')\n        grad.addColorStop(0.9, 'rgb(249, 237, 139)')\n        grad.addColorStop(0.95, 'rgb(243, 226, 108)')\n        grad.addColorStop(1, 'rgb(202, 182, 113)')\n        linFCtx.fillStyle = grad\n        linFCtx.fill()\n        break\n\n      case 'steel':\n        grad = linFCtx.createLinearGradient(\n          0,\n          imageWidth * 0.004672,\n          0,\n          imageHeight * 0.990654\n        )\n        grad.addColorStop(0, 'rgb(231, 237, 237)')\n        grad.addColorStop(0.05, 'rgb(189, 199, 198)')\n        grad.addColorStop(0.1, 'rgb(192, 201, 200)')\n        grad.addColorStop(0.5, 'rgb(23, 31, 33)')\n        grad.addColorStop(0.9, 'rgb(196, 205, 204)')\n        grad.addColorStop(0.95, 'rgb(194, 204, 203)')\n        grad.addColorStop(1, 'rgb(189, 201, 199)')\n        linFCtx.fillStyle = grad\n        linFCtx.fill()\n        break\n\n      case 'gold':\n        grad = linFCtx.createLinearGradient(\n          0,\n          imageWidth * 0.004672,\n          0,\n          imageHeight * 0.990654\n        )\n        grad.addColorStop(0, 'rgb(255, 255, 207)')\n        grad.addColorStop(0.15, 'rgb(255, 237, 96)')\n        grad.addColorStop(0.22, 'rgb(254, 199, 57)')\n        grad.addColorStop(0.3, 'rgb(255, 249, 203)')\n        grad.addColorStop(0.38, 'rgb(255, 199, 64)')\n        grad.addColorStop(0.44, 'rgb(252, 194, 60)')\n        grad.addColorStop(0.51, 'rgb(255, 204, 59)')\n        grad.addColorStop(0.6, 'rgb(213, 134, 29)')\n        grad.addColorStop(0.68, 'rgb(255, 201, 56)')\n        grad.addColorStop(0.75, 'rgb(212, 135, 29)')\n        grad.addColorStop(1, 'rgb(247, 238, 101)')\n        linFCtx.fillStyle = grad\n        linFCtx.fill()\n        break\n\n      case 'anthracite':\n        grad = linFCtx.createLinearGradient(\n          0,\n          0.004672 * imageHeight,\n          0,\n          0.995326 * imageHeight\n        )\n        grad.addColorStop(0, 'rgb(118, 117, 135)')\n        grad.addColorStop(0.06, 'rgb(74, 74, 82)')\n        grad.addColorStop(0.12, 'rgb(50, 50, 54)')\n        grad.addColorStop(1, 'rgb(79, 79, 87)')\n        linFCtx.fillStyle = grad\n        linFCtx.fill()\n        break\n\n      case 'tiltedGray':\n        grad = linFCtx.createLinearGradient(\n          0.233644 * imageWidth,\n          0.084112 * imageHeight,\n          0.81258 * imageWidth,\n          0.910919 * imageHeight\n        )\n        grad.addColorStop(0, '#ffffff')\n        grad.addColorStop(0.07, 'rgb(210, 210, 210)')\n        grad.addColorStop(0.16, 'rgb(179, 179, 179)')\n        grad.addColorStop(0.33, '#ffffff')\n        grad.addColorStop(0.55, '#c5c5c5')\n        grad.addColorStop(0.79, '#ffffff')\n        grad.addColorStop(1, '#666666')\n        linFCtx.fillStyle = grad\n        linFCtx.fill()\n        break\n\n      case 'tiltedBlack':\n        grad = linFCtx.createLinearGradient(\n          0.228971 * imageWidth,\n          0.079439 * imageHeight,\n          0.802547 * imageWidth,\n          0.898591 * imageHeight\n        )\n        grad.addColorStop(0, '#666666')\n        grad.addColorStop(0.21, '#000000')\n        grad.addColorStop(0.47, '#666666')\n        grad.addColorStop(0.99, '#000000')\n        grad.addColorStop(1, '#000000')\n        linFCtx.fillStyle = grad\n        linFCtx.fill()\n        break\n\n      case 'glossyMetal':\n        Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n          linFCtx,\n          1,\n          1,\n          imageWidth - 2,\n          imageHeight - 2,\n          OUTER_FRAME_CORNER_RADIUS\n        )\n        linFCtx.clip()\n        grad = linFCtx.createLinearGradient(0, 1, 0, imageHeight - 2)\n        // The fractions from the Java version of linear gauge\n        /*\n                    grad.addColorStop(0, 'rgb(249, 249, 249)');\n                    grad.addColorStop(0.1, 'rgb(200, 195, 191)');\n                    grad.addColorStop(0.26, '#ffffff');\n                    grad.addColorStop(0.73, 'rgb(29, 29, 29)');\n                    grad.addColorStop(1, 'rgb(209, 209, 209)');\n        */\n        // Modified fractions from the radial gauge - looks better imho\n        grad.addColorStop(0, 'rgb(249, 249, 249)')\n        grad.addColorStop(0.2, 'rgb(200, 195, 191)')\n        grad.addColorStop(0.3, '#ffffff')\n        grad.addColorStop(0.6, 'rgb(29, 29, 29)')\n        grad.addColorStop(0.8, 'rgb(200, 194, 192)')\n        grad.addColorStop(1, 'rgb(209, 209, 209)')\n        linFCtx.fillStyle = grad\n        linFCtx.fill()\n\n        // Inner frame bright\n        Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n          linFCtx,\n          frameWidth - 2,\n          frameWidth - 2,\n          imageWidth - (frameWidth - 2) * 2,\n          imageHeight - (frameWidth - 2) * 2,\n          SUBTRACT_CORNER_RADIUS\n        )\n        linFCtx.clip()\n        linFCtx.fillStyle = '#f6f6f6'\n        linFCtx.fill()\n\n        // Inner frame dark\n        Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n          linFCtx,\n          frameWidth - 1,\n          frameWidth - 1,\n          imageWidth - (frameWidth - 1) * 2,\n          imageHeight - (frameWidth - 1) * 2,\n          SUBTRACT_CORNER_RADIUS\n        )\n        linFCtx.clip()\n        linFCtx.fillStyle = '#333333'\n        //                linFCtx.fill();\n        break\n\n      case 'blackMetal':\n        fractions = [0, 0.125, 0.347222, 0.5, 0.680555, 0.875, 1]\n\n        colors = [\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#FFFFFF'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#000000'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#999999'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#000000'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#999999'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#000000'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#FFFFFF')\n        ]\n        // Set the clip\n        linFCtx.beginPath()\n        Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n          linFCtx,\n          1,\n          1,\n          imageWidth - 2,\n          imageHeight - 2,\n          OUTER_FRAME_CORNER_RADIUS\n        )\n        linFCtx.closePath()\n        linFCtx.clip()\n        grad = new _tools__WEBPACK_IMPORTED_MODULE_0__[\"ConicalGradient\"](fractions, colors)\n        grad.fillRect(\n          linFCtx,\n          imageWidth / 2,\n          imageHeight / 2,\n          imageWidth,\n          imageHeight,\n          frameWidth,\n          frameWidth\n        )\n        break\n\n      case 'shinyMetal':\n        fractions = [0, 0.125, 0.25, 0.347222, 0.5, 0.652777, 0.75, 0.875, 1]\n\n        colors = [\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#FFFFFF'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#D2D2D2'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#B3B3B3'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#EEEEEE'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#A0A0A0'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#EEEEEE'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#B3B3B3'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#D2D2D2'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#FFFFFF')\n        ]\n        // Set the clip\n        linFCtx.beginPath()\n        Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n          linFCtx,\n          1,\n          1,\n          imageWidth - 2,\n          imageHeight - 2,\n          OUTER_FRAME_CORNER_RADIUS\n        )\n        linFCtx.closePath()\n        linFCtx.clip()\n        grad = new _tools__WEBPACK_IMPORTED_MODULE_0__[\"ConicalGradient\"](fractions, colors)\n        grad.fillRect(\n          linFCtx,\n          imageWidth / 2,\n          imageHeight / 2,\n          imageWidth,\n          imageHeight,\n          frameWidth,\n          frameWidth\n        )\n        break\n\n      case 'chrome':\n        fractions = [\n          0,\n          0.09,\n          0.12,\n          0.16,\n          0.25,\n          0.29,\n          0.33,\n          0.38,\n          0.48,\n          0.52,\n          0.63,\n          0.68,\n          0.8,\n          0.83,\n          0.87,\n          0.97,\n          1\n        ]\n\n        colors = [\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#FFFFFF'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#FFFFFF'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#888890'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#A4B9BE'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#9EB3B6'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#707070'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#DDE3E3'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#9BB0B3'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#9CB0B1'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#FEFFFF'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#FFFFFF'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#9CB4B4'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#C6D1D3'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#F6F8F7'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#CCD8D8'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#A4BCBE'),\n          new _tools__WEBPACK_IMPORTED_MODULE_0__[\"rgbaColor\"]('#FFFFFF')\n        ]\n        // Set the clip\n        linFCtx.beginPath()\n        Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n          linFCtx,\n          1,\n          1,\n          imageWidth - 2,\n          imageHeight - 2,\n          OUTER_FRAME_CORNER_RADIUS\n        )\n        linFCtx.closePath()\n        linFCtx.clip()\n        grad = new _tools__WEBPACK_IMPORTED_MODULE_0__[\"ConicalGradient\"](fractions, colors)\n        grad.fillRect(\n          linFCtx,\n          imageWidth / 2,\n          imageHeight / 2,\n          imageWidth,\n          imageHeight,\n          frameWidth,\n          frameWidth\n        )\n        break\n    }\n\n    Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n      linFCtx,\n      frameWidth,\n      frameWidth,\n      imageWidth - frameWidth * 2,\n      imageHeight - frameWidth * 2,\n      SUBTRACT_CORNER_RADIUS\n    )\n    linFCtx.fillStyle = 'rgb(192, 192, 192)'\n\n    // clip out the center of the frame for transparent backgrounds\n    linFCtx.globalCompositeOperation = 'destination-out'\n    Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"roundedRectangle\"])(\n      linFCtx,\n      frameWidth,\n      frameWidth,\n      imageWidth - frameWidth * 2,\n      imageHeight - frameWidth * 2,\n      SUBTRACT_CORNER_RADIUS\n    )\n    linFCtx.fill()\n\n    // cache the buffer\n    drawLinearFrameImage.cache[cacheKey] = linFBuffer\n  }\n  ctx.drawImage(drawLinearFrameImage.cache[cacheKey], 0, 0)\n  return this\n}\ndrawLinearFrameImage.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawLinearFrameImage);\n\n\n//# sourceURL=webpack://steelseries/./src/drawLinearFrameImage.js?");

/***/ }),

/***/ "./src/drawPointerImage.js":
/*!*********************************!*\
  !*** ./src/drawPointerImage.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst drawPointerImage = function (ctx, size, ptrType, ptrColor, lblColor) {\n  let ptrBuffer\n  let ptrCtx\n  let grad\n  let radius\n  const cacheKey =\n    size.toString() +\n    ptrType.type +\n    ptrColor.light.getHexColor() +\n    ptrColor.medium.getHexColor()\n\n  // check if we have already created and cached this buffer, if not create it\n  if (!drawPointerImage.cache[cacheKey]) {\n    // create a pointer buffer\n    ptrBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"createBuffer\"])(size, size)\n    ptrCtx = ptrBuffer.getContext('2d')\n\n    switch (ptrType.type) {\n      case 'type2':\n        grad = ptrCtx.createLinearGradient(\n          0,\n          size * 0.471962,\n          0,\n          size * 0.130841\n        )\n        grad.addColorStop(0, lblColor.getRgbaColor())\n        grad.addColorStop(0.36, lblColor.getRgbaColor())\n        grad.addColorStop(0.361, ptrColor.light.getRgbaColor())\n        grad.addColorStop(1, ptrColor.light.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.518691, size * 0.471962)\n        ptrCtx.lineTo(size * 0.509345, size * 0.462616)\n        ptrCtx.lineTo(size * 0.509345, size * 0.341121)\n        ptrCtx.lineTo(size * 0.504672, size * 0.130841)\n        ptrCtx.lineTo(size * 0.495327, size * 0.130841)\n        ptrCtx.lineTo(size * 0.490654, size * 0.341121)\n        ptrCtx.lineTo(size * 0.490654, size * 0.462616)\n        ptrCtx.lineTo(size * 0.481308, size * 0.471962)\n        ptrCtx.closePath()\n        ptrCtx.fill()\n        break\n\n      case 'type3':\n        ptrCtx.beginPath()\n        ptrCtx.rect(\n          size * 0.495327,\n          size * 0.130841,\n          size * 0.009345,\n          size * 0.373831\n        )\n        ptrCtx.closePath()\n        ptrCtx.fillStyle = ptrColor.light.getRgbaColor()\n        ptrCtx.fill()\n        break\n\n      case 'type4':\n        grad = ptrCtx.createLinearGradient(\n          0.467289 * size,\n          0,\n          0.528036 * size,\n          0\n        )\n        grad.addColorStop(0, ptrColor.dark.getRgbaColor())\n        grad.addColorStop(0.51, ptrColor.dark.getRgbaColor())\n        grad.addColorStop(0.52, ptrColor.light.getRgbaColor())\n        grad.addColorStop(1, ptrColor.light.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.5, size * 0.126168)\n        ptrCtx.lineTo(size * 0.514018, size * 0.135514)\n        ptrCtx.lineTo(size * 0.53271, size * 0.5)\n        ptrCtx.lineTo(size * 0.523364, size * 0.602803)\n        ptrCtx.lineTo(size * 0.476635, size * 0.602803)\n        ptrCtx.lineTo(size * 0.467289, size * 0.5)\n        ptrCtx.lineTo(size * 0.485981, size * 0.135514)\n        ptrCtx.lineTo(size * 0.5, size * 0.126168)\n        ptrCtx.closePath()\n        ptrCtx.fill()\n        break\n\n      case 'type5':\n        grad = ptrCtx.createLinearGradient(\n          0.471962 * size,\n          0,\n          0.528036 * size,\n          0\n        )\n        grad.addColorStop(0, ptrColor.light.getRgbaColor())\n        grad.addColorStop(0.5, ptrColor.light.getRgbaColor())\n        grad.addColorStop(0.5, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(1, ptrColor.medium.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.5, size * 0.495327)\n        ptrCtx.lineTo(size * 0.528037, size * 0.495327)\n        ptrCtx.lineTo(size * 0.5, size * 0.149532)\n        ptrCtx.lineTo(size * 0.471962, size * 0.495327)\n        ptrCtx.lineTo(size * 0.5, size * 0.495327)\n        ptrCtx.closePath()\n        ptrCtx.fill()\n\n        ptrCtx.lineWidth = 1\n        ptrCtx.lineCap = 'square'\n        ptrCtx.lineJoin = 'miter'\n        ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor()\n        ptrCtx.stroke()\n        break\n\n      case 'type6':\n        ptrCtx.fillStyle = ptrColor.medium.getRgbaColor()\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.481308, size * 0.485981)\n        ptrCtx.lineTo(size * 0.481308, size * 0.392523)\n        ptrCtx.lineTo(size * 0.485981, size * 0.317757)\n        ptrCtx.lineTo(size * 0.495327, size * 0.130841)\n        ptrCtx.lineTo(size * 0.504672, size * 0.130841)\n        ptrCtx.lineTo(size * 0.514018, size * 0.317757)\n        ptrCtx.lineTo(size * 0.518691, size * 0.38785)\n        ptrCtx.lineTo(size * 0.518691, size * 0.485981)\n        ptrCtx.lineTo(size * 0.504672, size * 0.485981)\n        ptrCtx.lineTo(size * 0.504672, size * 0.38785)\n        ptrCtx.lineTo(size * 0.5, size * 0.317757)\n        ptrCtx.lineTo(size * 0.495327, size * 0.392523)\n        ptrCtx.lineTo(size * 0.495327, size * 0.485981)\n        ptrCtx.lineTo(size * 0.481308, size * 0.485981)\n        ptrCtx.closePath()\n        ptrCtx.fill()\n        break\n\n      case 'type7':\n        grad = ptrCtx.createLinearGradient(\n          0.481308 * size,\n          0,\n          0.518691 * size,\n          0\n        )\n        grad.addColorStop(0, ptrColor.dark.getRgbaColor())\n        grad.addColorStop(1, ptrColor.medium.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.490654, size * 0.130841)\n        ptrCtx.lineTo(size * 0.481308, size * 0.5)\n        ptrCtx.lineTo(size * 0.518691, size * 0.5)\n        ptrCtx.lineTo(size * 0.504672, size * 0.130841)\n        ptrCtx.lineTo(size * 0.490654, size * 0.130841)\n        ptrCtx.closePath()\n        ptrCtx.fill()\n        break\n\n      case 'type8':\n        grad = ptrCtx.createLinearGradient(\n          0.471962 * size,\n          0,\n          0.528036 * size,\n          0\n        )\n        grad.addColorStop(0, ptrColor.light.getRgbaColor())\n        grad.addColorStop(0.5, ptrColor.light.getRgbaColor())\n        grad.addColorStop(0.5, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(1, ptrColor.medium.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor()\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.5, size * 0.53271)\n        ptrCtx.lineTo(size * 0.53271, size * 0.5)\n        ptrCtx.bezierCurveTo(\n          size * 0.53271,\n          size * 0.5,\n          size * 0.509345,\n          size * 0.457943,\n          size * 0.5,\n          size * 0.149532\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.490654,\n          size * 0.457943,\n          size * 0.467289,\n          size * 0.5,\n          size * 0.467289,\n          size * 0.5\n        )\n        ptrCtx.lineTo(size * 0.5, size * 0.53271)\n        ptrCtx.closePath()\n        ptrCtx.fill()\n        ptrCtx.stroke()\n        break\n\n      case 'type9':\n        grad = ptrCtx.createLinearGradient(\n          0.471962 * size,\n          0,\n          0.528036 * size,\n          0\n        )\n        grad.addColorStop(0, 'rgb(50, 50, 50)')\n        grad.addColorStop(0.5, '#666666')\n        grad.addColorStop(1, 'rgb(50, 50, 50)')\n        ptrCtx.fillStyle = grad\n        ptrCtx.strokeStyle = '#2E2E2E'\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.495327, size * 0.233644)\n        ptrCtx.lineTo(size * 0.504672, size * 0.233644)\n        ptrCtx.lineTo(size * 0.514018, size * 0.439252)\n        ptrCtx.lineTo(size * 0.485981, size * 0.439252)\n        ptrCtx.lineTo(size * 0.495327, size * 0.233644)\n        ptrCtx.closePath()\n        ptrCtx.moveTo(size * 0.490654, size * 0.130841)\n        ptrCtx.lineTo(size * 0.471962, size * 0.471962)\n        ptrCtx.lineTo(size * 0.471962, size * 0.528037)\n        ptrCtx.bezierCurveTo(\n          size * 0.471962,\n          size * 0.528037,\n          size * 0.476635,\n          size * 0.602803,\n          size * 0.476635,\n          size * 0.602803\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.476635,\n          size * 0.607476,\n          size * 0.481308,\n          size * 0.607476,\n          size * 0.5,\n          size * 0.607476\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.518691,\n          size * 0.607476,\n          size * 0.523364,\n          size * 0.607476,\n          size * 0.523364,\n          size * 0.602803\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.523364,\n          size * 0.602803,\n          size * 0.528037,\n          size * 0.528037,\n          size * 0.528037,\n          size * 0.528037\n        )\n        ptrCtx.lineTo(size * 0.528037, size * 0.471962)\n        ptrCtx.lineTo(size * 0.509345, size * 0.130841)\n        ptrCtx.lineTo(size * 0.490654, size * 0.130841)\n        ptrCtx.closePath()\n        ptrCtx.fill()\n\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.495327, size * 0.219626)\n        ptrCtx.lineTo(size * 0.504672, size * 0.219626)\n        ptrCtx.lineTo(size * 0.504672, size * 0.135514)\n        ptrCtx.lineTo(size * 0.495327, size * 0.135514)\n        ptrCtx.lineTo(size * 0.495327, size * 0.219626)\n        ptrCtx.closePath()\n\n        ptrCtx.fillStyle = ptrColor.medium.getRgbaColor()\n        ptrCtx.fill()\n        break\n\n      case 'type10':\n        // POINTER_TYPE10\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.5, size * 0.149532)\n        ptrCtx.bezierCurveTo(\n          size * 0.5,\n          size * 0.149532,\n          size * 0.443925,\n          size * 0.490654,\n          size * 0.443925,\n          size * 0.5\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.443925,\n          size * 0.53271,\n          size * 0.467289,\n          size * 0.556074,\n          size * 0.5,\n          size * 0.556074\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.53271,\n          size * 0.556074,\n          size * 0.556074,\n          size * 0.53271,\n          size * 0.556074,\n          size * 0.5\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.556074,\n          size * 0.490654,\n          size * 0.5,\n          size * 0.149532,\n          size * 0.5,\n          size * 0.149532\n        )\n        ptrCtx.closePath()\n        grad = ptrCtx.createLinearGradient(\n          0.471962 * size,\n          0,\n          0.528036 * size,\n          0\n        )\n        grad.addColorStop(0, ptrColor.light.getRgbaColor())\n        grad.addColorStop(0.5, ptrColor.light.getRgbaColor())\n        grad.addColorStop(0.5, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(1, ptrColor.medium.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.strokeStyle = ptrColor.medium.getRgbaColor()\n        ptrCtx.lineWidth = 1\n        ptrCtx.lineCap = 'square'\n        ptrCtx.lineJoin = 'miter'\n        ptrCtx.fill()\n        ptrCtx.stroke()\n        break\n\n      case 'type11':\n        // POINTER_TYPE11\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(0.5 * size, 0.168224 * size)\n        ptrCtx.lineTo(0.485981 * size, 0.5 * size)\n        ptrCtx.bezierCurveTo(\n          0.485981 * size,\n          0.5 * size,\n          0.481308 * size,\n          0.584112 * size,\n          0.5 * size,\n          0.584112 * size\n        )\n        ptrCtx.bezierCurveTo(\n          0.514018 * size,\n          0.584112 * size,\n          0.509345 * size,\n          0.5 * size,\n          0.509345 * size,\n          0.5 * size\n        )\n        ptrCtx.lineTo(0.5 * size, 0.168224 * size)\n        ptrCtx.closePath()\n        grad = ptrCtx.createLinearGradient(\n          0,\n          0.168224 * size,\n          0,\n          0.584112 * size\n        )\n        grad.addColorStop(0, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(1, ptrColor.dark.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor()\n        ptrCtx.fill()\n        ptrCtx.stroke()\n        break\n\n      case 'type12':\n        // POINTER_TYPE12\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(0.5 * size, 0.168224 * size)\n        ptrCtx.lineTo(0.485981 * size, 0.5 * size)\n        ptrCtx.lineTo(0.5 * size, 0.504672 * size)\n        ptrCtx.lineTo(0.509345 * size, 0.5 * size)\n        ptrCtx.lineTo(0.5 * size, 0.168224 * size)\n        ptrCtx.closePath()\n        grad = ptrCtx.createLinearGradient(\n          0,\n          0.168224 * size,\n          0,\n          0.504672 * size\n        )\n        grad.addColorStop(0, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(1, ptrColor.dark.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor()\n        ptrCtx.fill()\n        ptrCtx.stroke()\n        break\n\n      case 'type13':\n      // POINTER_TYPE13\n      // eslint-disable-next-line no-fallthrough\n      case 'type14':\n        // POINTER_TYPE14 (same shape as 13)\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(0.485981 * size, 0.168224 * size)\n        ptrCtx.lineTo(0.5 * size, 0.130841 * size)\n        ptrCtx.lineTo(0.509345 * size, 0.168224 * size)\n        ptrCtx.lineTo(0.509345 * size, 0.509345 * size)\n        ptrCtx.lineTo(0.485981 * size, 0.509345 * size)\n        ptrCtx.lineTo(0.485981 * size, 0.168224 * size)\n        ptrCtx.closePath()\n        if (ptrType.type === 'type13') {\n          // TYPE13\n          grad = ptrCtx.createLinearGradient(0, 0.5 * size, 0, 0.130841 * size)\n          grad.addColorStop(0, lblColor.getRgbaColor())\n          grad.addColorStop(0.85, lblColor.getRgbaColor())\n          grad.addColorStop(0.85, ptrColor.medium.getRgbaColor())\n          grad.addColorStop(1, ptrColor.medium.getRgbaColor())\n          ptrCtx.fillStyle = grad\n        } else {\n          // TYPE14\n          grad = ptrCtx.createLinearGradient(\n            0.485981 * size,\n            0,\n            0.509345 * size,\n            0\n          )\n          grad.addColorStop(0, ptrColor.veryDark.getRgbaColor())\n          grad.addColorStop(0.5, ptrColor.light.getRgbaColor())\n          grad.addColorStop(1, ptrColor.veryDark.getRgbaColor())\n          ptrCtx.fillStyle = grad\n        }\n        ptrCtx.fill()\n        break\n\n      case 'type15':\n      // POINTER TYPE15 - Classic with crescent\n      // eslint-disable-next-line no-fallthrough\n      case 'type16':\n        // POINTER TYPE16 - Classic without crescent\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.509345, size * 0.457943)\n        ptrCtx.lineTo(size * 0.5015, size * 0.13)\n        ptrCtx.lineTo(size * 0.4985, size * 0.13)\n        ptrCtx.lineTo(size * 0.490654, size * 0.457943)\n        ptrCtx.bezierCurveTo(\n          size * 0.490654,\n          size * 0.457943,\n          size * 0.490654,\n          size * 0.457943,\n          size * 0.490654,\n          size * 0.457943\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.471962,\n          size * 0.462616,\n          size * 0.457943,\n          size * 0.481308,\n          size * 0.457943,\n          size * 0.5\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.457943,\n          size * 0.518691,\n          size * 0.471962,\n          size * 0.537383,\n          size * 0.490654,\n          size * 0.542056\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.490654,\n          size * 0.542056,\n          size * 0.490654,\n          size * 0.542056,\n          size * 0.490654,\n          size * 0.542056\n        )\n        if (ptrType.type === 'type15') {\n          ptrCtx.lineTo(size * 0.490654, size * 0.57)\n          ptrCtx.bezierCurveTo(\n            size * 0.46,\n            size * 0.58,\n            size * 0.46,\n            size * 0.62,\n            size * 0.490654,\n            size * 0.63\n          )\n          ptrCtx.bezierCurveTo(\n            size * 0.47,\n            size * 0.62,\n            size * 0.48,\n            size * 0.59,\n            size * 0.5,\n            size * 0.59\n          )\n          ptrCtx.bezierCurveTo(\n            size * 0.53,\n            size * 0.59,\n            size * 0.52,\n            size * 0.62,\n            size * 0.509345,\n            size * 0.63\n          )\n          ptrCtx.bezierCurveTo(\n            size * 0.54,\n            size * 0.62,\n            size * 0.54,\n            size * 0.58,\n            size * 0.509345,\n            size * 0.57\n          )\n          ptrCtx.lineTo(size * 0.509345, size * 0.57)\n        } else {\n          ptrCtx.lineTo(size * 0.490654, size * 0.621495)\n          ptrCtx.lineTo(size * 0.509345, size * 0.621495)\n        }\n        ptrCtx.lineTo(size * 0.509345, size * 0.542056)\n        ptrCtx.bezierCurveTo(\n          size * 0.509345,\n          size * 0.542056,\n          size * 0.509345,\n          size * 0.542056,\n          size * 0.509345,\n          size * 0.542056\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.528037,\n          size * 0.537383,\n          size * 0.542056,\n          size * 0.518691,\n          size * 0.542056,\n          size * 0.5\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.542056,\n          size * 0.481308,\n          size * 0.528037,\n          size * 0.462616,\n          size * 0.509345,\n          size * 0.457943\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.509345,\n          size * 0.457943,\n          size * 0.509345,\n          size * 0.457943,\n          size * 0.509345,\n          size * 0.457943\n        )\n        ptrCtx.closePath()\n        if (ptrType.type === 'type15') {\n          grad = ptrCtx.createLinearGradient(0, 0, 0, size * 0.63)\n        } else {\n          grad = ptrCtx.createLinearGradient(0, 0, 0, size * 0.621495)\n        }\n        grad.addColorStop(0, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(0.388888, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(0.5, ptrColor.light.getRgbaColor())\n        grad.addColorStop(0.611111, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(1, ptrColor.medium.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor()\n        ptrCtx.fill()\n        ptrCtx.stroke()\n        // Draw the rings\n        ptrCtx.beginPath()\n        radius = (size * 0.06542) / 2\n        ptrCtx.arc(size * 0.5, size * 0.5, radius, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"])\n        grad = ptrCtx.createLinearGradient(\n          size * 0.5 - radius,\n          size * 0.5 + radius,\n          0,\n          size * 0.5 + radius\n        )\n        grad.addColorStop(0, '#e6b35c')\n        grad.addColorStop(0.01, '#e6b35c')\n        grad.addColorStop(0.99, '#c48200')\n        grad.addColorStop(1, '#c48200')\n        ptrCtx.fillStyle = grad\n        ptrCtx.closePath()\n        ptrCtx.fill()\n        ptrCtx.beginPath()\n        radius = (size * 0.046728) / 2\n        ptrCtx.arc(size * 0.5, size * 0.5, radius, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"])\n        grad = ptrCtx.createRadialGradient(\n          size * 0.5,\n          size * 0.5,\n          0,\n          size * 0.5,\n          size * 0.5,\n          radius\n        )\n        grad.addColorStop(0, '#c5c5c5')\n        grad.addColorStop(0.19, '#c5c5c5')\n        grad.addColorStop(0.22, '#000000')\n        grad.addColorStop(0.8, '#000000')\n        grad.addColorStop(0.99, '#707070')\n        grad.addColorStop(1, '#707070')\n        ptrCtx.fillStyle = grad\n        ptrCtx.closePath()\n        ptrCtx.fill()\n        break\n\n      case 'type1':\n      /* falls through */\n      default:\n        grad = ptrCtx.createLinearGradient(\n          0,\n          size * 0.471962,\n          0,\n          size * 0.130841\n        )\n        grad.addColorStop(0, ptrColor.veryDark.getRgbaColor())\n        grad.addColorStop(0.3, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(0.59, ptrColor.medium.getRgbaColor())\n        grad.addColorStop(1, ptrColor.veryDark.getRgbaColor())\n        ptrCtx.fillStyle = grad\n        ptrCtx.beginPath()\n        ptrCtx.moveTo(size * 0.518691, size * 0.471962)\n        ptrCtx.bezierCurveTo(\n          size * 0.514018,\n          size * 0.457943,\n          size * 0.509345,\n          size * 0.415887,\n          size * 0.509345,\n          size * 0.401869\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.504672,\n          size * 0.383177,\n          size * 0.5,\n          size * 0.130841,\n          size * 0.5,\n          size * 0.130841\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.5,\n          size * 0.130841,\n          size * 0.490654,\n          size * 0.383177,\n          size * 0.490654,\n          size * 0.397196\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.490654,\n          size * 0.415887,\n          size * 0.485981,\n          size * 0.457943,\n          size * 0.481308,\n          size * 0.471962\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.471962,\n          size * 0.481308,\n          size * 0.467289,\n          size * 0.490654,\n          size * 0.467289,\n          size * 0.5\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.467289,\n          size * 0.518691,\n          size * 0.481308,\n          size * 0.53271,\n          size * 0.5,\n          size * 0.53271\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.518691,\n          size * 0.53271,\n          size * 0.53271,\n          size * 0.518691,\n          size * 0.53271,\n          size * 0.5\n        )\n        ptrCtx.bezierCurveTo(\n          size * 0.53271,\n          size * 0.490654,\n          size * 0.528037,\n          size * 0.481308,\n          size * 0.518691,\n          size * 0.471962\n        )\n        ptrCtx.closePath()\n        ptrCtx.fill()\n        break\n    }\n    // cache buffer\n    drawPointerImage.cache[cacheKey] = ptrBuffer\n  }\n  ctx.drawImage(drawPointerImage.cache[cacheKey], 0, 0)\n  return this\n}\ndrawPointerImage.cache = {}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawPointerImage);\n\n\n//# sourceURL=webpack://steelseries/./src/drawPointerImage.js?");

/***/ }),

/***/ "./src/drawRadialCustomImage.js":
/*!**************************************!*\
  !*** ./src/drawRadialCustomImage.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst drawRadialCustomImage = function (\n  ctx,\n  img,\n  centerX,\n  centerY,\n  imageWidth,\n  imageHeight\n) {\n  const drawWidth = imageWidth * 0.831775\n  const drawHeight = imageHeight * 0.831775\n  const x = (imageWidth - drawWidth) / 2\n  const y = (imageHeight - drawHeight) / 2\n\n  if (img !== null && img.height > 0 && img.width > 0) {\n    ctx.save()\n    // Set the clipping area\n    ctx.beginPath()\n    ctx.arc(centerX, centerY, (imageWidth * 0.831775) / 2, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], true)\n    ctx.clip()\n    // Add the image\n    ctx.drawImage(img, x, y, drawWidth, drawHeight)\n    ctx.restore()\n  }\n  return this\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawRadialCustomImage);\n\n\n//# sourceURL=webpack://steelseries/./src/drawRadialCustomImage.js?");

/***/ }),

/***/ "./src/drawRoseImage.js":
/*!******************************!*\
  !*** ./src/drawRoseImage.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst drawRoseImage = function (\n  ctx,\n  centerX,\n  centerY,\n  imageWidth,\n  imageHeight,\n  backgroundColor\n) {\n  let fill = true\n  let i\n  let grad\n  const symbolColor = backgroundColor.symbolColor.getRgbaColor()\n\n  ctx.save()\n  ctx.lineWidth = 1\n  ctx.fillStyle = symbolColor\n  ctx.strokeStyle = symbolColor\n  ctx.translate(centerX, centerY)\n  // broken ring\n  for (i = 0; i < 360; i += 15) {\n    fill = !fill\n\n    ctx.beginPath()\n    ctx.arc(\n      0,\n      0,\n      imageWidth * 0.26,\n      i * _tools__WEBPACK_IMPORTED_MODULE_0__[\"RAD_FACTOR\"],\n      (i + 15) * _tools__WEBPACK_IMPORTED_MODULE_0__[\"RAD_FACTOR\"],\n      false\n    )\n    ctx.arc(\n      0,\n      0,\n      imageWidth * 0.23,\n      (i + 15) * _tools__WEBPACK_IMPORTED_MODULE_0__[\"RAD_FACTOR\"],\n      i * _tools__WEBPACK_IMPORTED_MODULE_0__[\"RAD_FACTOR\"],\n      true\n    )\n    ctx.closePath()\n    if (fill) {\n      ctx.fill()\n    }\n    ctx.stroke()\n  }\n\n  ctx.translate(-centerX, -centerY)\n\n  for (i = 0; i <= 360; i += 90) {\n    // Small pointers\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.560747, imageHeight * 0.584112)\n    ctx.lineTo(imageWidth * 0.640186, imageHeight * 0.644859)\n    ctx.lineTo(imageWidth * 0.584112, imageHeight * 0.560747)\n    ctx.lineTo(imageWidth * 0.560747, imageHeight * 0.584112)\n    ctx.closePath()\n    ctx.fillStyle = symbolColor\n    ctx.fill()\n    ctx.stroke()\n    // Large pointers\n    ctx.beginPath()\n    ctx.moveTo(imageWidth * 0.523364, imageHeight * 0.397196)\n    ctx.lineTo(imageWidth * 0.5, imageHeight * 0.196261)\n    ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.397196)\n    ctx.lineTo(imageWidth * 0.523364, imageHeight * 0.397196)\n    ctx.closePath()\n    grad = ctx.createLinearGradient(\n      0.476635 * imageWidth,\n      0,\n      0.518691 * imageWidth,\n      0\n    )\n    grad.addColorStop(0, 'rgb(222, 223, 218)')\n    grad.addColorStop(0.48, 'rgb(222, 223, 218)')\n    grad.addColorStop(0.49, symbolColor)\n    grad.addColorStop(1, symbolColor)\n    ctx.fillStyle = grad\n    ctx.fill()\n    ctx.stroke()\n    ctx.translate(centerX, centerY)\n    ctx.rotate(i * _tools__WEBPACK_IMPORTED_MODULE_0__[\"RAD_FACTOR\"])\n    ctx.translate(-centerX, -centerY)\n  }\n\n  // Central ring\n  ctx.beginPath()\n  ctx.translate(centerX, centerY)\n  ctx.arc(0, 0, imageWidth * 0.1, 0, _tools__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"], false)\n  ctx.lineWidth = imageWidth * 0.022\n  ctx.stroke()\n  ctx.translate(-centerX, -centerY)\n\n  ctx.restore()\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawRoseImage);\n\n\n//# sourceURL=webpack://steelseries/./src/drawRoseImage.js?");

/***/ }),

/***/ "./src/drawTitleImage.js":
/*!*******************************!*\
  !*** ./src/drawTitleImage.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n\n\n\n\nconst drawTitleImage = function (\n  ctx,\n  imageWidth,\n  imageHeight,\n  titleString,\n  unitString,\n  backgroundColor,\n  vertical,\n  radial,\n  altPos,\n  gaugeType\n) {\n  gaugeType =\n    undefined === gaugeType ? (gaugeType = _definitions__WEBPACK_IMPORTED_MODULE_1__[\"GaugeType\"].TYPE1) : gaugeType\n  ctx.save()\n  ctx.textAlign = radial ? 'center' : 'left'\n  ctx.textBaseline = 'middle'\n  ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor()\n  ctx.fillStyle = backgroundColor.labelColor.getRgbaColor()\n\n  if (radial) {\n    ctx.font = 0.046728 * imageWidth + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_0__[\"stdFontName\"]\n    ctx.fillText(\n      titleString,\n      imageWidth / 2,\n      imageHeight * 0.3,\n      imageWidth * 0.3\n    )\n    ctx.fillText(\n      unitString,\n      imageWidth / 2,\n      imageHeight * 0.38,\n      imageWidth * 0.3\n    )\n  } else {\n    // linear\n    if (vertical) {\n      ctx.font = 0.1 * imageWidth + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_0__[\"stdFontName\"]\n      ctx.save()\n      ctx.translate(0.671428 * imageWidth, 0.1375 * imageHeight)\n      ctx.rotate(1.570796)\n      ctx.fillText(titleString, 0, 0)\n      ctx.translate(-0.671428 * imageWidth, -0.1375 * imageHeight)\n      ctx.restore()\n      ctx.font = 0.071428 * imageWidth + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_0__[\"stdFontName\"]\n      if (altPos) {\n        // LCD visible\n        if (gaugeType.type === 'type2') {\n          ctx.textAlign = 'right'\n          ctx.fillText(\n            unitString,\n            0.36 * imageWidth,\n            imageHeight * 0.79,\n            imageWidth * 0.25\n          )\n        } else {\n          ctx.fillText(\n            unitString,\n            0.63 * imageWidth,\n            imageHeight * 0.85,\n            imageWidth * 0.2\n          )\n        }\n      } else {\n        // LCD hidden\n        ctx.textAlign = 'center'\n        if (gaugeType.type === 'type2') {\n          ctx.fillText(\n            unitString,\n            imageWidth / 2,\n            imageHeight * 0.92,\n            imageWidth * 0.2\n          )\n        } else {\n          ctx.fillText(\n            unitString,\n            imageWidth / 2,\n            imageHeight * 0.89,\n            imageWidth * 0.2\n          )\n        }\n      }\n    } else {\n      // linear horizontal\n      ctx.font = 0.035 * imageWidth + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_0__[\"stdFontName\"]\n      ctx.fillText(\n        titleString,\n        imageWidth * 0.15,\n        imageHeight * 0.25,\n        imageWidth * 0.3\n      )\n      ctx.font = 0.025 * imageWidth + 'px ' + _tools__WEBPACK_IMPORTED_MODULE_0__[\"stdFontName\"]\n      ctx.fillText(\n        unitString,\n        imageWidth * 0.0625,\n        imageHeight * 0.7,\n        imageWidth * 0.07\n      )\n    }\n  }\n  ctx.restore()\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (drawTitleImage);\n\n\n//# sourceURL=webpack://steelseries/./src/drawTitleImage.js?");

/***/ }),

/***/ "./src/punchedSheetBuffer.js":
/*!***********************************!*\
  !*** ./src/punchedSheetBuffer.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n\n\nconst punchedSheetBuffer = Object(_tools__WEBPACK_IMPORTED_MODULE_0__[\"drawToBuffer\"])(15, 15, function (ctx) {\n  const imageWidth = ctx.canvas.width\n  const imageHeight = ctx.canvas.height\n  let grad\n\n  ctx.save()\n\n  // BACK\n  ctx.save()\n  ctx.beginPath()\n  ctx.rect(0, 0, imageWidth, imageHeight)\n  ctx.closePath()\n  ctx.restore()\n  ctx.fillStyle = '#1D2123'\n  ctx.fill()\n\n  // ULB\n  ctx.save()\n  ctx.beginPath()\n  ctx.moveTo(0, imageHeight * 0.266666)\n  ctx.bezierCurveTo(\n    0,\n    imageHeight * 0.4,\n    imageWidth * 0.066666,\n    imageHeight * 0.466666,\n    imageWidth * 0.2,\n    imageHeight * 0.466666\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.333333,\n    imageHeight * 0.466666,\n    imageWidth * 0.4,\n    imageHeight * 0.4,\n    imageWidth * 0.4,\n    imageHeight * 0.266666\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.4,\n    imageHeight * 0.133333,\n    imageWidth * 0.333333,\n    imageHeight * 0.066666,\n    imageWidth * 0.2,\n    imageHeight * 0.066666\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.066666,\n    imageHeight * 0.066666,\n    0,\n    imageHeight * 0.133333,\n    0,\n    imageHeight * 0.266666\n  )\n  ctx.closePath()\n  grad = ctx.createLinearGradient(\n    0,\n    0.066666 * imageHeight,\n    0,\n    0.466666 * imageHeight\n  )\n  grad.addColorStop(0, '#000000')\n  grad.addColorStop(1, '#444444')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  // ULF\n  ctx.save()\n  ctx.beginPath()\n  ctx.moveTo(0, imageHeight * 0.2)\n  ctx.bezierCurveTo(\n    0,\n    imageHeight * 0.333333,\n    imageWidth * 0.066666,\n    imageHeight * 0.4,\n    imageWidth * 0.2,\n    imageHeight * 0.4\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.333333,\n    imageHeight * 0.4,\n    imageWidth * 0.4,\n    imageHeight * 0.333333,\n    imageWidth * 0.4,\n    imageHeight * 0.2\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.4,\n    imageHeight * 0.066666,\n    imageWidth * 0.333333,\n    0,\n    imageWidth * 0.2,\n    0\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.066666,\n    0,\n    0,\n    imageHeight * 0.066666,\n    0,\n    imageHeight * 0.2\n  )\n  ctx.closePath()\n  ctx.fillStyle = '#050506'\n  ctx.fill()\n\n  // LRB\n  ctx.save()\n  ctx.beginPath()\n  ctx.moveTo(imageWidth * 0.466666, imageHeight * 0.733333)\n  ctx.bezierCurveTo(\n    imageWidth * 0.466666,\n    imageHeight * 0.866666,\n    imageWidth * 0.533333,\n    imageHeight * 0.933333,\n    imageWidth * 0.666666,\n    imageHeight * 0.933333\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.8,\n    imageHeight * 0.933333,\n    imageWidth * 0.866666,\n    imageHeight * 0.866666,\n    imageWidth * 0.866666,\n    imageHeight * 0.733333\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.866666,\n    imageHeight * 0.6,\n    imageWidth * 0.8,\n    imageHeight * 0.533333,\n    imageWidth * 0.666666,\n    imageHeight * 0.533333\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.533333,\n    imageHeight * 0.533333,\n    imageWidth * 0.466666,\n    imageHeight * 0.6,\n    imageWidth * 0.466666,\n    imageHeight * 0.733333\n  )\n  ctx.closePath()\n  grad = ctx.createLinearGradient(\n    0,\n    0.533333 * imageHeight,\n    0,\n    0.933333 * imageHeight\n  )\n  grad.addColorStop(0, '#000000')\n  grad.addColorStop(1, '#444444')\n  ctx.fillStyle = grad\n  ctx.fill()\n\n  // LRF\n  ctx.save()\n  ctx.beginPath()\n  ctx.moveTo(imageWidth * 0.466666, imageHeight * 0.666666)\n  ctx.bezierCurveTo(\n    imageWidth * 0.466666,\n    imageHeight * 0.8,\n    imageWidth * 0.533333,\n    imageHeight * 0.866666,\n    imageWidth * 0.666666,\n    imageHeight * 0.866666\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.8,\n    imageHeight * 0.866666,\n    imageWidth * 0.866666,\n    imageHeight * 0.8,\n    imageWidth * 0.866666,\n    imageHeight * 0.666666\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.866666,\n    imageHeight * 0.533333,\n    imageWidth * 0.8,\n    imageHeight * 0.466666,\n    imageWidth * 0.666666,\n    imageHeight * 0.466666\n  )\n  ctx.bezierCurveTo(\n    imageWidth * 0.533333,\n    imageHeight * 0.466666,\n    imageWidth * 0.466666,\n    imageHeight * 0.533333,\n    imageWidth * 0.466666,\n    imageHeight * 0.666666\n  )\n  ctx.closePath()\n  ctx.fillStyle = '#050506'\n  ctx.fill()\n\n  ctx.restore()\n})\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (punchedSheetBuffer);\n\n\n//# sourceURL=webpack://steelseries/./src/punchedSheetBuffer.js?");

/***/ }),

/***/ "./src/steelseries.js":
/*!****************************!*\
  !*** ./src/steelseries.js ***!
  \****************************/
/*! exports provided: Radial, RadialBargraph, RadialVertical, Linear, LinearBargraph, DisplaySingle, DisplayMulti, Level, Compass, WindDirection, Horizon, Led, Clock, Battery, StopWatch, Altimeter, TrafficLight, LightBulb, Odometer, drawFrame, drawBackground, drawForeground, rgbaColor, ConicalGradient, setAlpha, getColorFromFraction, gradientWrapper, BackgroundColor, LcdColor, ColorDef, LedColor, GaugeType, Orientation, FrameDesign, PointerType, ForegroundType, KnobType, KnobStyle, LabelNumberFormat, TickLabelOrientation, TrendState, Section */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Radial */ \"./src/Radial.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Radial\", function() { return _Radial__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _RadialBargraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RadialBargraph */ \"./src/RadialBargraph.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RadialBargraph\", function() { return _RadialBargraph__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _RadialVertical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RadialVertical */ \"./src/RadialVertical.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RadialVertical\", function() { return _RadialVertical__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _Linear__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Linear */ \"./src/Linear.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Linear\", function() { return _Linear__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _LinearBargraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LinearBargraph */ \"./src/LinearBargraph.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LinearBargraph\", function() { return _LinearBargraph__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _DisplaySingle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DisplaySingle */ \"./src/DisplaySingle.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DisplaySingle\", function() { return _DisplaySingle__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var _DisplayMulti__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DisplayMulti */ \"./src/DisplayMulti.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DisplayMulti\", function() { return _DisplayMulti__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n/* harmony import */ var _Level__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Level */ \"./src/Level.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Level\", function() { return _Level__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _Compass__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Compass */ \"./src/Compass.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Compass\", function() { return _Compass__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony import */ var _WindDirection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./WindDirection */ \"./src/WindDirection.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WindDirection\", function() { return _WindDirection__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n/* harmony import */ var _Horizon__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Horizon */ \"./src/Horizon.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Horizon\", function() { return _Horizon__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\n/* harmony import */ var _Led__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Led */ \"./src/Led.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Led\", function() { return _Led__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Clock */ \"./src/Clock.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Clock\", function() { return _Clock__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; });\n\n/* harmony import */ var _Battery__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Battery */ \"./src/Battery.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Battery\", function() { return _Battery__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; });\n\n/* harmony import */ var _StopWatch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./StopWatch */ \"./src/StopWatch.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StopWatch\", function() { return _StopWatch__WEBPACK_IMPORTED_MODULE_14__[\"default\"]; });\n\n/* harmony import */ var _Altimeter__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Altimeter */ \"./src/Altimeter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Altimeter\", function() { return _Altimeter__WEBPACK_IMPORTED_MODULE_15__[\"default\"]; });\n\n/* harmony import */ var _TrafficLight__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./TrafficLight */ \"./src/TrafficLight.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TrafficLight\", function() { return _TrafficLight__WEBPACK_IMPORTED_MODULE_16__[\"default\"]; });\n\n/* harmony import */ var _LightBulb__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./LightBulb */ \"./src/LightBulb.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LightBulb\", function() { return _LightBulb__WEBPACK_IMPORTED_MODULE_17__[\"default\"]; });\n\n/* harmony import */ var _Odometer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Odometer */ \"./src/Odometer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Odometer\", function() { return _Odometer__WEBPACK_IMPORTED_MODULE_18__[\"default\"]; });\n\n/* harmony import */ var _drawFrame__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./drawFrame */ \"./src/drawFrame.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"drawFrame\", function() { return _drawFrame__WEBPACK_IMPORTED_MODULE_19__[\"default\"]; });\n\n/* harmony import */ var _drawBackground__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./drawBackground */ \"./src/drawBackground.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"drawBackground\", function() { return _drawBackground__WEBPACK_IMPORTED_MODULE_20__[\"default\"]; });\n\n/* harmony import */ var _drawForeground__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./drawForeground */ \"./src/drawForeground.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"drawForeground\", function() { return _drawForeground__WEBPACK_IMPORTED_MODULE_21__[\"default\"]; });\n\n/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./tools */ \"./src/tools.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rgbaColor\", function() { return _tools__WEBPACK_IMPORTED_MODULE_22__[\"rgbaColor\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ConicalGradient\", function() { return _tools__WEBPACK_IMPORTED_MODULE_22__[\"ConicalGradient\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"setAlpha\", function() { return _tools__WEBPACK_IMPORTED_MODULE_22__[\"setAlpha\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getColorFromFraction\", function() { return _tools__WEBPACK_IMPORTED_MODULE_22__[\"getColorFromFraction\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"gradientWrapper\", function() { return _tools__WEBPACK_IMPORTED_MODULE_22__[\"gradientWrapper\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Section\", function() { return _tools__WEBPACK_IMPORTED_MODULE_22__[\"Section\"]; });\n\n/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./definitions */ \"./src/definitions.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BackgroundColor\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"BackgroundColor\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LcdColor\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"LcdColor\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ColorDef\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"ColorDef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LedColor\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"LedColor\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GaugeType\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"GaugeType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Orientation\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"Orientation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FrameDesign\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"FrameDesign\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PointerType\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"PointerType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ForegroundType\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"ForegroundType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"KnobType\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"KnobType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"KnobStyle\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"KnobStyle\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LabelNumberFormat\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"LabelNumberFormat\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TickLabelOrientation\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"TickLabelOrientation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TrendState\", function() { return _definitions__WEBPACK_IMPORTED_MODULE_23__[\"TrendState\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Images\n\n\n\n\n// Tools\n\n\n\n\n\n\n// Constants\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Other\n\n\n\n//# sourceURL=webpack://steelseries/./src/steelseries.js?");

/***/ }),

/***/ "./src/tools.js":
/*!**********************!*\
  !*** ./src/tools.js ***!
  \**********************/
/*! exports provided: HALF_PI, TWO_PI, PI, RAD_FACTOR, DEG_FACTOR, doc, lcdFontName, stdFontName, rgbaColor, ConicalGradient, gradientWrapper, setAlpha, getColorFromFraction, Section, calcNiceNumber, roundedRectangle, createBuffer, drawToBuffer, getColorValues, customColorDef, rgbToHsl, hsbToRgb, rgbToHsb, range, darker, lighter, wrap, getShortestAngle, requestAnimFrame, getCanvasContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HALF_PI\", function() { return HALF_PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TWO_PI\", function() { return TWO_PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PI\", function() { return PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RAD_FACTOR\", function() { return RAD_FACTOR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEG_FACTOR\", function() { return DEG_FACTOR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"doc\", function() { return doc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lcdFontName\", function() { return lcdFontName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stdFontName\", function() { return stdFontName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgbaColor\", function() { return rgbaColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConicalGradient\", function() { return ConicalGradient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gradientWrapper\", function() { return gradientWrapper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAlpha\", function() { return setAlpha; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getColorFromFraction\", function() { return getColorFromFraction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Section\", function() { return Section; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calcNiceNumber\", function() { return calcNiceNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"roundedRectangle\", function() { return roundedRectangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createBuffer\", function() { return createBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"drawToBuffer\", function() { return drawToBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getColorValues\", function() { return getColorValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"customColorDef\", function() { return customColorDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgbToHsl\", function() { return rgbToHsl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hsbToRgb\", function() { return hsbToRgb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgbToHsb\", function() { return rgbToHsb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"range\", function() { return range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"darker\", function() { return darker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lighter\", function() { return lighter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrap\", function() { return wrap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getShortestAngle\", function() { return getShortestAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requestAnimFrame\", function() { return requestAnimFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCanvasContext\", function() { return getCanvasContext; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\n\nconst HALF_PI = Math.PI * 0.5\nconst TWO_PI = Math.PI * 2\nconst PI = Math.PI\nconst RAD_FACTOR = Math.PI / 180\nconst DEG_FACTOR = 180 / Math.PI\nconst doc = document\nconst lcdFontName = 'LCDMono2Ultra,Arial,Verdana,sans-serif'\nconst stdFontName = 'Arial,Verdana,sans-serif'\n\nconst rgbaColor = function (r, g, b, a) {\n  let red\n  let green\n  let blue\n  let alpha\n\n  if (arguments.length === 1) {\n    // hexadecimal input #112233\n    b = parseInt(r.substr(5, 2), 16)\n    g = parseInt(r.substr(3, 2), 16)\n    r = parseInt(r.substr(1, 2), 16)\n    a = 1\n  } else if (arguments.length === 3) {\n    a = 1\n  }\n\n  function validateColors () {\n    red = range(r, 255)\n    green = range(g, 255)\n    blue = range(b, 255)\n    alpha = range(a, 1)\n  }\n\n  validateColors()\n\n  this.getRed = function () {\n    return red\n  }\n\n  this.setRed = function (r) {\n    red = range(r, 255)\n  }\n\n  this.getGreen = function () {\n    return green\n  }\n\n  this.setGreen = function (g) {\n    green = range(g, 255)\n  }\n\n  this.getBlue = function () {\n    return blue\n  }\n\n  this.setBlue = function (b) {\n    blue = range(b, 255)\n  }\n\n  this.getAlpha = function () {\n    return alpha\n  }\n\n  this.setAlpha = function (a) {\n    alpha = range(a, 1)\n  }\n\n  this.getRgbaColor = function () {\n    return 'rgba(' + red + ', ' + green + ', ' + blue + ', ' + alpha + ')'\n  }\n\n  this.getRgbColor = function () {\n    return 'rgb(' + red + ', ' + green + ', ' + blue + ')'\n  }\n\n  this.getHexColor = function () {\n    return '#' + red.toString(16) + green.toString(16) + blue.toString(16)\n  }\n}\n\nconst ConicalGradient = function (fractions, colors) {\n  const limit = fractions.length - 1\n  let i\n\n  // Pre-multipy fractions array into range -PI to PI\n  for (i = 0; i <= limit; i++) {\n    fractions[i] = TWO_PI * fractions[i] - PI\n  }\n\n  this.fillCircle = function (ctx, centerX, centerY, innerX, outerX) {\n    let angle\n    const radius = Math.ceil(outerX)\n    const diameter = radius * 2\n    let x\n    let y\n    let dx\n    let dy\n    let dy2\n    let distance\n    let indx\n    let pixColor\n\n    // Create pixel array\n    const pixels = ctx.createImageData(diameter, diameter)\n    const alpha = 255\n\n    for (y = 0; y < diameter; y++) {\n      dy = radius - y\n      dy2 = dy * dy\n      for (x = 0; x < diameter; x++) {\n        dx = x - radius\n        distance = Math.sqrt(dx * dx + dy2)\n        if (distance <= radius && distance >= innerX) {\n          // pixels are transparent by default, so only paint the ones we need\n          angle = Math.atan2(dx, dy)\n          for (i = 0; i < limit; i++) {\n            if (angle >= fractions[i] && angle < fractions[i + 1]) {\n              pixColor = getColorFromFraction(\n                colors[i],\n                colors[i + 1],\n                fractions[i + 1] - fractions[i],\n                angle - fractions[i],\n                true\n              )\n            }\n          }\n          // The pixel array is addressed as 4 elements per pixel [r,g,b,a]\n          // plot is 180 rotated from orginal method, so apply a simple invert (diameter - y)\n          indx = (diameter - y) * diameter * 4 + x * 4\n          pixels.data[indx] = pixColor[0]\n          pixels.data[indx + 1] = pixColor[1]\n          pixels.data[indx + 2] = pixColor[2]\n          pixels.data[indx + 3] = alpha\n        }\n      }\n    }\n\n    // Create a new buffer to apply the raw data so we can rotate it\n    const buffer = createBuffer(diameter, diameter)\n    const bufferCtx = buffer.getContext('2d')\n    bufferCtx.putImageData(pixels, 0, 0)\n    // Apply the image buffer\n    ctx.drawImage(buffer, centerX - radius, centerY - radius)\n  }\n\n  this.fillRect = function (\n    ctx,\n    centerX,\n    centerY,\n    width,\n    height,\n    thicknessX,\n    thicknessY\n  ) {\n    let angle\n    let x\n    let y\n    let dx\n    let dy\n    let indx\n    let pixColor\n\n    width = Math.ceil(width)\n    height = Math.ceil(height)\n    const width2 = width / 2\n    const height2 = height / 2\n    thicknessX = Math.ceil(thicknessX)\n    thicknessY = Math.ceil(thicknessY)\n\n    // Create pixel array\n    const pixels = ctx.createImageData(width, height)\n    const alpha = 255\n\n    for (y = 0; y < height; y++) {\n      dy = height2 - y\n      for (x = 0; x < width; x++) {\n        if (y > thicknessY && y <= height - thicknessY) {\n          // we are in the range where we only draw the sides\n          if (x > thicknessX && x < width - thicknessX) {\n            // we are in the empty 'middle', jump to the next edge\n            x = width - thicknessX\n          }\n        }\n        dx = x - width2\n        angle = Math.atan2(dx, dy)\n        for (i = 0; i < limit; i++) {\n          if (angle >= fractions[i] && angle < fractions[i + 1]) {\n            pixColor = getColorFromFraction(\n              colors[i],\n              colors[i + 1],\n              fractions[i + 1] - fractions[i],\n              angle - fractions[i],\n              true\n            )\n          }\n        }\n        // The pixel array is addressed as 4 elements per pixel [r,g,b,a]\n        // plot is 180 rotated from orginal method, so apply a simple invert (height - y)\n        indx = (height - y) * width * 4 + x * 4\n        pixels.data[indx] = pixColor[0]\n        pixels.data[indx + 1] = pixColor[0]\n        pixels.data[indx + 2] = pixColor[0]\n        pixels.data[indx + 3] = alpha\n      }\n    }\n    // Create a new buffer to apply the raw data so we can clip it when drawing to canvas\n    const buffer = createBuffer(width, height)\n    const bufferCtx = buffer.getContext('2d')\n    bufferCtx.putImageData(pixels, 0, 0)\n\n    // draw the buffer back to the canvas\n    ctx.drawImage(buffer, centerX - width2, centerY - height2)\n  }\n}\n\nconst gradientWrapper = function (start, end, fractions, colors) {\n  this.getColorAt = function (fraction) {\n    let lowerLimit = 0\n    let lowerIndex = 0\n    let upperLimit = 1\n    let upperIndex = 1\n    let i\n\n    fraction = fraction < 0 ? 0 : fraction > 1 ? 1 : fraction\n\n    for (i = 0; i < fractions.length; i++) {\n      if (fractions[i] < fraction && lowerLimit < fractions[i]) {\n        lowerLimit = fractions[i]\n        lowerIndex = i\n      }\n      if (fractions[i] === fraction) {\n        return colors[i]\n      }\n      if (fractions[i] > fraction && upperLimit >= fractions[i]) {\n        upperLimit = fractions[i]\n        upperIndex = i\n      }\n    }\n    const interpolationFraction = (fraction - lowerLimit) / (upperLimit - lowerLimit)\n    return getColorFromFraction(\n      colors[lowerIndex],\n      colors[upperIndex],\n      1,\n      interpolationFraction\n    )\n  }\n\n  this.getStart = function () {\n    return start\n  }\n\n  this.getEnd = function () {\n    return end\n  }\n}\n\nfunction setAlpha (hex, alpha) {\n  const hexColor = hex.charAt(0) === '#' ? hex.substring(1, 7) : hex\n  const red = parseInt(hexColor.substring(0, 2), 16)\n  const green = parseInt(hexColor.substring(2, 4), 16)\n  const blue = parseInt(hexColor.substring(4, 6), 16)\n  const color = 'rgba(' + red + ',' + green + ',' + blue + ',' + alpha + ')'\n\n  return color\n}\n\nfunction getColorFromFraction (\n  sourceColor,\n  destinationColor,\n  range,\n  fraction,\n  returnRawData\n) {\n  const INT_TO_FLOAT = 1 / 255\n  const sourceRed = sourceColor.getRed()\n  const sourceGreen = sourceColor.getGreen()\n  const sourceBlue = sourceColor.getBlue()\n  const sourceAlpha = sourceColor.getAlpha()\n\n  const deltaRed = destinationColor.getRed() - sourceRed\n  const deltaGreen = destinationColor.getGreen() - sourceGreen\n  const deltaBlue = destinationColor.getBlue() - sourceBlue\n  const deltaAlpha =\n    destinationColor.getAlpha() * INT_TO_FLOAT - sourceAlpha * INT_TO_FLOAT\n\n  const fractionRed = (deltaRed / range) * fraction\n  const fractionGreen = (deltaGreen / range) * fraction\n  const fractionBlue = (deltaBlue / range) * fraction\n  const fractionAlpha = (deltaAlpha / range) * fraction\n\n  returnRawData = returnRawData || false\n  if (returnRawData) {\n    return [\n      (sourceRed + fractionRed).toFixed(0),\n      (sourceGreen + fractionGreen).toFixed(0),\n      (sourceBlue + fractionBlue).toFixed(0),\n      sourceAlpha + fractionAlpha\n    ]\n  } else {\n    return new rgbaColor(\n      (sourceRed + fractionRed).toFixed(0),\n      (sourceGreen + fractionGreen).toFixed(0),\n      (sourceBlue + fractionBlue).toFixed(0),\n      sourceAlpha + fractionAlpha\n    )\n  }\n}\n\nfunction Section (start, stop, color) {\n  return {\n    start: start,\n    stop: stop,\n    color: color\n  }\n}\n\nMath.log10 = function (value) {\n  return Math.log(value) / Math.LN10\n}\n\nfunction calcNiceNumber (range, round) {\n  const exponent = Math.floor(Math.log10(range)) // exponent of range\n  const fraction = range / Math.pow(10, exponent) // fractional part of range\n  let niceFraction // nice, rounded fraction\n\n  if (round) {\n    if (fraction < 1.5) {\n      niceFraction = 1\n    } else if (fraction < 3) {\n      niceFraction = 2\n    } else if (fraction < 7) {\n      niceFraction = 5\n    } else {\n      niceFraction = 10\n    }\n  } else {\n    if (fraction <= 1) {\n      niceFraction = 1\n    } else if (fraction <= 2) {\n      niceFraction = 2\n    } else if (fraction <= 5) {\n      niceFraction = 5\n    } else {\n      niceFraction = 10\n    }\n  }\n  return niceFraction * Math.pow(10, exponent)\n}\n\nfunction roundedRectangle (ctx, x, y, w, h, radius) {\n  const r = x + w\n  const b = y + h\n  ctx.beginPath()\n  ctx.moveTo(x + radius, y)\n  ctx.lineTo(r - radius, y)\n  ctx.quadraticCurveTo(r, y, r, y + radius)\n  ctx.lineTo(r, y + h - radius)\n  ctx.quadraticCurveTo(r, b, r - radius, b)\n  ctx.lineTo(x + radius, b)\n  ctx.quadraticCurveTo(x, b, x, b - radius)\n  ctx.lineTo(x, y + radius)\n  ctx.quadraticCurveTo(x, y, x + radius, y)\n  ctx.closePath()\n  //        ctx.stroke();\n}\n\nfunction createBuffer (width, height) {\n  const buffer = doc.createElement('canvas')\n  buffer.width = width\n  buffer.height = height\n  return buffer\n}\n\nfunction drawToBuffer (width, height, drawFunction) {\n  const buffer = doc.createElement('canvas')\n  buffer.width = width\n  buffer.height = height\n  drawFunction(buffer.getContext('2d'))\n  return buffer\n}\n\nfunction getColorValues (color) {\n  const lookupBuffer = drawToBuffer(1, 1, function (ctx) {\n    ctx.fillStyle = color\n    ctx.beginPath()\n    ctx.rect(0, 0, 1, 1)\n    ctx.fill()\n  })\n  const colorData = lookupBuffer.getContext('2d').getImageData(0, 0, 2, 2).data\n\n  return [colorData[0], colorData[1], colorData[2], colorData[3]]\n}\n\nfunction customColorDef (color) {\n  const values = getColorValues(color)\n  const rgbaCol = new rgbaColor(values[0], values[1], values[2], values[3])\n\n  const VERY_DARK = darker(rgbaCol, 0.32)\n  const DARK = darker(rgbaCol, 0.62)\n  const LIGHT = lighter(rgbaCol, 0.84)\n  const LIGHTER = lighter(rgbaCol, 0.94)\n  const VERY_LIGHT = lighter(rgbaCol, 1)\n\n  return new _constants__WEBPACK_IMPORTED_MODULE_0__[\"ColorDef\"](VERY_DARK, DARK, rgbaCol, LIGHT, LIGHTER, VERY_LIGHT)\n}\n\nfunction rgbToHsl (red, green, blue) {\n  let hue\n  let saturation\n  let delta\n\n  red /= 255\n  green /= 255\n  blue /= 255\n\n  const max = Math.max(red, green, blue)\n  const min = Math.min(red, green, blue)\n  const lightness = (max + min) / 2\n\n  if (max === min) {\n    hue = saturation = 0 // achromatic\n  } else {\n    delta = max - min\n    saturation =\n      lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min)\n    switch (max) {\n      case red:\n        hue = (green - blue) / delta + (green < blue ? 6 : 0)\n        break\n      case green:\n        hue = (blue - red) / delta + 2\n        break\n      case blue:\n        hue = (red - green) / delta + 4\n        break\n    }\n    hue /= 6\n  }\n  return [hue, saturation, lightness]\n}\n\nfunction hsbToRgb (hue, saturation, brightness) {\n  let r\n  let g\n  let b\n  const i = Math.floor(hue * 6)\n  const f = hue * 6 - i\n  const p = brightness * (1 - saturation)\n  const q = brightness * (1 - f * saturation)\n  const t = brightness * (1 - (1 - f) * saturation)\n\n  switch (i % 6) {\n    case 0:\n      r = brightness\n      g = t\n      b = p\n      break\n    case 1:\n      r = q\n      g = brightness\n      b = p\n      break\n    case 2:\n      r = p\n      g = brightness\n      b = t\n      break\n    case 3:\n      r = p\n      g = q\n      b = brightness\n      break\n    case 4:\n      r = t\n      g = p\n      b = brightness\n      break\n    case 5:\n      r = brightness\n      g = p\n      b = q\n      break\n  }\n\n  return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)]\n}\n\nfunction rgbToHsb (r, g, b) {\n  let hue\n\n  r = r / 255\n  g = g / 255\n  b = b / 255\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n  const brightness = max\n  const delta = max - min\n  const saturation = max === 0 ? 0 : delta / max\n\n  if (max === min) {\n    hue = 0 // achromatic\n  } else {\n    switch (max) {\n      case r:\n        hue = (g - b) / delta + (g < b ? 6 : 0)\n        break\n      case g:\n        hue = (b - r) / delta + 2\n        break\n      case b:\n        hue = (r - g) / delta + 4\n        break\n    }\n    hue /= 6\n  }\n  return [hue, saturation, brightness]\n}\n\nfunction range (value, limit) {\n  return value < 0 ? 0 : value > limit ? limit : value\n}\n\nfunction darker (color, fraction) {\n  let red = Math.floor(color.getRed() * (1 - fraction))\n  let green = Math.floor(color.getGreen() * (1 - fraction))\n  let blue = Math.floor(color.getBlue() * (1 - fraction))\n\n  red = range(red, 255)\n  green = range(green, 255)\n  blue = range(blue, 255)\n\n  return new rgbaColor(red, green, blue, color.getAlpha())\n}\n\nfunction lighter (color, fraction) {\n  let red = Math.round(color.getRed() * (1 + fraction))\n  let green = Math.round(color.getGreen() * (1 + fraction))\n  let blue = Math.round(color.getBlue() * (1 + fraction))\n\n  red = range(red, 255)\n  green = range(green, 255)\n  blue = range(blue, 255)\n\n  return new rgbaColor(red, green, blue, color.getAlpha())\n}\n\nfunction wrap (value, lower, upper) {\n  if (upper <= lower) {\n    throw new Error('Rotary bounds are of negative or zero size')\n  }\n\n  const distance = upper - lower\n  const times = Math.floor((value - lower) / distance)\n\n  return value - times * distance\n}\n\nfunction getShortestAngle (from, to) {\n  return wrap(to - from, -180, 180)\n}\n\n// shim layer\nconst requestAnimFrame = (function () {\n  return (\n    window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    function (callback) {\n      window.setTimeout(callback, 1000 / 16)\n    }\n  )\n})()\n\nfunction getCanvasContext (elementOrId) {\n  const element =\n    typeof elementOrId === 'string' || elementOrId instanceof String\n      ? doc.getElementById(elementOrId)\n      : elementOrId\n  return element.getContext('2d')\n}\n\n\n//# sourceURL=webpack://steelseries/./src/tools.js?");

/***/ }),

/***/ "./src/tween.js":
/*!**********************!*\
  !*** ./src/tween.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** ********************************************************************\nTERMS OF USE - EASING EQUATIONS\nOpen source under the BSD License.\nCopyright (c) 2001 Robert Penner\nJavaScript version copyright (C) 2006 by Philippe Maegerman\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of the author nor the names of contributors may\nbe used to endorse or promote products derived from this software\nwithout specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*****************************************/\nfunction Delegate () {}\nDelegate.create = function (o, f) {\n  const a = []\n  let i\n  const l = arguments.length\n  for (i = 2; i < l; i++) {\n    a[i - 2] = arguments[i]\n  }\n  return function () {\n    const aP = [].concat(arguments, a)\n    f.apply(o, aP)\n  }\n}\n\n/*\nobject:\n  type:Object\n    The object you want to modify. It can be any object, a visual object that you want to animate\n    ( document.body.style ) or an anymous object ( new Object() ).\nproperty:\n  type:String\n    The property that is updated on the target object, it can be empty ('')\neasing:\n  type:Function\n    The easing that will be applied to motion.\nstart:\n  type:Number\n    Start value\nend:\n  type:Number\n    End value\nduration:\n  type:Number\n    Animation duration in seconds\nsuffixe:\n type:String\n   A string to append to the updated property ('%','pt','em' ...).\n*/\n\nconst Tween = function (obj, prop, func, begin, finish, duration, suffixe) {\n  this.init(obj, prop, func, begin, finish, duration, suffixe)\n}\nconst t = Tween.prototype\n\nt.obj = {}\nt.prop = ''\nt.func = function (t, b, c, d) {\n  return (c * t) / d + b\n}\nt.begin = 0\nt.change = 0\nt.prevTime = 0\nt.prevPos = 0\nt.looping = false\nt._duration = 0\nt._time = 0\nt._pos = 0\nt._position = 0\nt._startTime = 0\nt._finish = 0\nt.name = ''\nt.suffixe = ''\nt._listeners = []\nt.setTime = function (t) {\n  this.prevTime = this._time\n  if (t > this.getDuration()) {\n    if (this.looping) {\n      this.rewind(t - this._duration)\n      this.update()\n      this.broadcastMessage('onMotionLooped', {\n        target: this,\n        type: 'onMotionLooped'\n      })\n    } else {\n      this._time = this._duration\n      this.update()\n      this.stop()\n      this.broadcastMessage('onMotionFinished', {\n        target: this,\n        type: 'onMotionFinished'\n      })\n    }\n  } else if (t < 0) {\n    this.rewind()\n    this.update()\n  } else {\n    this._time = t\n    this.update()\n  }\n}\nt.getTime = function () {\n  return this._time\n}\nt.setDuration = function (d) {\n  this._duration = d === null || d <= 0 ? 100000 : d\n}\nt.getDuration = function () {\n  return this._duration\n}\nt.setPosition = function (p) {\n  this.prevPos = this._pos\n  const a = this.suffixe !== '' ? this.suffixe : ''\n  this.obj[this.prop] = Math.round(p) + a\n  this._pos = p\n  this.broadcastMessage('onMotionChanged', {\n    target: this,\n    type: 'onMotionChanged'\n  })\n}\nt.getPosition = function (t) {\n  if (t === undefined) {\n    t = this._time\n  }\n  return this.func(t, this.begin, this.change, this._duration)\n}\nt.setFinish = function (f) {\n  this.change = f - this.begin\n}\nt.getFinish = function () {\n  return this.begin + this.change\n}\nt.init = function (obj, prop, func, begin, finish, duration, suffixe) {\n  if (!arguments.length) {\n    return\n  }\n  this._listeners = []\n  this.addListener(this)\n  if (suffixe) {\n    this.suffixe = suffixe\n  }\n  this.obj = obj\n  this.prop = prop\n  this.begin = begin\n  this._pos = begin\n  this.setDuration(duration)\n  if (func !== null && func !== '') {\n    this.func = func\n  }\n  this.setFinish(finish)\n}\nt.start = function () {\n  this.rewind()\n  this.startEnterFrame()\n  this.broadcastMessage('onMotionStarted', {\n    target: this,\n    type: 'onMotionStarted'\n  })\n  // alert('in');\n}\nt.rewind = function (t) {\n  this.stop()\n  this._time = t === undefined ? 0 : t\n  this.fixTime()\n  this.update()\n}\nt.fforward = function () {\n  this._time = this._duration\n  this.fixTime()\n  this.update()\n}\nt.update = function () {\n  this.setPosition(this.getPosition(this._time))\n}\nt.startEnterFrame = function () {\n  this.stopEnterFrame()\n  this.isPlaying = true\n  this.onEnterFrame()\n}\nt.onEnterFrame = function () {\n  if (this.isPlaying) {\n    this.nextFrame()\n    // To get real smooth movement you have to set the timeout to 0 instead of 25\n    setTimeout(Delegate.create(this, this.onEnterFrame), 25)\n  }\n}\nt.nextFrame = function () {\n  this.setTime((this.getTimer() - this._startTime) / 1000)\n}\nt.stop = function () {\n  this.stopEnterFrame()\n  this.broadcastMessage('onMotionStopped', {\n    target: this,\n    type: 'onMotionStopped'\n  })\n}\nt.stopEnterFrame = function () {\n  this.isPlaying = false\n}\nt.playing = function () {\n  return this.isPlaying\n}\nt.continueTo = function (finish, duration) {\n  this.begin = this._pos\n  this.setFinish(finish)\n  if (this._duration !== undefined) {\n    this.setDuration(duration)\n  }\n  this.start()\n}\nt.resume = function () {\n  this.fixTime()\n  this.startEnterFrame()\n  this.broadcastMessage('onMotionResumed', {\n    target: this,\n    type: 'onMotionResumed'\n  })\n}\nt.yoyo = function () {\n  this.continueTo(this.begin, this._time)\n}\nt.addListener = function (o) {\n  this.removeListener(o)\n  return this._listeners.push(o)\n}\nt.removeListener = function (o) {\n  const a = this._listeners\n  let i = a.length\n  while (i--) {\n    if (a[i] === o) {\n      a.splice(i, 1)\n      return true\n    }\n  }\n  return false\n}\nt.broadcastMessage = function () {\n  const arr = []\n  let i\n  const a = this._listeners\n  const l = a.length\n  for (i = 0; i < arguments.length; i++) {\n    arr.push(arguments[i])\n  }\n  const e = arr.shift()\n\n  for (i = 0; i < l; i++) {\n    if (a[i][e]) {\n      a[i][e].apply(a[i], arr)\n    }\n  }\n}\nt.fixTime = function () {\n  this._startTime = this.getTimer() - this._time * 1000\n}\nt.getTimer = function () {\n  return new Date().getTime() - this._time\n}\nTween.backEaseIn = function (t, b, c, d, a, p) {\n  const s = 1.70158\n  return c * (t /= d) * t * ((s + 1) * t - s) + b\n}\nTween.backEaseOut = function (t, b, c, d, a, p) {\n  const s = 1.70158\n  return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b\n}\nTween.backEaseInOut = function (t, b, c, d, a, p) {\n  let s = 1.70158\n  if ((t /= d / 2) < 1) {\n    return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b\n  }\n  return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b\n}\nTween.elasticEaseIn = function (t, b, c, d, a, p) {\n  let s\n  if (t === 0) {\n    return b\n  }\n  if ((t /= d) === 1) {\n    return b + c\n  }\n  if (!p) {\n    p = d * 0.3\n  }\n  if (!a || a < Math.abs(c)) {\n    a = c\n    s = p / 4\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(c / a)\n  }\n\n  return (\n    -(\n      a *\n      Math.pow(2, 10 * (t -= 1)) *\n      Math.sin(((t * d - s) * (2 * Math.PI)) / p)\n    ) + b\n  )\n}\nTween.elasticEaseOut = function (t, b, c, d, a, p) {\n  let s\n  if (t === 0) {\n    return b\n  }\n  if ((t /= d) === 1) {\n    return b + c\n  }\n  if (!p) {\n    p = d * 0.3\n  }\n  if (!a || a < Math.abs(c)) {\n    a = c\n    s = p / 4\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(c / a)\n  }\n  return (\n    a * Math.pow(2, -10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) +\n    c +\n    b\n  )\n}\nTween.elasticEaseInOut = function (t, b, c, d, a, p) {\n  let s\n  if (t === 0) {\n    return b\n  }\n  if ((t /= d / 2) === 2) {\n    return b + c\n  }\n  if (!p) {\n    p = d * (0.3 * 1.5)\n  }\n  if (!a || a < Math.abs(c)) {\n    a = c\n    s = p / 4\n  } else {\n    s = (p / (2 * Math.PI)) * Math.asin(c / a)\n  }\n  if (t < 1) {\n    return (\n      -0.5 *\n        (a *\n          Math.pow(2, 10 * (t -= 1)) *\n          Math.sin(((t * d - s) * (2 * Math.PI)) / p)) +\n      b\n    )\n  }\n  return (\n    a *\n      Math.pow(2, -10 * (t -= 1)) *\n      Math.sin(((t * d - s) * (2 * Math.PI)) / p) *\n      0.5 +\n    c +\n    b\n  )\n}\nTween.bounceEaseOut = function (t, b, c, d) {\n  if ((t /= d) < 1 / 2.75) {\n    return c * (7.5625 * t * t) + b\n  } else if (t < 2 / 2.75) {\n    return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b\n  } else if (t < 2.5 / 2.75) {\n    return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b\n  } else {\n    return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b\n  }\n}\nTween.bounceEaseIn = function (t, b, c, d) {\n  return c - Tween.bounceEaseOut(d - t, 0, c, d) + b\n}\nTween.bounceEaseInOut = function (t, b, c, d) {\n  if (t < d / 2) {\n    return Tween.bounceEaseIn(t * 2, 0, c, d) * 0.5 + b\n  } else {\n    return Tween.bounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b\n  }\n}\nTween.strongEaseInOut = function (t, b, c, d) {\n  return c * (t /= d) * t * t * t * t + b\n}\nTween.regularEaseIn = function (t, b, c, d) {\n  return c * (t /= d) * t + b\n}\nTween.regularEaseOut = function (t, b, c, d) {\n  return -c * (t /= d) * (t - 2) + b\n}\nTween.regularEaseInOut = function (t, b, c, d) {\n  if ((t /= d / 2) < 1) {\n    return (c / 2) * t * t + b\n  }\n  return (-c / 2) * (--t * (t - 2) - 1) + b\n}\nTween.strongEaseIn = function (t, b, c, d) {\n  return c * (t /= d) * t * t * t * t + b\n}\nTween.strongEaseOut = function (t, b, c, d) {\n  return c * ((t = t / d - 1) * t * t * t * t + 1) + b\n}\nTween.strongEaseInOut = function (t, b, c, d) {\n  if ((t /= d / 2) < 1) {\n    return (c / 2) * t * t * t * t * t + b\n  }\n  return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Tween);\n\n\n//# sourceURL=webpack://steelseries/./src/tween.js?");

/***/ })

/******/ });
});
